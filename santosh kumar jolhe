#!/usr/bin/env python3
"""
Colony Maintenance Manager with Login + Modernized Look
Python 3.13 single-file app (Tkinter + SQLite)

Features added/changed:
 - Login screen before opening the main app
 - User creation (creates admin if none exists)
 - Passwords stored securely (salt + SHA-256)
 - Slightly modernized look using ttk styles and fonts
 - Backup saved to %APPDATA%\\colony_backups (Windows roaming folder)

Save as colony_manager_with_login.py and run with Python 3.13.
"""

import tkinter as tk
from tkinter import ttk, messagebox
import sqlite3
import os
import csv
import shutil
from datetime import datetime, date, timedelta
from pathlib import Path
import webbrowser
import hashlib
import secrets
import platform
import uuid
import sys  # Added for exit functionality
try:
    from tkcalendar import DateEntry
except ImportError:
    # If tkcalendar is not available, create a simple replacement
    class DateEntry(ttk.Entry):
        def __init__(self, *args, **kwargs):
            kwargs.pop('date_pattern', None)
            kwargs.pop('background', None)
            kwargs.pop('foreground', None)
            kwargs.pop('borderwidth', None)
            super().__init__(*args, **kwargs)

# --- Configuration ---
APPDATA_DIR = os.getenv("APPDATA") or os.path.join(Path.home(), "AppData", "Roaming")
APP_DATA_DIR = os.path.join(APPDATA_DIR, "ColonyMaintenanceManager")
DB_FILE = os.path.join(APP_DATA_DIR, "colony.db")
EXPORT_DIR = os.path.join(APP_DATA_DIR, "exports")
BACKUP_DIR = os.path.join(APP_DATA_DIR, "backups")
RECEIPT_DIR = os.path.join(APP_DATA_DIR, "receipts")
LICENSE_FILE = os.path.join(APP_DATA_DIR, "license.dat")
DEVELOPER_KEY_FILE = os.path.join(APP_DATA_DIR, "developer.key")

# Create all necessary directories
os.makedirs(APP_DATA_DIR, exist_ok=True)
os.makedirs(EXPORT_DIR, exist_ok=True)
os.makedirs(BACKUP_DIR, exist_ok=True)
os.makedirs(RECEIPT_DIR, exist_ok=True)


# --- License Management System ---
class LicenseManager:
    def __init__(self):
        self.license_file = LICENSE_FILE
        self.machine_id = self._get_machine_id()
        self.master_secret = "COLONY_SOFTWARE_2024"
        # Always require master authentication - no automatic developer mode
        self.developer_mode = False
    
    def _get_machine_id(self):
        """Generate unique machine identifier"""
        try:
            # Combine multiple hardware identifiers
            machine_info = f"{platform.machine()}-{platform.processor()}-{uuid.getnode()}"
            # Add Windows-specific info if available
            try:
                import winreg
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Cryptography") as key:
                    machine_guid = winreg.QueryValueEx(key, "MachineGuid")[0]
                    machine_info += f"-{machine_guid}"
            except:
                pass
            
            return hashlib.sha256(machine_info.encode()).hexdigest()[:16].upper()
        except:
            # Fallback method
            return hashlib.sha256(f"{platform.node()}-{uuid.getnode()}".encode()).hexdigest()[:16].upper()
    
    def _is_developer_machine(self):
        """Check if this is the developer's machine - ULTRA SECURE CHECK"""
        # CRITICAL SECURITY: MASTER AUTHENTICATION SYSTEM
        # This system uses both machine binding AND master credentials
        
        try:
            import getpass
            current_machine_id = self.machine_id
            current_username = getpass.getuser()
            
            # DEVELOPER CONFIGURATION - ULTRA SECURE SETUP
            DEVELOPER_MACHINE_ID = "F9C1E60D8C75D4E7"  # EXACT machine ID only
            DEVELOPER_USERNAME = os.getenv('USERNAME') or "User"  # Use current username
            DEV_KEY_FILE = "developer.key"  # Look in current directory first, then AppData
            DEVELOPER_SECRET = "SANTOSH_DEVELOPER_2024"
            
            # MASTER AUTHENTICATION CREDENTIALS
            MASTER_DEVELOPER_ID = "SANTOSH_MASTER_DEV_2024"
            MASTER_PASSWORD = "COLONY_MASTER_SECURE_2024"
            
            # CONDITION 1: Machine ID must match EXACTLY
            machine_match = (current_machine_id == DEVELOPER_MACHINE_ID)
            
            # CONDITION 2: Username check (more flexible)
            username_match = (current_username == DEVELOPER_USERNAME) or (DEVELOPER_USERNAME == "User")
            
            # CONDITION 3: Developer key file must exist with correct secret
            key_file_match = False
            # Check both current directory and AppData locations
            key_locations = [
                DEV_KEY_FILE,  # Current directory
                os.path.join(APP_DATA_DIR, "developer.key")  # AppData directory
            ]
            
            for key_file_path in key_locations:
                if os.path.exists(key_file_path):
                    try:
                        with open(key_file_path, 'r') as f:
                            key_content = f.read().strip()
                        if key_content == DEVELOPER_SECRET:
                            key_file_match = True
                            break
                    except:
                        continue
            
            # CONDITION 4: Master credentials verification
            master_auth_file = os.path.join(APP_DATA_DIR, "master_auth.key")
            master_auth_match = False
            
            if os.path.exists(master_auth_file):
                try:
                    with open(master_auth_file, 'r') as f:
                        auth_data = f.read().strip().split('|')
                    if len(auth_data) == 2:
                        stored_id, stored_pass = auth_data
                        master_auth_match = (stored_id == MASTER_DEVELOPER_ID and stored_pass == MASTER_PASSWORD)
                except:
                    master_auth_match = False
            else:
                # Don't auto-create master auth file - require manual entry
                master_auth_match = False  # Always require manual master authentication
            
            # ALL FOUR CONDITIONS MUST BE TRUE FOR DEVELOPER ACCESS
            developer_access = machine_match and username_match and key_file_match and master_auth_match
            
            # Enhanced logging for security audit
            if developer_access:
                self._log_developer_access("SUCCESS", "Full developer access granted")
            else:
                failed_conditions = []
                if not machine_match: failed_conditions.append("Machine ID mismatch")
                if not username_match: failed_conditions.append("Username mismatch")
                if not key_file_match: failed_conditions.append("Developer key not found")
                if not master_auth_match: failed_conditions.append("Master authentication failed")
                self._log_developer_access("FAILED", f"Access denied: {', '.join(failed_conditions)}")
            
            return developer_access
            
        except Exception as e:
            self._log_developer_access("ERROR", f"Developer check error: {str(e)}")
            return False
    
    def _log_developer_access(self, status, message):
        """Log developer access attempts for security audit"""
        try:
            log_file = os.path.join(APP_DATA_DIR, "security_audit.log")
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            log_entry = f"[{timestamp}] DEVELOPER_ACCESS_{status}: {message}\n"
            
            with open(log_file, 'a', encoding='utf-8') as f:
                f.write(log_entry)
        except:
            pass  # Silent logging failure
    
    def check_license(self):
        """Check if valid license exists"""
        # Developer bypass - no license required for developer machine
        if self.developer_mode:
            return True, "DEVELOPER MODE - Master Authentication Successful"
            
        if not os.path.exists(self.license_file):
            return False, "CUSTOMER MODE - Please activate your license."
        
        try:
            with open(self.license_file, 'r') as f:
                license_data = f.read().strip()
            
            if self._validate_license_data(license_data):
                # Check if it's a full license
                parts = license_data.split(':')
                if len(parts) == 3:
                    # It's a full license
                    return True, "CUSTOMER MODE - Full License Active"
                else:
                    return False, "CUSTOMER MODE - Invalid license format"
            else:
                return False, "CUSTOMER MODE - Invalid or corrupted license file"
        except Exception as e:
            return False, f"CUSTOMER MODE - License file error: {str(e)}"
    
    def _validate_license_data(self, license_data):
        """Validate license data format and integrity"""
        try:
            parts = license_data.split(':')
            if len(parts) != 3:
                return False
            
            machine_id, expiry, hash_check = parts
            
            # Check machine ID
            if machine_id != self.machine_id:
                return False
            
            # Check expiry
            expiry_date = datetime.strptime(expiry, '%Y%m%d').date()
            if datetime.now().date() > expiry_date:
                return False
            
            # Verify hash
            expected_hash = hashlib.sha256(f"{machine_id}{expiry}{self.master_secret}".encode()).hexdigest()[:8]
            
            return hash_check == expected_hash
        except:
            return False
    
    def activate_license(self, license_key):
        """Activate software with license key"""
        # Clean the license key
        license_key = license_key.strip().upper().replace(' ', '')
        
        # Check format: XXXX-XXXX-XXXX-XXXX
        if len(license_key) != 19 or license_key.count('-') != 3:
            return False, "Invalid license key format. Please use XXXX-XXXX-XXXX-XXXX format."
        
        # For demo purposes, accept any properly formatted key
        # In real implementation, you'd verify against your server/database
        try:
            # Generate license file
            expiry = (datetime.now() + timedelta(days=365)).strftime('%Y%m%d')
            hash_part = hashlib.sha256(f"{self.machine_id}{expiry}{self.master_secret}".encode()).hexdigest()[:8]
            license_data = f"{self.machine_id}:{expiry}:{hash_part}"
            
            with open(self.license_file, 'w') as f:
                f.write(license_data)
            
            return True, "License activated successfully! Software is now fully licensed."
        except Exception as e:
            return False, f"Failed to activate license: {str(e)}"
    
    
    def get_machine_id(self):
        """Get machine ID for license generation"""
        return self.machine_id
    
    def get_license_info(self):
        """Get current license information"""
        # Developer mode status
        if self.developer_mode:
            return "Developer Mode - Full Access"
            
        if not os.path.exists(self.license_file):
            return "No license found"
        
        try:
            with open(self.license_file, 'r') as f:
                license_data = f.read().strip()
            
            parts = license_data.split(':')
            if len(parts) == 3:
                machine_id, expiry, hash_check = parts
                expiry_date = datetime.strptime(expiry, '%Y%m%d').date()
                days_left = (expiry_date - datetime.now().date()).days
                
                return f"Full License - Valid until {expiry_date.strftime('%d-%m-%Y')}"
            else:
                return "Invalid license format"
        except:
            return "License file corrupted"


# --- Master Authentication Dialog ---
class MasterAuthenticationDialog(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("Master Authentication Required")
        self.geometry("400x300")
        self.resizable(False, False)
        self.transient(parent)
        self.grab_set()
        
        self.result = False
        self.master_id = ""
        self.master_password = ""
        
        self._build_ui()
        self._center_window()
        
        # Focus on the first entry
        self.id_entry.focus_set()
    
    def _build_ui(self):
        # Main frame
        main_frame = ttk.Frame(self, padding=20)
        main_frame.pack(fill="both", expand=True)
        
        # Title
        title_label = ttk.Label(main_frame, text="🔐 Master Authentication", 
                               font=("Segoe UI", 14, "bold"), foreground="#dc2626")
        title_label.pack(pady=(0, 10))
        
        # Description
        desc_label = ttk.Label(main_frame, 
                              text="Enter master credentials to access developer mode:",
                              font=("Segoe UI", 10))
        desc_label.pack(pady=(0, 20))
        
        # Master ID field
        id_frame = ttk.Frame(main_frame)
        id_frame.pack(fill="x", pady=(0, 10))
        
        ttk.Label(id_frame, text="Master ID:", font=("Segoe UI", 10, "bold")).pack(anchor="w")
        self.id_var = tk.StringVar()
        self.id_entry = ttk.Entry(id_frame, textvariable=self.id_var, font=("Consolas", 10), width=35)
        self.id_entry.pack(fill="x", pady=(5, 0))
        
        # Master Password field
        pass_frame = ttk.Frame(main_frame)
        pass_frame.pack(fill="x", pady=(0, 20))
        
        ttk.Label(pass_frame, text="Master Password:", font=("Segoe UI", 10, "bold")).pack(anchor="w")
        self.pass_var = tk.StringVar()
        self.pass_entry = ttk.Entry(pass_frame, textvariable=self.pass_var, show="*", 
                                   font=("Consolas", 10), width=35)
        self.pass_entry.pack(fill="x", pady=(5, 0))
        
        # Buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill="x", pady=(10, 0))
        
        ttk.Button(button_frame, text="Authenticate", command=self._authenticate).pack(side="left", padx=(0, 10))
        ttk.Button(button_frame, text="Cancel", command=self._cancel).pack(side="left")
        
        # Status label
        self.status_var = tk.StringVar()
        self.status_label = ttk.Label(main_frame, textvariable=self.status_var, 
                                     foreground="red", font=("Segoe UI", 9))
        self.status_label.pack(pady=(10, 0))
        
        # Bind Enter key
        self.bind('<Return>', lambda e: self._authenticate())
        
        # Handle window close
        self.protocol("WM_DELETE_WINDOW", self._cancel)
    
    def _center_window(self):
        """Center window on screen"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")
    
    def _authenticate(self):
        """Validate master credentials"""
        master_id = self.id_var.get().strip()
        master_password = self.pass_var.get().strip()
        
        if not master_id or not master_password:
            self.status_var.set("Please enter both Master ID and Password")
            return
        
        # Validate credentials
        MASTER_DEVELOPER_ID = "SANTOSH_MASTER_DEV_2024"
        MASTER_PASSWORD = "COLONY_MASTER_SECURE_2024"
        
        print(f"🔍 Debug: Entered ID: '{master_id}'")
        print(f"🔍 Debug: Expected ID: '{MASTER_DEVELOPER_ID}'")
        print(f"🔍 Debug: ID Match: {master_id == MASTER_DEVELOPER_ID}")
        print(f"🔍 Debug: Password Match: {master_password == MASTER_PASSWORD}")
        
        if master_id == MASTER_DEVELOPER_ID and master_password == MASTER_PASSWORD:
            print("✅ Master authentication successful!")
            self.result = True
            self.master_id = master_id
            self.master_password = master_password
            
            # Save credentials securely
            try:
                # Ensure directory exists
                os.makedirs(APP_DATA_DIR, exist_ok=True)
                master_auth_file = os.path.join(APP_DATA_DIR, "master_auth.key")
                with open(master_auth_file, 'w') as f:
                    f.write(f"{master_id}|{master_password}")
                print(f"✅ Master auth saved to: {master_auth_file}")
            except Exception as e:
                print(f"⚠️ Failed to save master auth: {e}")
            
            self.status_var.set("✅ Authentication successful!")
            self.after(1000, self.destroy)  # Close after 1 second
        else:
            print("❌ Master authentication failed")
            self.status_var.set("❌ Invalid Master ID or Password")
            self.pass_entry.select_range(0, tk.END)
            self.pass_entry.focus_set()
    
    def _cancel(self):
        """Cancel authentication"""
        self.result = False
        self.destroy()


# --- Customer Machine ID Window ---
class CustomerMachineIdWindow(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Colony Maintenance Manager - Activation Required")
        self.geometry("900x800")
        self.resizable(False, False)
        self.license_manager = LicenseManager()
        self.machine_id = self.license_manager.get_machine_id()
        
        # Apply modern styling
        self._apply_styles()
        self._build_ui()
        self._center_window()
        
        # Make window modal and always on top
        self.transient()
        self.grab_set()
        self.attributes('-topmost', True)
        
        # Prevent closing without license
        self.protocol("WM_DELETE_WINDOW", self._on_close)
    
    def _apply_styles(self):
        """Apply modern styling"""
        style = ttk.Style()
        try:
            style.theme_use("clam")
        except:
            pass
        
        # Modern color scheme
        style.configure("Title.TLabel", font=("Segoe UI", 16, "bold"), foreground="#dc2626")
        style.configure("Subtitle.TLabel", font=("Segoe UI", 10), foreground="#6b7280")
        style.configure("Info.TLabel", font=("Segoe UI", 9), foreground="#374151")
        style.configure("MachineID.TLabel", font=("Consolas", 14, "bold"), foreground="#1f2937", background="#fef3c7")
        style.configure("Important.TLabel", font=("Segoe UI", 10, "bold"), foreground="#dc2626")
    
    def _build_ui(self):
        # Main container with padding
        main_frame = ttk.Frame(self, padding=25)
        main_frame.pack(fill="both", expand=True)
        
        # Header with warning icon
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill="x", pady=(0, 20))
        
        # Title with mode indicator
        license_manager = LicenseManager()
        mode_text = "DEVELOPER MODE" if license_manager.developer_mode else "CUSTOMER MODE"
        mode_color = "#16a34a" if license_manager.developer_mode else "#dc2626"
        
        title_label = ttk.Label(header_frame, text=f"⚠️ Software Activation Required ({mode_text})", 
                               style="Title.TLabel")
        title_label.pack()
        
        # Mode indicator
        mode_label = ttk.Label(header_frame, text=mode_text, 
                              font=("Segoe UI", 10, "bold"), foreground=mode_color)
        mode_label.pack(pady=(2, 0))
        
        subtitle_label = ttk.Label(header_frame, text="Colony Maintenance Manager", style="Subtitle.TLabel")
        subtitle_label.pack(pady=(5, 0))
        
        # Main message
        message_frame = ttk.LabelFrame(main_frame, text="Activation Instructions", padding=15)
        message_frame.pack(fill="x", pady=(0, 15))
        
        message_text = (
            "This software requires activation before use.\n\n"
            "Please follow these steps:\n"
            "1. Copy your Machine ID below\n"
            "2. Send it to the software provider\n"
            "3. You will receive an activation key\n"
            "4. Enter the key to activate your software"
        )
        
        ttk.Label(message_frame, text=message_text, style="Info.TLabel", justify="left").pack(anchor="w")
        
        # Machine ID section
        machine_frame = ttk.LabelFrame(main_frame, text="Your Machine ID", padding=15)
        machine_frame.pack(fill="x", pady=(0, 15))
        
        ttk.Label(machine_frame, text="Please send this Machine ID to get your license:", 
                 style="Important.TLabel").pack(anchor="w", pady=(0, 10))
        
        # Machine ID display with special styling and better width
        id_display_frame = ttk.Frame(machine_frame)
        id_display_frame.pack(fill="x")
        
        # Create a wider entry for machine ID display (read-only)
        self.machine_id_entry = tk.Entry(id_display_frame, 
                                        font=("Consolas", 12, "bold"),
                                        justify="center",
                                        bg="#fef3c7", fg="#1f2937",
                                        relief="solid", bd=2,
                                        state="readonly",
                                        readonlybackground="#fef3c7")
        self.machine_id_entry.pack(fill="x", pady=(0, 10))
        
        # Insert machine ID and make it readonly
        self.machine_id_entry.config(state="normal")
        self.machine_id_entry.insert(0, self.machine_id)
        self.machine_id_entry.config(state="readonly")
        
        # Copy button - Apply memory specifications for consistency
        copy_btn = tk.Button(id_display_frame, text="📋 Copy Machine ID", 
                            command=self._copy_machine_id,
                            font=("Segoe UI", 9, "bold"),
                            relief="raised", bd=1,
                            padx=10, pady=6,
                            bg="#0d6efd", fg="white",
                            cursor="hand2")
        copy_btn.pack(pady=(10, 0))
        
        # Master authentication section (if needed)
        if not license_manager.developer_mode:
            auth_frame = ttk.LabelFrame(main_frame, text="Developer Access", padding=15)
            auth_frame.pack(fill="x", pady=(0, 15))
            
            ttk.Label(auth_frame, text="Developers can access the Master Authentication system:", 
                     style="Info.TLabel").pack(anchor="w", pady=(0, 10))
            
            master_auth_btn = tk.Button(auth_frame, text="🔐 Master Authentication", 
                                       command=self._show_master_auth,
                                       font=("Segoe UI", 9, "bold"),
                                       relief="raised", bd=1,
                                       padx=15, pady=8,
                                       bg="#6366f1", fg="white",
                                       cursor="hand2")
            master_auth_btn.pack(pady=(0, 10))
            
            ttk.Label(auth_frame, text="Use this if you have master developer credentials.", 
                     font=("Segoe UI", 8), foreground="#6b7280").pack(anchor="w")
        
        # License activation section
        activation_frame = ttk.LabelFrame(main_frame, text="Enter Activation Key", padding=15)
        activation_frame.pack(fill="x", pady=(0, 15))
        
        ttk.Label(activation_frame, text="Once you receive your activation key, enter it here:", 
                 style="Info.TLabel").pack(anchor="w")
        
        # License key entry with better styling
        key_frame = ttk.Frame(activation_frame)
        key_frame.pack(fill="x", pady=(10, 0))
        
        self.license_key_var = tk.StringVar()
        self.license_entry = tk.Entry(key_frame, textvariable=self.license_key_var, 
                                     font=("Consolas", 12),
                                     justify="center",
                                     bg="white", fg="#1f2937",
                                     relief="solid", bd=2)
        self.license_entry.pack(fill="x", pady=(0, 5))
        
        # Placeholder hint
        ttk.Label(key_frame, text="Format: XXXX-XXXX-XXXX-XXXX", 
                 style="Subtitle.TLabel").pack(pady=(5, 0))
        
        # BUTTON PLACEMENT - Using pack() for responsive positioning
        # This ensures buttons adjust properly on different screen sizes
        
        # Create a frame for buttons to ensure proper layout
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill="x", pady=(20, 0))
        
        # Create sub-frames for button rows
        row1_frame = ttk.Frame(button_frame)
        row1_frame.pack(fill="x", pady=(0, 10))
        
        row2_frame = ttk.Frame(button_frame)
        row2_frame.pack(fill="x")
        
        # ACTIVATE Button
        activate_btn = tk.Button(row1_frame,
                               text="ACTIVATE",
                               command=self._activate_license,
                               font=("Segoe UI", 12, "bold"),
                               relief="raised",
                               bd=3,
                               padx=20,
                               pady=10,
                               width=15,
                               bg="#16a34a",
                               fg="white")
        activate_btn.pack(side="left", padx=(0, 20))
        
        # CANCEL Button
        cancel_btn = tk.Button(row1_frame,
                             text="CANCEL",
                             command=self._cancel_activation,
                             font=("Segoe UI", 12, "bold"),
                             relief="raised",
                             bd=3,
                             padx=20,
                             pady=10,
                             width=15,
                             bg="#6b7280",
                             fg="white")
        cancel_btn.pack(side="left")
        
        # TRIAL functionality removed per user request
        
        # EXIT Button
        exit_btn = tk.Button(row2_frame,
                           text="EXIT",
                           command=self._exit_app,
                           font=("Segoe UI", 12, "bold"),
                           relief="raised",
                           bd=3,
                           padx=20,
                           pady=10,
                           width=15,
                           bg="#dc2626",
                           fg="white")
        exit_btn.pack(side="left")
        
        # Status label
        self.status_var = tk.StringVar()
        self.status_label = ttk.Label(main_frame, textvariable=self.status_var, 
                                     font=("Segoe UI", 9), foreground="#16a34a")
        self.status_label.pack(pady=(10, 0))
        
        # Bind Enter key to activate license
        self.bind('<Return>', lambda e: self._activate_license())
        self.license_entry.bind('<Return>', lambda e: self._activate_license())
    
    def _center_window(self):
        """Center window on screen"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")
    
    def _copy_machine_id(self):
        """Copy machine ID to clipboard"""
        try:
            self.clipboard_clear()
            self.clipboard_append(self.machine_id)
            self.status_var.set("✅ Machine ID copied to clipboard!")
            self.after(3000, lambda: self.status_var.set(""))
        except Exception as e:
            self.status_var.set(f"❌ Copy failed: {str(e)}")
    
    def _activate_license(self):
        """Activate license with provided key - Enhanced with security validation"""
        try:
            license_key = self.license_key_var.get().strip()
            if not license_key:
                self.status_var.set("❌ Please enter a license key")
                return
            
            # Enhanced validation - check format and content
            if not self._validate_license_format(license_key):
                self.status_var.set("❌ Invalid license key format. Use XXXX-XXXX-XXXX-XXXX")
                return
            
            # Security check - prevent common attack patterns
            if self._detect_malicious_input(license_key):
                self.status_var.set("❌ Invalid license key detected")
                self._log_security_attempt("MALICIOUS_LICENSE_ATTEMPT", license_key)
                return
            
            # Activate with enhanced error handling
            success, message = self.license_manager.activate_license(license_key)
            if success:
                self.status_var.set("✅ License activated successfully!")
                self._log_security_attempt("LICENSE_ACTIVATION_SUCCESS", license_key[:9] + "****")
                self.after(2000, self.destroy)
            else:
                self.status_var.set(f"❌ {message}")
                self._log_security_attempt("LICENSE_ACTIVATION_FAILED", f"Key: {license_key[:9]}**** - {message}")
                
        except Exception as e:
            error_msg = f"Activation error: {str(e)}"
            self.status_var.set(f"❌ {error_msg}")
            self._log_security_attempt("LICENSE_ACTIVATION_ERROR", error_msg)
    
    def _validate_license_format(self, license_key):
        """Enhanced license format validation"""
        try:
            # Remove spaces and convert to uppercase
            clean_key = license_key.strip().upper().replace(' ', '')
            
            # Check basic format: XXXX-XXXX-XXXX-XXXX
            if len(clean_key) != 19 or clean_key.count('-') != 3:
                return False
            
            # Check each segment
            segments = clean_key.split('-')
            if len(segments) != 4:
                return False
            
            for segment in segments:
                if len(segment) != 4 or not segment.isalnum():
                    return False
            
            return True
            
        except Exception:
            return False
    
    def _detect_malicious_input(self, license_key):
        """Detect potential malicious input patterns"""
        try:
            # Convert to string for analysis
            key_str = str(license_key).lower()
            
            # Check for SQL injection patterns
            sql_patterns = ['select ', 'drop ', 'delete ', 'insert ', 'update ', 
                          'union ', 'script', 'exec', '--', ';', 'xp_']
            
            # Check for script injection patterns
            script_patterns = ['<script', 'javascript:', 'vbscript:', 'onload=', 
                             'onerror=', 'eval(', 'alert(', 'document.']
            
            # Check for file system patterns
            file_patterns = ['../', '..\\', '/etc/', 'c:\\', 'system32', 
                           'windows', '.exe', '.bat', '.cmd', '.ps1']
            
            # Combine all patterns
            all_patterns = sql_patterns + script_patterns + file_patterns
            
            for pattern in all_patterns:
                if pattern in key_str:
                    return True
            
            return False
            
        except Exception:
            return True  # If we can't analyze it, treat it as suspicious
    
    def _log_security_attempt(self, event_type, details):
        """Log security events for audit trail"""
        try:
            import os
            from datetime import datetime
            
            # Create security log in AppData
            log_dir = os.path.join(os.getenv('APPDATA', ''), 'ColonyMaintenanceManager')
            os.makedirs(log_dir, exist_ok=True)
            
            log_file = os.path.join(log_dir, 'security_audit.log')
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            machine_id = getattr(self, 'machine_id', 'UNKNOWN')
            
            log_entry = f"[{timestamp}] {event_type} | Machine: {machine_id} | Details: {details}\n"
            
            with open(log_file, 'a', encoding='utf-8') as f:
                f.write(log_entry)
                
        except Exception:
            pass  # Silent logging failure for security
    
    def _cancel_activation(self):
        """Cancel activation and clear input"""
        self.license_key_var.set("")
        self.status_var.set("Activation cancelled")
        self.after(2000, lambda: self.status_var.set(""))
    
    def _show_master_auth(self):
        """Show master authentication dialog"""
        try:
            dialog = MasterAuthenticationDialog(self)
            self.wait_window(dialog)
            
            if dialog.result:
                self.status_var.set("✅ Master authentication successful! Restarting application...")
                self.after(2000, self._restart_as_developer)
            else:
                self.status_var.set("❌ Master authentication cancelled or failed")
                self.after(3000, lambda: self.status_var.set(""))
        except Exception as e:
            self.status_var.set(f"❌ Authentication error: {str(e)}")
    
    def _restart_as_developer(self):
        """Restart application with developer mode"""
        try:
            # Close current window
            self.destroy()
            
            # Start main application directly (bypassing license check)
            import subprocess
            import sys
            subprocess.Popen([sys.executable, "colony soft.py"])
        except Exception as e:
            print(f"Restart error: {e}")
    
    def _exit_app(self):
        """Exit the application"""
        self.quit()
        self.destroy()
        sys.exit(0)
    
    def _on_close(self):
        """Handle window close event"""
        # Prevent closing without license - force exit or activation
        result = messagebox.askyesno("Exit Application", 
                                   "Software requires activation to continue.\n\nDo you want to exit the application?")
        if result:
            self._exit_app()


# --- Enhanced License Management with Customer Tracking ---
# Import CustomerDatabase - ensure it has all required methods
try:
    from customer_database import CustomerDatabase
    CustomerDatabaseClass = CustomerDatabase  # type: ignore
except ImportError:
    # Create comprehensive fallback if customer_database.py is not available
    class CustomerDatabaseClass:
        def __init__(self, *args, **kwargs):
            pass
        def add_customer(self, name, email, phone, company, machine_id):
            return None
        def get_customer_by_machine_id(self, machine_id):
            return None
        def create_license(self, customer_id, machine_id, duration_days, notes=""):
            return None
        def expire_license(self, license_key):
            return False
        def get_license_info(self, license_key):
            return None
        def log_license_usage(self, license_key, machine_id):
            pass
        def get_analytics(self):
            return {'total_customers': 0, 'active_licenses': 0, 'expired_licenses': 0, 'recent_usage': 0}
        def get_all_customers(self):
            return []
        def get_customer_licenses(self, customer_id):
            return []

class EnhancedLicenseManager(LicenseManager):
    """Enhanced license manager with customer tracking and remote control"""
    
    def __init__(self):
        super().__init__()
        # Pass the correct customer database path from our AppData configuration
        customer_db_path = os.path.join(APP_DATA_DIR, "customers.db")
        # Use the correct CustomerDatabase class
        try:
            from customer_database import CustomerDatabase
            self.customer_db = CustomerDatabase(customer_db_path)
        except ImportError:
            # Fallback if customer_database.py is not available
            self.customer_db = None
    
    def validate_license_key(self, license_key, machine_id):
        """Validate license key against customer database"""
        # Check if customer database is available
        if self.customer_db is None:
            return False, "Customer database not available"
            
        try:
            # Check if customer_database has the required methods
            if hasattr(self.customer_db, 'get_license_info'):
                license_info = self.customer_db.get_license_info(license_key)
                if not license_info:
                    return False, "Invalid license key"
                
                # Check machine ID match
                if license_info['machine_id'] != machine_id:
                    return False, "License not valid for this machine"
                
                # Check expiry date
                expiry_date = datetime.strptime(license_info['expiry_date'], '%Y-%m-%d %H:%M:%S')
                if datetime.now() > expiry_date:
                    return False, "License has expired"
                
                # Check if manually expired
                if license_info['status'] == 'Expired':
                    return False, "License has been revoked"
                
                # Log usage
                if hasattr(self.customer_db, 'log_license_usage'):
                    self.customer_db.log_license_usage(license_key, machine_id)
                
                return True, f"License valid until {expiry_date.strftime('%d-%m-%Y')}"
            else:
                return False, "License validation not available"
            
        except Exception as e:
            return False, f"License validation error: {str(e)}"
    
    def generate_customer_license(self, customer_name, email, phone, company, machine_id, duration_days, notes=""):
        """Generate license for customer with tracking"""
        # Check if customer database is available
        if self.customer_db is None:
            return None, "Customer database not available"
            
        try:
            # Check if customer exists
            customer = self.customer_db.get_customer_by_machine_id(machine_id)
            
            if not customer:
                # Add new customer
                customer_id = self.customer_db.add_customer(customer_name, email, phone, company, machine_id)
                if not customer_id:
                    return None, "Failed to add customer to database"
            else:
                customer_id = customer['id']
            
            # Generate license
            license_key = self.customer_db.create_license(customer_id, machine_id, duration_days, notes)
            
            # Also create local license file for the customer
            expiry = (datetime.now() + timedelta(days=duration_days)).strftime('%Y%m%d')
            hash_part = hashlib.sha256(f"{machine_id}{expiry}{self.master_secret}".encode()).hexdigest()[:8]
            license_data = f"{machine_id}:{expiry}:{hash_part}"
            
            return license_key, license_data
            
        except Exception as e:
            return None, f"License generation failed: {str(e)}"
    
    def expire_customer_license(self, license_key):
        """Remotely expire a customer's license"""
        # Check if customer database is available
        if self.customer_db is None:
            return False
        return self.customer_db.expire_license(license_key)
    
    def get_system_analytics(self):
        """Get comprehensive system analytics"""
        # Check if customer database is available
        if self.customer_db is None:
            return {'total_customers': 0, 'active_licenses': 0, 'expired_licenses': 0, 'recent_usage': 0}
        return self.customer_db.get_analytics()
class LicenseWindow(CustomerMachineIdWindow):
    """Legacy class name for backward compatibility"""
    def __init__(self, force_customer_mode=False):
        self.force_customer_mode = force_customer_mode
        super().__init__()
        self.license_valid = False
        
        # Check if license already exists and is valid ONLY if not forcing customer mode
        if not force_customer_mode:
            is_valid, message = self.license_manager.check_license()
            if is_valid:
                self.license_valid = True
                self.destroy()
                return
    
    def destroy(self):
        """Override destroy to ensure license_valid is properly set"""
        # Set license_valid based on final license check
        if hasattr(self, 'license_manager') and not self.force_customer_mode:
            is_valid, _ = self.license_manager.check_license()
            self.license_valid = is_valid
        super().destroy()


# --- Database helper with user management ---
class Database:
    def __init__(self, db_file=DB_FILE):
        self.db_file = db_file
        self.conn = sqlite3.connect(self.db_file)
        self.conn.row_factory = sqlite3.Row
        self._init_db()

    def _init_db(self):
        cur = self.conn.cursor()
        # Users table for login
        cur.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                salt TEXT NOT NULL,
                password_hash TEXT NOT NULL,
                role TEXT DEFAULT 'user'
            )
        """)
        # Members
        cur.execute("""
            CREATE TABLE IF NOT EXISTS members (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                phone TEXT,
                email TEXT,
                flat_no TEXT,
                join_date TEXT,
                monthly_rent REAL DEFAULT 0,
                member_type TEXT DEFAULT 'Tenant',
                last_payment_date TEXT,
                total_paid_amount REAL DEFAULT 0
            )
        """)
        cur.execute("PRAGMA table_info(members)")
        columns = [column[1] for column in cur.fetchall()]
        if 'member_type' not in columns:
            cur.execute("ALTER TABLE members ADD COLUMN member_type TEXT DEFAULT 'Tenant'")
        if 'last_payment_date' not in columns:
            cur.execute("ALTER TABLE members ADD COLUMN last_payment_date TEXT")
        if 'total_paid_amount' not in columns:
            cur.execute("ALTER TABLE members ADD COLUMN total_paid_amount REAL DEFAULT 0")
        # Payments
        cur.execute("""
            CREATE TABLE IF NOT EXISTS payments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                member_id INTEGER,
                amount REAL,
                date TEXT,
                note TEXT,
                payment_status TEXT DEFAULT 'Paid',
                FOREIGN KEY(member_id) REFERENCES members(id)
            )
        """)
        
        # Check and add payment_status column if missing
        cur.execute("PRAGMA table_info(payments)")
        columns = [column[1] for column in cur.fetchall()]
        if 'payment_status' not in columns:
            cur.execute("ALTER TABLE payments ADD COLUMN payment_status TEXT DEFAULT 'Paid'")
        
        # Update existing records to set default payment status
        cur.execute("UPDATE payments SET payment_status = 'Paid' WHERE payment_status IS NULL")
        cur.execute("PRAGMA table_info(payments)")
        columns = [column[1] for column in cur.fetchall()]
        if 'payment_mode' not in columns:
            cur.execute("ALTER TABLE payments ADD COLUMN payment_mode TEXT DEFAULT 'Cash'")
        if 'payment_type' not in columns:
            cur.execute("ALTER TABLE payments ADD COLUMN payment_type TEXT DEFAULT 'Maintenance charge'")
        # Complaints
        cur.execute("""
            CREATE TABLE IF NOT EXISTS complaints (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                member_id INTEGER,
                title TEXT,
                description TEXT,
                date DATE,
                status TEXT DEFAULT 'Open',
                priority TEXT DEFAULT 'Medium',
                resolution TEXT,
                resolved_date DATE,
                FOREIGN KEY(member_id) REFERENCES members(id)
            )
        """)
        
        # Add priority column to complaints table if it doesn't exist
        cur.execute("PRAGMA table_info(complaints)")
        complaint_columns = [column[1] for column in cur.fetchall()]
        if 'priority' not in complaint_columns:
            cur.execute("ALTER TABLE complaints ADD COLUMN priority TEXT DEFAULT 'Medium'")
        # Events
        cur.execute("""
            CREATE TABLE IF NOT EXISTS events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT,
                description TEXT,
                event_date DATE,
                posted_date DATE,
                total_budget REAL DEFAULT 0,
                status TEXT DEFAULT 'Planned'
            )
        """)
        
        # Event contributions table for member contributions
        cur.execute("""
            CREATE TABLE IF NOT EXISTS event_contributions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id INTEGER,
                member_id INTEGER,
                amount REAL,
                contribution_date DATE,
                note TEXT,
                FOREIGN KEY(event_id) REFERENCES events(id),
                FOREIGN KEY(member_id) REFERENCES members(id)
            )
        """)
        
        # Add new columns to events table if they don't exist
        cur.execute("PRAGMA table_info(events)")
        event_columns = [column[1] for column in cur.fetchall()]
        if 'total_budget' not in event_columns:
            cur.execute("ALTER TABLE events ADD COLUMN total_budget REAL DEFAULT 0")
        if 'status' not in event_columns:
            cur.execute("ALTER TABLE events ADD COLUMN status TEXT DEFAULT 'Planned'")
        # Staff
        cur.execute("""
            CREATE TABLE IF NOT EXISTS staff (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                role TEXT,
                phone TEXT,
                salary REAL,
                joined_date DATE,
                status TEXT DEFAULT 'Active'
            )
        """)
        
        # Add status column to staff table if it doesn't exist
        cur.execute("PRAGMA table_info(staff)")
        staff_columns = [column[1] for column in cur.fetchall()]
        if 'status' not in staff_columns:
            cur.execute("ALTER TABLE staff ADD COLUMN status TEXT DEFAULT 'Active'")
        # Parking
        cur.execute("""
            CREATE TABLE IF NOT EXISTS parking (
                slot_no TEXT PRIMARY KEY,
                member_id INTEGER,
                vehicle_number TEXT,
                vehicle_model TEXT,
                allocated_date DATE,
                FOREIGN KEY(member_id) REFERENCES members(id)
            )
        """)
        # Inventory
        cur.execute("""
            CREATE TABLE IF NOT EXISTS inventory (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                item_name TEXT,
                quantity INTEGER,
                unit TEXT,
                min_required INTEGER DEFAULT 0
            )
        """)
        # Inventory usage log
        cur.execute("""
            CREATE TABLE IF NOT EXISTS inventory_usage (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                inventory_id INTEGER,
                quantity INTEGER,
                date DATE,
                note TEXT,
                FOREIGN KEY(inventory_id) REFERENCES inventory(id)
            )
        """)
        self.conn.commit()

    def execute(self, query, params=()):
        cur = self.conn.cursor()
        cur.execute(query, params)
        self.conn.commit()
        return cur

    def fetchall(self, query, params=()):
        cur = self.conn.cursor()
        cur.execute(query, params)
        return cur.fetchall()

    def fetchone(self, query, params=()):
        cur = self.conn.cursor()
        cur.execute(query, params)
        return cur.fetchone()

    def close(self):
        self.conn.close()

    # User functions
    def create_user(self, username: str, password: str, role: str = "admin"):
        username = username.strip()
        if not username or not password:
            raise ValueError("Username and password required")
        salt = secrets.token_hex(16)
        pwd_hash = hashlib.sha256((salt + password).encode("utf-8")).hexdigest()
        try:
            self.execute("INSERT INTO users (username, salt, password_hash, role) VALUES (?, ?, ?, ?)",
                         (username, salt, pwd_hash, role))
            return True
        except sqlite3.IntegrityError:
            return False

    def validate_user(self, username: str, password: str):
        row = self.fetchone("SELECT * FROM users WHERE username=?", (username.strip(),))
        if not row:
            return False, None
        salt = row["salt"]
        expected_hash = row["password_hash"]
        provided_hash = hashlib.sha256((salt + password).encode("utf-8")).hexdigest()
        return provided_hash == expected_hash, row["role"]

    def user_count(self):
        r = self.fetchone("SELECT COUNT(*) as cnt FROM users")
        return r["cnt"] if r else 0


# --- Utility functions ---
def export_rows_to_csv(rows, columns, filename):
    if not rows:
        raise ValueError("No data to export")
    with open(filename, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(columns)
        for idx,r in enumerate(rows, start=1):
            writer.writerow([r[col] for col in columns])


def open_file_in_default_app(filepath):
    try:
        webbrowser.open_new_tab(Path(filepath).as_uri())
    except Exception:
        try:
            if os.name == "nt":
                os.startfile(filepath)
            else:
                os.system(f'xdg-open "{filepath}"')
        except Exception:
            messagebox.showinfo("Open file", f"File saved to {filepath}")


# --- Login Window ---
class LoginWindow(tk.Tk):
    def __init__(self, db: Database):
        super().__init__()
        self.db = db
        self.title("Login - Colony Maintenance")
        self.geometry("420x320")
        self.resizable(False, False)
        # Apply style
        self._apply_style(modern=True)
        self.authenticated = False
        self.username = None
        self._build_ui()

    def _apply_style(self, modern=True):
        style = ttk.Style(self)
        try:
            style.theme_use("clam")
        except Exception:
            pass
        base_font = ("Segoe UI", 10)
        header_font = ("Segoe UI Semibold", 14)
        style.configure(".", font=base_font)
        style.configure("Header.TLabel", font=header_font, foreground="#222")
        style.configure("Card.TFrame", background="#f6f7fb", relief="flat")
        style.configure("Accent.TButton", background="#3b82f6", foreground="white")
        style.map("Accent.TButton",
                  background=[("active", "#2563eb"), ("disabled", "#a5b4fc")],
                  foreground=[("disabled", "#eee")])
        style.configure("TEntry", padding=6)
        style.configure("TButton", padding=6)
        self.configure(bg="#eef2ff")

    def _build_ui(self):
        pad = {"padx": 12, "pady": 8}
        container = ttk.Frame(self, style="Card.TFrame", padding=18)
        container.place(relx=0.5, rely=0.5, anchor=tk.CENTER)

        ttk.Label(container, text="Welcome", style="Header.TLabel").grid(row=0, column=0, columnspan=2, pady=(0, 6))
        ttk.Label(container, text="Colony Maintenance Manager", font=("Segoe UI", 10)).grid(row=1, column=0, columnspan=2, pady=(0, 12))

        ttk.Label(container, text="Username:").grid(row=2, column=0, sticky=tk.W, padx=pad["padx"], pady=pad["pady"])
        self.user_var = tk.StringVar()
        ttk.Entry(container, textvariable=self.user_var, width=30).grid(row=2, column=1, padx=pad["padx"], pady=pad["pady"])

        ttk.Label(container, text="Password:").grid(row=3, column=0, sticky=tk.W, padx=pad["padx"], pady=pad["pady"])
        self.pwd_var = tk.StringVar()
        ttk.Entry(container, textvariable=self.pwd_var, show="*", width=30).grid(row=3, column=1, padx=pad["padx"], pady=pad["pady"])

        self.msg_lbl = ttk.Label(container, text="", foreground="red")
        self.msg_lbl.grid(row=4, column=0, columnspan=2)

        login_btn = ttk.Button(container, text="Login", style="Accent.TButton", command=self.do_login)
        login_btn.grid(row=5, column=0, columnspan=2, pady=(6, 4), sticky="ew")

        # If no users, show create admin prompt
        if self.db.user_count() == 0:
            ttk.Separator(container).grid(row=6, column=0, columnspan=2, sticky="ew", pady=(8, 8))
            ttk.Label(container, text="No admin found. Create initial admin account.", foreground="#444").grid(row=7, column=0, columnspan=2, pady=(0, 6))
            create_btn = ttk.Button(container, text="Create Admin", command=self.create_admin_window)
            create_btn.grid(row=8, column=0, columnspan=2, sticky="ew")

        # Bind Enter to login
        self.bind("<Return>", lambda e: self.do_login())

    def do_login(self):
        u = self.user_var.get().strip()
        p = self.pwd_var.get()
        if not u or not p:
            self.msg_lbl.config(text="Enter username and password")
            return
        valid, role = self.db.validate_user(u, p)
        if valid:
            self.authenticated = True
            self.username = u
            self.destroy()  # close login window; main program will open main app
        else:
            self.msg_lbl.config(text="Invalid credentials")

    def create_admin_window(self):
        win = tk.Toplevel(self)
        win.title("Create Admin Account")
        win.geometry("380x220")
        win.resizable(False, False)
        frm = ttk.Frame(win, padding=12)
        frm.pack(fill=tk.BOTH, expand=True)

        ttk.Label(frm, text="Admin Username:").grid(row=0, column=0, sticky=tk.W, pady=6)
        uname = tk.StringVar()
        ttk.Entry(frm, textvariable=uname).grid(row=0, column=1, pady=6)
        ttk.Label(frm, text="Password:").grid(row=1, column=0, sticky=tk.W, pady=6)
        pwd = tk.StringVar()
        ttk.Entry(frm, textvariable=pwd, show="*").grid(row=1, column=1, pady=6)
        ttk.Label(frm, text="Confirm Password:").grid(row=2, column=0, sticky=tk.W, pady=6)
        pwd2 = tk.StringVar()
        ttk.Entry(frm, textvariable=pwd2, show="*").grid(row=2, column=1, pady=6)

        def create():
            a = uname.get().strip()
            p1 = pwd.get()
            p2 = pwd2.get()
            if not a or not p1:
                messagebox.showerror("Validation", "Enter username and password", parent=win)
                return
            if p1 != p2:
                messagebox.showerror("Validation", "Passwords do not match", parent=win)
                return
            ok = self.db.create_user(a, p1, role="admin")
            if not ok:
                messagebox.showerror("Error", "Username already exists", parent=win)
                return
            messagebox.showinfo("Created", "Admin account created. Please login.", parent=win)
            win.destroy()

        ttk.Button(frm, text="Create", command=create).grid(row=3, column=0, columnspan=2, pady=12, sticky="ew")


# --- Main Application (modernized styling applied) ---
class ColonyApp(tk.Tk):
    def __init__(self, db: Database, current_user: str):
        super().__init__()
        self.db = db
        self.current_user = current_user
        # Initialize the missing variables
        self.total_rent_var = tk.StringVar(value="0.00")
        self.total_paid_var = tk.StringVar(value="0.00")
        self.total_balance_var = tk.StringVar(value="0.00")
        self.total_advance_var = tk.StringVar(value="0.00")
        self.title(f" Created By Santosh Kumar Jolhe contact no 9399876001 *Colony Maintenance* - Logged in as {self.current_user}")
        
        # Set window to full screen
        self.state('zoomed')  # For Windows - maximized window
        # Alternative: self.attributes('-fullscreen', True)  # For true fullscreen
        
        self.geometry("1050x680")  # Fallback size if maximization fails
        self.minsize(1000, 650)    # Reasonable minimum
        self._apply_style()
        self.filter_payment_type_var = tk.StringVar(value="All") # Initialize filter variable
        
        # Add keyboard shortcuts for fullscreen toggle
        self.bind('<F11>', self.toggle_fullscreen)
        self.bind('<Escape>', self.exit_fullscreen)
        
        self._build_ui()
        self.refresh_all()
    
    def toggle_fullscreen(self, event=None):
        """Toggle between fullscreen and windowed mode"""
        current_state = self.attributes('-fullscreen')
        self.attributes('-fullscreen', not current_state)
        return "break"
    
    def exit_fullscreen(self, event=None):
        """Exit fullscreen mode"""
        self.attributes('-fullscreen', False)
        return "break"

    def _apply_style(self):
        style = ttk.Style(self)
        try:
            style.theme_use("clam")
        except Exception:
            pass
        # Modern, compact color palette
        bg = "#f8fafc"  # Light background
        panel = "#ffffff"  # Clean white panels
        accent = "#2563eb"  # Modern blue
        success = "#059669"  # Green
        warning = "#d97706"  # Orange
        danger = "#dc2626"  # Red
        fg = "#1f2937"  # Dark text
        secondary = "#6b7280"  # Gray text
        
        # Compact fonts
        font_main = ("Segoe UI", 9)  # Smaller main font
        font_header = ("Segoe UI Semibold", 11)  # Smaller header
        font_small = ("Segoe UI", 8)  # Smaller details

        # Base styles with compact sizing
        style.configure(".", background=bg, font=font_main, foreground=fg)
        style.configure("TLabel", background=bg, foreground=fg)
        style.configure("Header.TLabel", font=font_header, background=bg, foreground=fg)
        style.configure("Small.TLabel", font=font_small, background=bg, foreground=secondary)
        
        # Compact frame styles
        style.configure("Card.TFrame", background=panel, relief="flat", borderwidth=1)
        
        # Compact button styles with smaller padding
        style.configure("Accent.TButton", 
                       background=accent, 
                       foreground="white", 
                       padding=(6, 3),  # Further reduced padding
                       font=font_small)  # Smaller font
        style.map("Accent.TButton", 
                  background=[("active", "#1d4ed8"), ("disabled", "#93c5fd")],
                  foreground=[("disabled", "#e5e7eb")])
        
        style.configure("Success.TButton", 
                       background=success, 
                       foreground="white", 
                       padding=(5, 2),  # Smaller padding
                       font=font_small)
        style.map("Success.TButton", background=[("active", "#047857")])
        
        style.configure("Warning.TButton", 
                       background=warning, 
                       foreground="white", 
                       padding=(5, 2),
                       font=font_small)
        style.map("Warning.TButton", background=[("active", "#b45309")])
        
        style.configure("Danger.TButton", 
                       background=danger, 
                       foreground="white", 
                       padding=(5, 2),
                       font=font_small)
        style.map("Danger.TButton", background=[("active", "#b91c1c")])
        
        # Add Small.TButton style for very compact buttons
        style.configure("Small.TButton", 
                       padding=(4, 2), 
                       font=("Segoe UI", 7))  # Very small buttons
        
        # Compact entry and combobox styles
        style.configure("TEntry", padding=(4, 3), relief="flat", borderwidth=1, font=("Segoe UI", 8))  # Smaller font and padding
        style.configure("TCombobox", padding=(4, 3), relief="flat", borderwidth=1, font=("Segoe UI", 8))
        
        # Compact treeview styles
        style.configure("Treeview", 
                       rowheight=20,  # Even smaller row height
                       font=("Segoe UI", 8),  # Smaller font
                       background=panel,
                       foreground=fg,
                       fieldbackground=panel,
                       borderwidth=0,
                       relief="flat")
        
        style.configure("Treeview.Heading", 
                       font=("Segoe UI", 8),  # Smaller heading font
                       background="#e2e8f0",
                       foreground=fg,
                       relief="flat",
                       borderwidth=1,
                       padding=(3, 1))  # Even more compact heading padding
        
        style.map("Treeview", 
                  background=[("selected", accent), ("focus", accent)],
                  foreground=[("selected", "white"), ("focus", "white")])
        
        # Compact notebook styles
        style.configure("TNotebook", background=bg, borderwidth=0)
        style.configure("TNotebook.Tab", 
                       padding=(8, 4),  # Even smaller tab padding
                       font=("Segoe UI", 8),  # Smaller tab font
                       background="#e2e8f0",
                       foreground=fg)
        style.map("TNotebook.Tab",
                  background=[("selected", panel), ("active", "#cbd5e1")],
                  foreground=[("selected", fg)])
        
        self.configure(bg=bg)

    def _build_ui(self):
        top_frame = ttk.Frame(self, padding=4)  # Further reduced padding from 6
        top_frame.pack(side=tk.TOP, fill=tk.X)
        ttk.Label(top_frame, text="Colony Maintenance Manager", style="Header.TLabel").pack(side=tk.LEFT)
        user_lbl = ttk.Label(top_frame, text=f"User: {self.current_user}", font=("Segoe UI", 7))  # Even smaller font
        user_lbl.pack(side=tk.RIGHT, padx=(0, 6))
        
        # Add fullscreen toggle button
        fullscreen_btn = ttk.Button(top_frame, text="⛶", style="Small.TButton", command=self.toggle_fullscreen, width=3)
        fullscreen_btn.pack(side=tk.RIGHT, padx=2)
        
        backup_btn = ttk.Button(top_frame, text="Backup", style="Small.TButton", command=self.backup_db)  # Use Small style
        backup_btn.pack(side=tk.RIGHT, padx=2)  # Further reduced padding
        refresh_btn = ttk.Button(top_frame, text="Refresh", style="Small.TButton", command=self.refresh_all)  # Use Small style
        refresh_btn.pack(side=tk.RIGHT, padx=2)

        # Main notebook with further reduced padding
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(expand=True, fill=tk.BOTH, padx=4, pady=4)  # Further reduced padding

        # Tabs creation (kept concise)
        self.dashboard_tab = ttk.Frame(self.notebook)
        self.members_tab = ttk.Frame(self.notebook)
        self.payments_tab = ttk.Frame(self.notebook)
        self.complaints_tab = ttk.Frame(self.notebook)
        self.events_tab = ttk.Frame(self.notebook)
        self.staff_tab = ttk.Frame(self.notebook)
        self.parking_tab = ttk.Frame(self.notebook)
        self.inventory_tab = ttk.Frame(self.notebook)
        self.account_tab = ttk.Frame(self.notebook)

        self.notebook.add(self.dashboard_tab, text="Dashboard")
        self.notebook.add(self.members_tab, text="Members")
        self.notebook.add(self.payments_tab, text="Payments")
        self.notebook.add(self.complaints_tab, text="Complaints")
        self.notebook.add(self.events_tab, text="Events")
        self.notebook.add(self.staff_tab, text="Staff")
        self.notebook.add(self.parking_tab, text="Parking")
        self.notebook.add(self.inventory_tab, text="Inventory")
        self.notebook.add(self.account_tab, text="Account Settings")

        # Populate tabs (reuse earlier layouts but concise)
        self._build_dashboard_tab()
        self._build_members_tab()
        self._build_payments_tab()
        self._build_complaints_tab()
        self._build_events_tab()
        self._build_staff_tab()
        self._build_parking_tab()
        self._build_inventory_tab()
        self._build_account_tab()

    # --- Dashboard ---
    def _build_dashboard_tab(self):
        frame = self.dashboard_tab
        # Configure two columns: main content (left) and side panel (right)
        frame.columnconfigure(0, weight=4)  # Increased weight for main content
        frame.columnconfigure(1, weight=1)
        top = ttk.Frame(frame, padding=6, style="Card.TFrame")  # Reduced padding from 8
        top.grid(row=0, column=0, sticky="nsew", padx=6, pady=6)  # Reduced padding
        # Configure multiple columns for summary statistics
        for i in range(5):  # Reduced from 6 to 5
            top.columnconfigure(i, weight=1)

        # Row 0 summary
        self.lbl_total_members = ttk.Label(top, text="Total Members: 0", style="Header.TLabel")
        self.lbl_total_members.grid(row=0, column=0, sticky="w")

        self.lbl_open_complaints = ttk.Label(top, text="Open Complaints: 0", style="Header.TLabel")
        self.lbl_open_complaints.grid(row=0, column=3, sticky="w", padx=20)

        # New summary labels
        self.lbl_todays_payment = ttk.Label(top, text="Today's Payment Received: 0", style="Header.TLabel")
        self.lbl_todays_payment.grid(row=0, column=2, sticky="w", padx=20)
        self.lbl_total_collection = ttk.Label(top, text="Total Collection Amt: 0", style="Header.TLabel")
        self.lbl_total_collection.grid(row=0, column=4, sticky="w", padx=20)

        # Row 1 additional summary
        self.lbl_total_unpaid = ttk.Label(top, text="Total Unpaid Amt: 0", style="Header.TLabel")
        self.lbl_total_unpaid.grid(row=1, column=2, sticky="w", padx=20, pady=(8,0))
        self.lbl_tenants = ttk.Label(top, text="Total Tenants: 0", style="Header.TLabel")
        self.lbl_tenants.grid(row=1, column=0, sticky="w", pady=(8,0))
        self.lbl_owners = ttk.Label(top, text="Total Owners: 0", style="Header.TLabel")
        self.lbl_owners.grid(row=1, column=1, sticky="w", padx=20, pady=(8,0))

        # Side panel container (modern card)
        side_panel = ttk.Frame(frame, padding=12, style="Card.TFrame")
        side_panel.grid(row=0, column=1, rowspan=3, sticky="n", padx=12, pady=12)

        # (Yellow mark maintenance period filter removed as per UI change)

        # Maintenance charge summary inside side panel
        maint_frame = ttk.Frame(side_panel)
        maint_frame.pack(fill="x")
        # Configure two columns: description and value
        maint_frame.columnconfigure(0, weight=1)
        maint_frame.columnconfigure(1, weight=1)

        # RowHouse maintenance
        ttk.Label(maint_frame, text="Total RowHouse Owner Maintenance:", style="Header.TLabel").grid(row=0, column=0, sticky="w", pady=2)
        self.lbl_maint_rowhouse = ttk.Label(maint_frame, text="0", style="Header.TLabel")
        self.lbl_maint_rowhouse.grid(row=0, column=1, sticky="e", pady=2)

        # FlatOwner maintenance
        ttk.Label(maint_frame, text="Total Flat Owner Maintenance:", style="Header.TLabel").grid(row=1, column=0, sticky="w", pady=2)
        self.lbl_maint_flat = ttk.Label(maint_frame, text="0", style="Header.TLabel")
        self.lbl_maint_flat.grid(row=1, column=1, sticky="e", pady=2)

        # Tenant maintenance
        ttk.Label(maint_frame, text="Total Tenant Maintenance:", style="Header.TLabel").grid(row=2, column=0, sticky="w", pady=2)
        self.lbl_maint_tenant = ttk.Label(maint_frame, text="0", style="Header.TLabel")
        self.lbl_maint_tenant.grid(row=2, column=1, sticky="e", pady=2)

        # All maintenance total
        ttk.Separator(maint_frame, orient="horizontal").grid(row=3, column=0, columnspan=2, sticky="ew", pady=4)
        ttk.Label(maint_frame, text="Total Maintenance (All):", style="Header.TLabel").grid(row=4, column=0, sticky="w", pady=2)
        self.lbl_maint_total = ttk.Label(maint_frame, text="0", style="Header.TLabel")
        self.lbl_maint_total.grid(row=4, column=1, sticky="e", pady=2)

        # Labels moved to top summary section

        # Filter controls with better styling - more compact
        filter_frame = ttk.Frame(frame, padding=4, style="Card.TFrame")  # Reduced padding from 6
        filter_frame.grid(row=1, column=0, sticky="ew", padx=6, pady=(0, 6))  # Reduced margins
        filter_frame.columnconfigure(3, weight=1)  # Changed from 4 to 3

        # Enhanced filter controls styling
        ttk.Label(filter_frame, text="Filter:", font=("Segoe UI", 8)).grid(row=0, column=0, sticky="w", padx=(2, 1), pady=1)  # Smaller
        self.filter_category_var = tk.StringVar(value="Time Period")
        category_options = ["Time Period"]  # Only Time Period filter
        category_cb = ttk.Combobox(filter_frame, textvariable=self.filter_category_var, values=category_options, state="readonly", width=12)  # Smaller width
        category_cb.grid(row=0, column=1, sticky="w", padx=1, pady=1)
        category_cb.configure(state="disabled")  # Disable the combobox since there's only one option

        # Container to hold specific filter widgets with better spacing
        self.dynamic_filter_box = ttk.Frame(filter_frame)
        self.dynamic_filter_box.grid(row=1, column=0, columnspan=2, sticky="ew", padx=2, pady=(2,1))  # Changed columnspan from 4 to 2
        
        # Button frame for better spacing
        button_frame = ttk.Frame(filter_frame)
        button_frame.grid(row=0, column=3, rowspan=2, sticky="e", padx=(8, 2))  # Increased left padding
        
        # Enhanced Apply Filters button - smaller
        apply_btn = ttk.Button(button_frame, text="Apply", command=self.update_dashboard, style="Accent.TButton")  # Shortened text
        apply_btn.pack(side="top", pady=(0, 4))  # Added bottom padding
        
        # Add clear filters button - smaller with separation
        clear_btn = ttk.Button(button_frame, text="Clear", command=self.clear_filters, style="Small.TButton")
        clear_btn.pack(side="top")

        # Build filter frames
        self.filter_frames = {}
        self._build_time_period_filter()
        # Remove other filter builders since we only want Time Period
        # self._build_payment_type_filter()
        # self._build_payment_status_filter()
        # self._build_member_type_filter()
        self._show_filter_frame("Time Period")
        # category_cb.bind("<<ComboboxSelected>>", lambda e: self._show_filter_frame(self.filter_category_var.get()))

        # Maintenance period variable and options
        self.maint_period_var = tk.StringVar(value="Till Today")
        maint_period_options = ["Till Today", "Monthly", "Yearly"]
        current_year = datetime.now().year
        for y in range(current_year, current_year - 2, -1):
            for m in range(1, 13):
                maint_period_options.append(datetime(y, m, 1).strftime("%B %Y"))
        # Place the maintenance period filter in the side panel with better styling
        ttk.Separator(side_panel, orient="horizontal").pack(fill="x", pady=8)
        ttk.Label(side_panel, text="Maintenance Period:", font=("Segoe UI Semibold", 10)).pack(anchor="w")
        self.maint_period_combo = ttk.Combobox(side_panel, textvariable=self.maint_period_var, values=maint_period_options, state="readonly", width=20)
        self.maint_period_combo.pack(fill="x", pady=(4,12))
        self.maint_period_combo.bind("<<ComboboxSelected>>", lambda event: self.update_dashboard())

        # Add Rent Collection Summary section
        ttk.Separator(side_panel, orient="horizontal").pack(fill="x", pady=8)
        ttk.Label(side_panel, text="Rent Collection Summary", font=("Segoe UI Semibold", 10)).pack(anchor="w", pady=(0, 5))
        
        # Month Rent Filter
        month_frame = ttk.Frame(side_panel)
        month_frame.pack(fill="x", pady=(0, 5))
        ttk.Label(month_frame, text="Month Rent:", font=("Segoe UI", 9)).pack(anchor="w")
        
        # Month selection dropdown
        month_names = ["January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        self.rent_month_var = tk.StringVar(value=month_names[datetime.now().month - 1])
        self.rent_month_combo = ttk.Combobox(month_frame, textvariable=self.rent_month_var, 
                                            values=month_names, state="readonly", width=18)
        self.rent_month_combo.pack(fill="x", pady=(2, 5))
        
        # Month rent summary
        self.lbl_month_rent_received = ttk.Label(side_panel, text="→ Total Tenant Rent Received: ₹0.00", 
                                                font=("Segoe UI", 9))
        self.lbl_month_rent_received.pack(anchor="w")
        self.lbl_month_rent_expected = ttk.Label(side_panel, text="   (Expected: ₹0.00)", 
                                                font=("Segoe UI", 8), foreground="#64748b")
        self.lbl_month_rent_expected.pack(anchor="w", pady=(0, 10))
        
        # Year Rent Filter
        year_frame = ttk.Frame(side_panel)
        year_frame.pack(fill="x", pady=(0, 5))
        ttk.Label(year_frame, text="Year Rent:", font=("Segoe UI", 9)).pack(anchor="w")
        
        # Year selection dropdown (current year and previous few years)
        current_year = datetime.now().year
        years = [str(current_year), str(current_year - 1), str(current_year - 2)]
        self.rent_year_var = tk.StringVar(value=str(current_year))
        self.rent_year_combo = ttk.Combobox(year_frame, textvariable=self.rent_year_var, 
                                           values=years, state="readonly", width=18)
        self.rent_year_combo.pack(fill="x", pady=(2, 5))
        
        # Year rent summary
        self.lbl_year_rent_received = ttk.Label(side_panel, text="→ Total Tenant Rent Received: ₹0.00", 
                                               font=("Segoe UI", 9))
        self.lbl_year_rent_received.pack(anchor="w")
        self.lbl_year_rent_expected = ttk.Label(side_panel, text="   (Expected: ₹0.00)", 
                                               font=("Segoe UI", 8), foreground="#64748b")
        self.lbl_year_rent_expected.pack(anchor="w")
        
        # Bind the combo boxes to update the dashboard when selection changes
        self.rent_month_combo.bind("<<ComboboxSelected>>", lambda event: self.update_rent_collection_summary())
        self.rent_year_combo.bind("<<ComboboxSelected>>", lambda event: self.update_rent_collection_summary())

        # Enhanced dues table with better title and status indicator
        dues_header_frame = ttk.Frame(frame)
        dues_header_frame.grid(row=2, column=0, sticky="ew", padx=12, pady=(0,4))
        ttk.Label(dues_header_frame, text="Outstanding Dues", font=("Segoe UI Semibold", 12)).pack(side=tk.LEFT)
        
        # Status indicator for active filters
        self.filter_status_label = ttk.Label(dues_header_frame, text="", font=("Segoe UI", 9), foreground="#059669")
        self.filter_status_label.pack(side=tk.RIGHT)
        
        dues_frame = ttk.Frame(frame, padding=8, style="Card.TFrame")
        dues_frame.grid(row=3, column=0, sticky="nsew", padx=12, pady=(0, 12))
        frame.rowconfigure(3, weight=1)  # Make dues table expandable
        
        cols = ("id", "name", "flat_no", "monthly_rent", "last_payment_date", "due_amount", "balance_amount", "paid_amount")
        self.dues_tree = ttk.Treeview(dues_frame, columns=cols, show="headings")
        
        # Better column headers and sizing
        column_configs = {
            "id": ("ID", 60),
            "name": ("Name", 150),
            "flat_no": ("Flat No", 100),
            "monthly_rent": ("Monthly Rent", 120),
            "last_payment_date": ("Last Payment", 120),
            "due_amount": ("Due Amount", 120),
            "balance_amount": ("Balance Amount", 120),
            "paid_amount": ("Paid Amount", 120)
        }
        
        for col, (header, width) in column_configs.items():
            self.dues_tree.heading(col, text=header)
            self.dues_tree.column(col, width=width, anchor="center" if col in ["id", "flat_no", "monthly_rent", "due_amount", "balance_amount", "paid_amount"] else "w")
        
        # Add scrollbar for dues table
        dues_scrollbar = ttk.Scrollbar(dues_frame, orient="vertical", command=self.dues_tree.yview)
        self.dues_tree.configure(yscrollcommand=dues_scrollbar.set)
        
        self.dues_tree.pack(side=tk.LEFT, fill="both", expand=True)
        # Configure totals row style similar to Payments tab
        self.dues_tree.tag_configure("totals", background="#d1fae5", font=("Segoe UI", 8, "bold"))
        dues_scrollbar.pack(side=tk.RIGHT, fill="y")


    # --- Members ---
    def _build_members_tab(self):
        frame = self.members_tab
        # Create main container for layout consistency
        main_container = ttk.Frame(frame, padding=8)
        main_container.pack(fill="both", expand=True)

        # --- Action bar (top) ---
        top_action_bar = ttk.Frame(main_container)
        top_action_bar.pack(fill="x", pady=(0,4))
        ttk.Button(top_action_bar, text="Add", command=self.add_member_window, style="Small.TButton").pack(side=tk.LEFT, padx=(0,6))
        ttk.Button(top_action_bar, text="Edit", command=self.edit_member_window, style="Small.TButton").pack(side=tk.LEFT, padx=(0,6))
        ttk.Button(top_action_bar, text="Delete", command=self.delete_member, style="Small.TButton").pack(side=tk.LEFT, padx=(0,6))
        ttk.Button(top_action_bar, text="Export CSV", command=self.export_members_csv, style="Small.TButton").pack(side=tk.LEFT, padx=(0,6))
        ttk.Button(top_action_bar, text="Report", command=self.open_consolidated_report, style="Small.TButton").pack(side=tk.LEFT, padx=(0,6))

        # --- Inline search controls ---
        search_frame = ttk.Frame(top_action_bar)
        search_frame.pack(side=tk.LEFT, padx=(30,0))
        ttk.Label(search_frame, text="Search Name:", font=("Segoe UI", 8)).pack(side=tk.LEFT)
        self.search_name_var = tk.StringVar()
        ttk.Entry(search_frame, textvariable=self.search_name_var, width=15, font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(0,6))
        ttk.Label(search_frame, text="Flat No:", font=("Segoe UI", 8)).pack(side=tk.LEFT)
        self.search_flat_no_var = tk.StringVar()
        ttk.Entry(search_frame, textvariable=self.search_flat_no_var, width=8, font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(0,6))
        ttk.Button(search_frame, text="Search", command=self.refresh_members, style="Small.TButton").pack(side=tk.LEFT)

        # --- Content frames ---
        left = ttk.Frame(main_container)
        left.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        right = ttk.Frame(main_container, width=240, padding=8)
        right.pack(side=tk.RIGHT, fill=tk.Y)
        cols = ("s_no", "id", "name", "flat_no", "phone", "email", "monthly_rent", "join_date", "member_type", "total_paid_amount", "balance_amount", "advance_amount", "payment_status")
        self.members_tree = ttk.Treeview(left, columns=cols, show="headings")
        for c in cols:
            self.members_tree.heading(c, text=c.replace("_", " ").title())
            if c == "id":
                # hide internal database id
                self.members_tree.column(c, width=0, stretch=False)
            elif c == "s_no":
                self.members_tree.column(c, width=60, anchor="center")
            elif c == "total_paid_amount":
                # Give more width to total paid amount column
                self.members_tree.column(c, width=140)
            elif c == "balance_amount":
                # Give more width to balance amount column
                self.members_tree.column(c, width=140)
            elif c == "advance_amount":
                # Give more width to advance amount column
                self.members_tree.column(c, width=140)
            else:
                self.members_tree.column(c, width=120)
        # Pack members tree
        # Override heading for total paid amount column
        self.members_tree.heading("total_paid_amount", text="Total Paid Rent Amt.")
        self.members_tree.pack(fill=tk.BOTH, expand=True)
        # Configure totals row style
        self.members_tree.tag_configure("totals", background="#d1fae5", font=("Segoe UI", 8, "bold"))



    # --- Payments ---
    def _build_payments_tab(self):
        frame = self.payments_tab
        
        # Create main container with proper layout
        main_container = ttk.Frame(frame)
        main_container.pack(fill="both", expand=True, padx=8, pady=8)
        
        # Top row - Member selection and basic payment info
        top_row1 = ttk.Frame(main_container)
        top_row1.pack(fill="x", pady=(0, 4))
        
        ttk.Label(top_row1, text="Member:", font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(0, 4))
        self.payment_member_cb = ttk.Combobox(top_row1, values=[], width=25, state="readonly", font=("Segoe UI", 8))
        self.payment_member_cb.pack(side=tk.LEFT, padx=(0, 8))
        self.payment_member_cb.bind("<<ComboboxSelected>>", self._on_payment_member_selected)
        
        ttk.Label(top_row1, text="Amount:", font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(0, 4))
        self.payment_amount_var = tk.StringVar()
        ttk.Entry(top_row1, textvariable=self.payment_amount_var, width=10, font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(0, 8))
        
        ttk.Label(top_row1, text="Date:", font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(0, 4))
        self.payment_date_var = tk.StringVar(value=datetime.now().strftime("%d-%m-%Y"))
        ttk.Entry(top_row1, textvariable=self.payment_date_var, width=12, font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(0, 8))
        
        # Second row - Payment details
        top_row2 = ttk.Frame(main_container)
        top_row2.pack(fill="x", pady=(0, 4))
        
        ttk.Label(top_row2, text="Payment Mode:", font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(0, 4))
        self.payment_mode_var = tk.StringVar()
        self.payment_mode_cb = ttk.Combobox(top_row2, textvariable=self.payment_mode_var, values=["Cash", "UPI", "Bank Transfer"], state="readonly", width=12, font=("Segoe UI", 8))
        self.payment_mode_cb.set("Cash")
        self.payment_mode_cb.pack(side=tk.LEFT, padx=(0, 8))
        
        ttk.Label(top_row2, text="Payment Type:", font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(0, 4))
        self.payment_type_var = tk.StringVar()
        self.payment_type_cb = ttk.Combobox(top_row2, textvariable=self.payment_type_var, values=["Rent", "Maintenance charge", "Amenities", "Corpus Fund", "Other"], state="readonly", width=15, font=("Segoe UI", 8))
        self.payment_type_cb.set("Maintenance charge")
        self.payment_type_cb.pack(side=tk.LEFT, padx=(0, 8))
        self.payment_type_cb.bind("<<ComboboxSelected>>", self._on_payment_type_selected)
        
        ttk.Label(top_row2, text="Note:", font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(0, 4))
        self.payment_note_var = tk.StringVar()
        ttk.Entry(top_row2, textvariable=self.payment_note_var, width=25, font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(0, 8))
        
        # Third row - Action buttons only (filters removed as Dashboard has comprehensive filtering)
        top_row3 = ttk.Frame(main_container)
        top_row3.pack(fill="x", pady=(0, 8))
        
        # Action buttons
        ttk.Button(top_row3, text="Add Payment", style="Accent.TButton", command=self.add_payment).pack(side=tk.LEFT, padx=(0, 6))
        ttk.Button(top_row3, text="Edit Payment", style="Small.TButton", command=self.edit_payment_window).pack(side=tk.LEFT, padx=(0, 6))
        ttk.Button(top_row3, text="Delete Payment", style="Small.TButton", command=self.delete_payment).pack(side=tk.LEFT, padx=(0, 6))
        ttk.Button(top_row3, text="Generate Slip", style="Small.TButton", command=self.generate_payment_slip).pack(side=tk.LEFT, padx=(0, 6))
        
        # Info label about filtering
        ttk.Label(top_row3, text="💡 Use Dashboard filters to filter payment data", font=("Segoe UI", 8), foreground="#6b7280").pack(side=tk.RIGHT)
        
        # Data table
        table_frame = ttk.Frame(main_container)
        table_frame.pack(fill="both", expand=True)
        
        cols = ("s_no", "id", "flat_no", "member", "amount", "date", "note", "payment_mode", "payment_type", "payment_status")
        self.payments_tree = ttk.Treeview(table_frame, columns=cols, show="headings")
        
        # Configure columns with proper sizing
        column_configs = {
            "s_no": ("S No", 50),
            "id": ("ID", 0),  # Hidden
            "flat_no": ("Flat No", 80),
            "member": ("Member", 150),
            "amount": ("Amount", 100),
            "date": ("Date", 100),
            "note": ("Note", 120),
            "payment_mode": ("Payment Mode", 110),
            "payment_type": ("Payment Type", 130),
            "payment_status": ("Payment Status", 110)
        }
        
        for col, (header, width) in column_configs.items():
            self.payments_tree.heading(col, text=header)
            if width == 0:
                self.payments_tree.column(col, width=0, stretch=False, minwidth=0)
            else:
                self.payments_tree.column(col, width=width, anchor="center" if col in ["s_no", "amount", "date"] else "w")
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=self.payments_tree.yview)
        self.payments_tree.configure(yscrollcommand=scrollbar.set)
        
        self.payments_tree.pack(side=tk.LEFT, fill="both", expand=True)
        scrollbar.pack(side=tk.RIGHT, fill="y")
        # Configure totals row style
        self.payments_tree.tag_configure("totals", background="#d1fae5", font=("Segoe UI", 8, "bold"))

    def _update_filter_status(self, has_filters_applied):
        """Update the filter status indicator"""
        if has_filters_applied:
            self.filter_status_label.config(text="📊 Filters Applied", foreground="#059669")
        else:
            self.filter_status_label.config(text="", foreground="#6b7280")

    def clear_filters(self):
        """Clear all filter values and reset to defaults"""
        # Reset filter category to default
        if hasattr(self, "filter_category_var"):
            self.filter_category_var.set("Time Period")
        
        # Clear all filter values
        if hasattr(self, "filter_from_date"):
            self.filter_from_date.set("")
        if hasattr(self, "filter_to_date"):
            self.filter_to_date.set("")
        if hasattr(self, "dashboard_filter_payment_type_var"):
            self.dashboard_filter_payment_type_var.set("")
        if hasattr(self, "dashboard_filter_payment_status_var"):
            self.dashboard_filter_payment_status_var.set("")
        if hasattr(self, "filter_member_type_var"):
            self.filter_member_type_var.set("")
        
        # Show the Time Period filter frame
        self._show_filter_frame("Time Period")
        
        # Update the dashboard to reflect cleared filters
        self.update_dashboard()
        
        # Update dashboard to show all data
        self.update_dashboard()
        
        messagebox.showinfo("Filters Cleared", "All filters have been cleared and data refreshed.")

    # --- Dynamic Filter Frame Builders ---
    def _build_time_period_filter(self):
        frame = ttk.Frame(self.dynamic_filter_box)
        # Compact layout with smaller fonts
        ttk.Label(frame, text="From Date:", font=("Segoe UI", 8)).grid(row=0, column=0, sticky="w", padx=(0,3), pady=1)
        self.filter_from_date = tk.StringVar()
        from_entry = ttk.Entry(frame, textvariable=self.filter_from_date, width=10, font=("Segoe UI", 8))
        from_entry.grid(row=0, column=1, padx=2, pady=1)
        ttk.Label(frame, text="(DD-MM-YYYY)", font=("Segoe UI", 7), foreground="#666").grid(row=0, column=2, sticky="w", padx=(1,6), pady=1)
        
        ttk.Label(frame, text="To Date:", font=("Segoe UI", 8)).grid(row=0, column=3, sticky="w", padx=(0,3), pady=1)
        self.filter_to_date = tk.StringVar()
        to_entry = ttk.Entry(frame, textvariable=self.filter_to_date, width=10, font=("Segoe UI", 8))
        to_entry.grid(row=0, column=4, padx=2, pady=1)
        ttk.Label(frame, text="(DD-MM-YYYY)", font=("Segoe UI", 7), foreground="#666").grid(row=0, column=5, sticky="w", padx=(1,0), pady=1)
        
        # Compact quick date buttons
        quick_frame = ttk.Frame(frame)
        quick_frame.grid(row=1, column=0, columnspan=6, pady=(3,0))
        
        def set_this_month():
            today = date.today()
            first_day = date(today.year, today.month, 1)
            self.filter_from_date.set(first_day.strftime("%d-%m-%Y"))
            self.filter_to_date.set(today.strftime("%d-%m-%Y"))
        
        def set_last_month():
            today = date.today()
            if today.month == 1:
                last_month = date(today.year - 1, 12, 1)
            else:
                last_month = date(today.year, today.month - 1, 1)
            
            # Get last day of last month
            if last_month.month == 12:
                next_month = date(last_month.year + 1, 1, 1)
            else:
                next_month = date(last_month.year, last_month.month + 1, 1)
            last_day = next_month - timedelta(days=1)
            
            self.filter_from_date.set(last_month.strftime("%d-%m-%Y"))
            self.filter_to_date.set(last_day.strftime("%d-%m-%Y"))
        
        # Smaller buttons with compact style
        style = ttk.Style()
        style.configure("Small.TButton", padding=(4, 2), font=("Segoe UI", 7))
        ttk.Button(quick_frame, text="This Month", command=set_this_month, width=9, style="Small.TButton").pack(side=tk.LEFT, padx=1)
        ttk.Button(quick_frame, text="Last Month", command=set_last_month, width=9, style="Small.TButton").pack(side=tk.LEFT, padx=1)
        ttk.Button(quick_frame, text="Clear", command=lambda: (self.filter_from_date.set(""), self.filter_to_date.set("")), width=6, style="Small.TButton").pack(side=tk.LEFT, padx=1)
        
        self.filter_frames["Time Period"] = frame

    def _build_payment_type_filter(self):
        frame = ttk.Frame(self.dynamic_filter_box)
        ttk.Label(frame, text="Payment Type:", font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(4,3))
        self.dashboard_filter_payment_type_var = tk.StringVar()  # Renamed to avoid conflict
        types = ["Rent", "Maintenance charge", "Amenities", "Corpus Fund", "Other"]
        combo = ttk.Combobox(frame, textvariable=self.dashboard_filter_payment_type_var, values=types, state="readonly", width=16, font=("Segoe UI", 8))
        combo.pack(side=tk.LEFT, padx=2)
        self.filter_frames["Payment Type"] = frame

    def _build_payment_status_filter(self):
        frame = ttk.Frame(self.dynamic_filter_box)
        ttk.Label(frame, text="Payment Status:", font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(4,3))
        self.dashboard_filter_payment_status_var = tk.StringVar()  # Renamed to avoid conflict
        statuses = ["Paid", "Unpaid", "Partial"]
        combo = ttk.Combobox(frame, textvariable=self.dashboard_filter_payment_status_var, values=statuses, state="readonly", width=12, font=("Segoe UI", 8))
        combo.pack(side=tk.LEFT, padx=2)
        self.filter_frames["Payment Status"] = frame

    def _build_member_type_filter(self):
        frame = ttk.Frame(self.dynamic_filter_box)
        ttk.Label(frame, text="Member Type:", font=("Segoe UI", 8)).pack(side=tk.LEFT, padx=(4,3))
        self.filter_member_type_var = tk.StringVar()
        mtypes = ["Row House Owner", "Flat Owner", "Tenant"]
        combo = ttk.Combobox(frame, textvariable=self.filter_member_type_var, values=mtypes, state="readonly", width=14, font=("Segoe UI", 8))
        combo.pack(side=tk.LEFT, padx=2)
        self.filter_frames["Member Type"] = frame

    def _show_filter_frame(self, key):
        for k, f in self.filter_frames.items():
            if k == key:
                f.pack(fill="x")
            else:
                f.pack_forget()

    # --- Complaints ---
    def _build_complaints_tab(self):
        frame = self.complaints_tab
        
        # Main container with modern layout
        main_container = ttk.Frame(frame)
        main_container.pack(fill="both", expand=True, padx=8, pady=8)
        
        # Left panel for complaints list
        left_panel = ttk.Frame(main_container)
        left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 8))
        
        # Enhanced complaints tree with flat number
        complaint_columns = ("id", "member", "flat_no", "title", "date", "status", "priority")
        self.complaints_tree = ttk.Treeview(left_panel, columns=complaint_columns, show="headings", height=15)
        
        # Configure columns
        self.complaints_tree.heading("id", text="ID")
        self.complaints_tree.column("id", width=50, anchor="center")
        self.complaints_tree.heading("member", text="Member Name")
        self.complaints_tree.column("member", width=150, anchor="w")
        self.complaints_tree.heading("flat_no", text="Flat No")
        self.complaints_tree.column("flat_no", width=80, anchor="center")
        self.complaints_tree.heading("title", text="Complaint Title")
        self.complaints_tree.column("title", width=200, anchor="w")
        self.complaints_tree.heading("date", text="Date")
        self.complaints_tree.column("date", width=100, anchor="center")
        self.complaints_tree.heading("status", text="Status")
        self.complaints_tree.column("status", width=80, anchor="center")
        self.complaints_tree.heading("priority", text="Priority")
        self.complaints_tree.column("priority", width=80, anchor="center")
        
        # Add scrollbar for complaints tree
        complaints_scrollbar = ttk.Scrollbar(left_panel, orient="vertical", command=self.complaints_tree.yview)
        self.complaints_tree.configure(yscrollcommand=complaints_scrollbar.set)
        
        self.complaints_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        complaints_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Right panel for controls
        right_panel = ttk.Frame(main_container, width=280)
        right_panel.pack(side=tk.RIGHT, fill=tk.Y)
        right_panel.pack_propagate(False)
        
        # Complaint Management section
        complaint_mgmt_frame = ttk.LabelFrame(right_panel, text="🔧 Complaint Management", padding=10)
        complaint_mgmt_frame.pack(fill="x", pady=(0, 10))
        
        tk.Button(complaint_mgmt_frame, text="Register Complaint", command=self.register_complaint_window,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#16a34a", fg="white").pack(fill="x", pady=2)
        
        tk.Button(complaint_mgmt_frame, text="Edit Complaint", command=self.edit_complaint_window,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#3b82f6", fg="white").pack(fill="x", pady=2)
        
        tk.Button(complaint_mgmt_frame, text="Delete Complaint", command=self.delete_complaint,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#dc2626", fg="white").pack(fill="x", pady=2)
        
        tk.Button(complaint_mgmt_frame, text="Resolve Complaint", command=self.resolve_complaint,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#059669", fg="white").pack(fill="x", pady=2)
        
        # Search & Filter section
        search_frame = ttk.LabelFrame(right_panel, text="🔍 Search & Filter", padding=10)
        search_frame.pack(fill="x", pady=(0, 10))
        
        # Search by member name
        ttk.Label(search_frame, text="Search by Member:", font=("Segoe UI", 9, "bold")).pack(anchor="w", pady=(0, 5))
        self.search_member_var = tk.StringVar()
        member_entry = ttk.Entry(search_frame, textvariable=self.search_member_var, width=25)
        member_entry.pack(fill="x", pady=(0, 8))
        self.search_member_var.trace('w', lambda *args: self.refresh_complaints())  # Auto-search
        
        # Search by flat number
        ttk.Label(search_frame, text="Search by Flat No:", font=("Segoe UI", 9, "bold")).pack(anchor="w", pady=(0, 5))
        self.search_flat_var = tk.StringVar()
        flat_entry = ttk.Entry(search_frame, textvariable=self.search_flat_var, width=25)
        flat_entry.pack(fill="x", pady=(0, 8))
        self.search_flat_var.trace('w', lambda *args: self.refresh_complaints())  # Auto-search
        
        # Search by title
        ttk.Label(search_frame, text="Search by Title:", font=("Segoe UI", 9, "bold")).pack(anchor="w", pady=(0, 5))
        self.search_title_var = tk.StringVar()
        title_entry = ttk.Entry(search_frame, textvariable=self.search_title_var, width=25)
        title_entry.pack(fill="x", pady=(0, 8))
        self.search_title_var.trace('w', lambda *args: self.refresh_complaints())  # Auto-search
        
        # Status filter
        ttk.Label(search_frame, text="Filter by Status:", font=("Segoe UI", 9, "bold")).pack(anchor="w", pady=(0, 5))
        self.filter_status_var = tk.StringVar(value="All")
        status_combo = ttk.Combobox(search_frame, textvariable=self.filter_status_var,
                                   values=["All", "Open", "In Progress", "Closed"],
                                   state="readonly", width=22)
        status_combo.pack(fill="x", pady=(0, 8))
        status_combo.bind('<<ComboboxSelected>>', lambda *args: self.refresh_complaints())  # Auto-filter
        
        # Priority filter
        ttk.Label(search_frame, text="Filter by Priority:", font=("Segoe UI", 9, "bold")).pack(anchor="w", pady=(0, 5))
        self.filter_priority_var = tk.StringVar(value="All")
        priority_combo = ttk.Combobox(search_frame, textvariable=self.filter_priority_var,
                                     values=["All", "High", "Medium", "Low"],
                                     state="readonly", width=22)
        priority_combo.pack(fill="x", pady=(0, 10))
        priority_combo.bind('<<ComboboxSelected>>', lambda *args: self.refresh_complaints())  # Auto-filter
        
        # Search buttons
        search_btn_frame = ttk.Frame(search_frame)
        search_btn_frame.pack(fill="x")
        
        tk.Button(search_btn_frame, text="Search", command=self.search_complaints,
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=15, pady=6,
                 bg="#7c3aed", fg="white").pack(side="left", padx=(0, 5))
        
        tk.Button(search_btn_frame, text="Clear", command=self.clear_complaint_search,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=15, pady=6).pack(side="right")
        
        # Quick Actions section
        actions_frame = ttk.LabelFrame(right_panel, text="⚡ Quick Actions", padding=10)
        actions_frame.pack(fill="x", pady=(0, 10))
        
        tk.Button(actions_frame, text="View Details", command=self.view_complaint_details,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#8b5cf6", fg="white").pack(fill="x", pady=2)
        
        tk.Button(actions_frame, text="Export Report", command=self.export_complaints_csv,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6).pack(fill="x", pady=2)
        
        # Statistics section
        stats_frame = ttk.LabelFrame(right_panel, text="📊 Statistics", padding=10)
        stats_frame.pack(fill="x")
        
        self.complaint_stats_labels = {}
        self.complaint_stats_labels['total'] = ttk.Label(stats_frame, text="Total Complaints: 0", font=("Segoe UI", 9, "bold"))
        self.complaint_stats_labels['total'].pack(anchor="w", pady=2)
        
        self.complaint_stats_labels['open'] = ttk.Label(stats_frame, text="Open: 0", font=("Segoe UI", 8), foreground="#dc2626")
        self.complaint_stats_labels['open'].pack(anchor="w", pady=1)
        
        self.complaint_stats_labels['in_progress'] = ttk.Label(stats_frame, text="In Progress: 0", font=("Segoe UI", 8), foreground="#f59e0b")
        self.complaint_stats_labels['in_progress'].pack(anchor="w", pady=1)
        
        self.complaint_stats_labels['closed'] = ttk.Label(stats_frame, text="Closed: 0", font=("Segoe UI", 8), foreground="#16a34a")
        self.complaint_stats_labels['closed'].pack(anchor="w", pady=1)
        
        # Bind double-click to view details
        self.complaints_tree.bind("<Double-1>", lambda e: self.view_complaint_details())
        
        # Add right-click context menu
        self.complaints_context_menu = tk.Menu(self, tearoff=0)
        self.complaints_context_menu.add_command(label="📋 View Details", command=self.view_complaint_details)
        self.complaints_context_menu.add_command(label="✏️ Edit Complaint", command=self.edit_complaint_window)
        self.complaints_context_menu.add_command(label="✅ Resolve Complaint", command=self.resolve_complaint)
        self.complaints_context_menu.add_separator()
        self.complaints_context_menu.add_command(label="⚡ Mark as High Priority", command=self.mark_complaint_urgent)
        self.complaints_context_menu.add_command(label="📧 Send Reminder", command=self.send_complaint_reminder)
        self.complaints_context_menu.add_separator()
        self.complaints_context_menu.add_command(label="🗑️ Delete Complaint", command=self.delete_complaint)
        
        def show_context_menu(event):
            try:
                # Select the item under cursor
                item = self.complaints_tree.identify_row(event.y)
                if item:
                    self.complaints_tree.selection_set(item)
                    self.complaints_context_menu.post(event.x_root, event.y_root)
            except Exception:
                pass
        
        self.complaints_tree.bind("<Button-3>", show_context_menu)  # Right-click
        
        # Initialize the complaints display
        self.refresh_complaints()

    # --- Events, Staff, Parking, Inventory (concise versions) ---
    def _build_events_tab(self):
        frame = self.events_tab
        
        # Main container with modern layout
        main_container = ttk.Frame(frame)
        main_container.pack(fill="both", expand=True, padx=8, pady=8)
        
        # Left panel for events list
        left_panel = ttk.Frame(main_container)
        left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 8))
        
        # Events tree with enhanced columns
        event_columns = ("id", "title", "event_date", "status", "total_budget", "total_collected")
        self.events_tree = ttk.Treeview(left_panel, columns=event_columns, show="headings", height=15)
        
        # Configure columns
        self.events_tree.heading("id", text="ID")
        self.events_tree.column("id", width=50, anchor="center")
        self.events_tree.heading("title", text="Event Name")
        self.events_tree.column("title", width=180, anchor="w")
        self.events_tree.heading("event_date", text="Event Date")
        self.events_tree.column("event_date", width=100, anchor="center")
        self.events_tree.heading("status", text="Status")
        self.events_tree.column("status", width=80, anchor="center")
        self.events_tree.heading("total_budget", text="Budget")
        self.events_tree.column("total_budget", width=100, anchor="center")
        self.events_tree.heading("total_collected", text="Collected")
        self.events_tree.column("total_collected", width=100, anchor="center")
        
        # Add scrollbar for events tree
        events_scrollbar = ttk.Scrollbar(left_panel, orient="vertical", command=self.events_tree.yview)
        self.events_tree.configure(yscrollcommand=events_scrollbar.set)
        
        self.events_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        events_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Right panel for controls
        right_panel = ttk.Frame(main_container, width=280)
        right_panel.pack(side=tk.RIGHT, fill=tk.Y)
        right_panel.pack_propagate(False)
        
        # Event Management section
        event_mgmt_frame = ttk.LabelFrame(right_panel, text="🎉 Event Management", padding=10)
        event_mgmt_frame.pack(fill="x", pady=(0, 10))
        
        tk.Button(event_mgmt_frame, text="Add Event", command=self.add_event_window,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#16a34a", fg="white").pack(fill="x", pady=2)
        
        tk.Button(event_mgmt_frame, text="Edit Event", command=self.edit_event_window,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#3b82f6", fg="white").pack(fill="x", pady=2)
        
        tk.Button(event_mgmt_frame, text="Delete Event", command=self.delete_event,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#dc2626", fg="white").pack(fill="x", pady=2)
        
        # Contribution Management section
        contrib_frame = ttk.LabelFrame(right_panel, text="💰 Contribution Management", padding=10)
        contrib_frame.pack(fill="x", pady=(0, 10))
        
        tk.Button(contrib_frame, text="Add Contribution", command=self.add_contribution_window,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#059669", fg="white").pack(fill="x", pady=2)
        
        tk.Button(contrib_frame, text="View Contributions", command=self.view_contributions_window,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#7c3aed", fg="white").pack(fill="x", pady=2)
        
        # Quick Actions section
        actions_frame = ttk.LabelFrame(right_panel, text="⚡ Quick Actions", padding=10)
        actions_frame.pack(fill="x", pady=(0, 10))
        
        # --- Member Filter & Slip Generation ---
        ttk.Label(actions_frame, text="Filter by Member:", font=("Segoe UI", 9, "bold")).pack(anchor="w", pady=(0, 5))
        # Load member list for filter (id - name (flat))
        members = self.db.fetchall("SELECT id, name, flat_no FROM members ORDER BY name")
        self.member_filter_map = {f"{m['id']} - {m['name']} ({m['flat_no']})": m['id'] for m in members}
        self.filter_member_var = tk.StringVar()
        member_combo = ttk.Combobox(actions_frame, textvariable=self.filter_member_var,
                                    values=list(self.member_filter_map.keys()), state="readonly")
        member_combo.pack(fill="x", pady=(0, 8))

        tk.Button(actions_frame, text="Generate Slip", command=self.generate_member_contrib_slip,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#f59e0b", fg="white").pack(fill="x", pady=2)
        
        # Event Statistics section
        stats_frame = ttk.LabelFrame(right_panel, text="📊 Statistics", padding=10)
        stats_frame.pack(fill="x")
        
        self.event_stats_labels = {}
        self.event_stats_labels['total'] = ttk.Label(stats_frame, text="Total Events: 0", font=("Segoe UI", 9, "bold"))
        self.event_stats_labels['total'].pack(anchor="w", pady=2)
        
        self.event_stats_labels['upcoming'] = ttk.Label(stats_frame, text="Upcoming: 0", font=("Segoe UI", 8), foreground="#16a34a")
        self.event_stats_labels['upcoming'].pack(anchor="w", pady=1)
        
        self.event_stats_labels['budget'] = ttk.Label(stats_frame, text="Total Budget: ₹0", font=("Segoe UI", 8), foreground="#3b82f6")
        self.event_stats_labels['budget'].pack(anchor="w", pady=1)
        
        self.event_stats_labels['collected'] = ttk.Label(stats_frame, text="Total Collected: ₹0", font=("Segoe UI", 8), foreground="#059669")
        self.event_stats_labels['collected'].pack(anchor="w", pady=1)
        
        # Bind double-click to view contributions
        self.events_tree.bind("<Double-1>", lambda e: self.view_contributions_window())
        
        # Initialize the events display
        self.refresh_events()

    def _build_staff_tab(self):
        frame = self.staff_tab
        
        # Main container with modern layout
        main_container = ttk.Frame(frame)
        main_container.pack(fill="both", expand=True, padx=8, pady=8)
        
        # Left panel for staff list
        left_panel = ttk.Frame(main_container)
        left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 8))
        
        # Enhanced staff tree with better columns
        staff_columns = ("id", "name", "role", "phone", "salary", "joined_date", "status")
        self.staff_tree = ttk.Treeview(left_panel, columns=staff_columns, show="headings", height=15)
        
        # Configure columns with better headers and sizing
        self.staff_tree.heading("id", text="ID")
        self.staff_tree.column("id", width=50, anchor="center")
        self.staff_tree.heading("name", text="Staff Name")
        self.staff_tree.column("name", width=180, anchor="w")
        self.staff_tree.heading("role", text="Role/Position")
        self.staff_tree.column("role", width=150, anchor="w")
        self.staff_tree.heading("phone", text="Phone Number")
        self.staff_tree.column("phone", width=120, anchor="center")
        self.staff_tree.heading("salary", text="Salary (₹)")
        self.staff_tree.column("salary", width=100, anchor="center")
        self.staff_tree.heading("joined_date", text="Joined Date")
        self.staff_tree.column("joined_date", width=120, anchor="center")
        self.staff_tree.heading("status", text="Status")
        self.staff_tree.column("status", width=80, anchor="center")

        # Add scrollbar for staff tree
        staff_scrollbar = ttk.Scrollbar(left_panel, orient="vertical", command=self.staff_tree.yview)
        self.staff_tree.configure(yscrollcommand=staff_scrollbar.set)
        
        self.staff_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        staff_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Right panel for controls
        right_panel = ttk.Frame(main_container, width=280)
        right_panel.pack(side=tk.RIGHT, fill=tk.Y)
        right_panel.pack_propagate(False)
        
        # Staff Management section
        staff_mgmt_frame = ttk.LabelFrame(right_panel, text="👥 Staff Management", padding=10)
        staff_mgmt_frame.pack(fill="x", pady=(0, 10))
        
        tk.Button(staff_mgmt_frame, text="Add Staff", command=self.add_staff_window,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#16a34a", fg="white").pack(fill="x", pady=2)
        
        tk.Button(staff_mgmt_frame, text="Edit Staff", command=self.edit_staff_window,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#3b82f6", fg="white").pack(fill="x", pady=2)
        
        tk.Button(staff_mgmt_frame, text="Delete Staff", command=self.delete_staff,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#dc2626", fg="white").pack(fill="x", pady=2)
        
        tk.Button(staff_mgmt_frame, text="View Details", command=self.view_staff_details,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#059669", fg="white").pack(fill="x", pady=2)
        
        # Search & Filter section
        search_frame = ttk.LabelFrame(right_panel, text="🔍 Search & Filter", padding=10)
        search_frame.pack(fill="x", pady=(0, 10))
        
        # Search by name
        ttk.Label(search_frame, text="Search by Name:", font=("Segoe UI", 9, "bold")).pack(anchor="w", pady=(0, 5))
        self.search_staff_name_var = tk.StringVar()
        name_entry = ttk.Entry(search_frame, textvariable=self.search_staff_name_var, width=25)
        name_entry.pack(fill="x", pady=(0, 8))
        self.search_staff_name_var.trace('w', lambda *args: self.refresh_staff())  # Auto-search
        
        # Search by role
        ttk.Label(search_frame, text="Search by Role:", font=("Segoe UI", 9, "bold")).pack(anchor="w", pady=(0, 5))
        self.search_staff_role_var = tk.StringVar()
        role_entry = ttk.Entry(search_frame, textvariable=self.search_staff_role_var, width=25)
        role_entry.pack(fill="x", pady=(0, 8))
        self.search_staff_role_var.trace('w', lambda *args: self.refresh_staff())  # Auto-search
        
        # Status filter
        ttk.Label(search_frame, text="Filter by Status:", font=("Segoe UI", 9, "bold")).pack(anchor="w", pady=(0, 5))
        self.filter_staff_status_var = tk.StringVar(value="All")
        status_combo = ttk.Combobox(search_frame, textvariable=self.filter_staff_status_var,
                                   values=["All", "Active", "Inactive", "On Leave"],
                                   state="readonly", width=22)
        status_combo.pack(fill="x", pady=(0, 10))
        status_combo.bind('<<ComboboxSelected>>', lambda *args: self.refresh_staff())  # Auto-filter
        
        # Search buttons
        search_btn_frame = ttk.Frame(search_frame)
        search_btn_frame.pack(fill="x")
        
        tk.Button(search_btn_frame, text="Clear", command=self.clear_staff_search,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=15, pady=6).pack(side="right")
        
        # Quick Actions section
        actions_frame = ttk.LabelFrame(right_panel, text="⚡ Quick Actions", padding=10)
        actions_frame.pack(fill="x", pady=(0, 10))
        
        tk.Button(actions_frame, text="Mark Present", command=self.mark_staff_present,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#16a34a", fg="white").pack(fill="x", pady=2)
        
        tk.Button(actions_frame, text="Mark On Leave", command=self.mark_staff_leave,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6,
                 bg="#f59e0b", fg="white").pack(fill="x", pady=2)
        
        tk.Button(actions_frame, text="Print Total Staff", command=self.print_total_staff,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=10, pady=6).pack(fill="x", pady=2)
        
        # Statistics section
        stats_frame = ttk.LabelFrame(right_panel, text="📊 Statistics", padding=10)
        stats_frame.pack(fill="x")
        
        self.staff_stats_labels = {}
        self.staff_stats_labels['total'] = ttk.Label(stats_frame, text="Total Staff: 0", font=("Segoe UI", 9, "bold"))
        self.staff_stats_labels['total'].pack(anchor="w", pady=2)
        
        self.staff_stats_labels['active'] = ttk.Label(stats_frame, text="Active: 0", font=("Segoe UI", 8), foreground="#16a34a")
        self.staff_stats_labels['active'].pack(anchor="w", pady=1)
        
        self.staff_stats_labels['on_leave'] = ttk.Label(stats_frame, text="On Leave: 0", font=("Segoe UI", 8), foreground="#f59e0b")
        self.staff_stats_labels['on_leave'].pack(anchor="w", pady=1)
        
        self.staff_stats_labels['total_salary'] = ttk.Label(stats_frame, text="Total Salary: ₹0", font=("Segoe UI", 8), foreground="#3b82f6")
        self.staff_stats_labels['total_salary'].pack(anchor="w", pady=1)
        
        # Add right-click context menu
        self.staff_context_menu = tk.Menu(self, tearoff=0)
        self.staff_context_menu.add_command(label="👤 View Details", command=self.view_staff_details)
        self.staff_context_menu.add_command(label="✏️ Edit Staff", command=self.edit_staff_window)
        self.staff_context_menu.add_separator()
        self.staff_context_menu.add_command(label="✅ Mark Present", command=self.mark_staff_present)
        self.staff_context_menu.add_command(label="🏖️ Mark On Leave", command=self.mark_staff_leave)
        self.staff_context_menu.add_separator()
        self.staff_context_menu.add_command(label="🗑️ Delete Staff", command=self.delete_staff)
        
        def show_staff_context_menu(event):
            try:
                # Select the item under cursor
                item = self.staff_tree.identify_row(event.y)
                if item:
                    self.staff_tree.selection_set(item)
                    self.staff_context_menu.post(event.x_root, event.y_root)
            except Exception:
                pass
        
        self.staff_tree.bind("<Button-3>", show_staff_context_menu)  # Right-click
        
        # Bind double-click to view details
        self.staff_tree.bind("<Double-1>", lambda e: self.view_staff_details())
        
        # Initialize the staff display
        self.refresh_staff()

    def _build_parking_tab(self):
        frame = self.parking_tab
        
        # Main container with modern layout
        main_container = ttk.Frame(frame)
        main_container.pack(fill="both", expand=True, padx=8, pady=8)
        
        # Header section with title and statistics
        header_frame = ttk.Frame(main_container)
        header_frame.pack(fill="x", pady=(0, 15))
        
        title_frame = ttk.Frame(header_frame)
        title_frame.pack(side="left")
        
        ttk.Label(title_frame, text="Parking Management", font=("Segoe UI", 16, "bold")).pack(anchor="w")
        ttk.Label(title_frame, text="Manage parking slots and vehicle allocations", font=("Segoe UI", 10)).pack(anchor="w")
        
        # Statistics frame with enhanced styling
        self.parking_stats_frame = ttk.LabelFrame(header_frame, text="Statistics", padding=8)
        self.parking_stats_frame.pack(side="right", fill="y")
        
        self.parking_stats_labels = {}
        stats_container = ttk.Frame(self.parking_stats_frame)
        stats_container.pack()
        
        # Enhanced statistics with better formatting and colors
        self.parking_stats_labels['total'] = ttk.Label(stats_container, text="Total Slots: 0", font=("Segoe UI", 9, "bold"))
        self.parking_stats_labels['total'].pack(anchor="w", pady=(0, 3))
        
        self.parking_stats_labels['allocated'] = ttk.Label(stats_container, text="Allocated: 0", font=("Segoe UI", 9), foreground="#dc2626")
        self.parking_stats_labels['allocated'].pack(anchor="w", pady=(0, 3))
        
        self.parking_stats_labels['free'] = ttk.Label(stats_container, text="Free: 0", font=("Segoe UI", 9), foreground="#16a34a")
        self.parking_stats_labels['free'].pack(anchor="w", pady=(0, 3))
        
        # Search and filter section
        search_frame = ttk.LabelFrame(main_container, text="Search & Filter", padding=8)
        search_frame.pack(fill="x", pady=(0, 15))
        
        # Search fields
        search_fields_frame = ttk.Frame(search_frame)
        search_fields_frame.pack(fill="x")
        
        ttk.Label(search_fields_frame, text="Slot No:").grid(row=0, column=0, padx=(0, 5), sticky="w")
        self.parking_search_slot_var = tk.StringVar()
        ttk.Entry(search_fields_frame, textvariable=self.parking_search_slot_var, width=15).grid(row=0, column=1, padx=(0, 15), sticky="w")
        
        ttk.Label(search_fields_frame, text="Member:").grid(row=0, column=2, padx=(0, 5), sticky="w")
        self.parking_search_member_var = tk.StringVar()
        ttk.Entry(search_fields_frame, textvariable=self.parking_search_member_var, width=20).grid(row=0, column=3, padx=(0, 15), sticky="w")
        
        ttk.Label(search_fields_frame, text="Vehicle:").grid(row=0, column=4, padx=(0, 5), sticky="w")
        self.parking_search_vehicle_var = tk.StringVar()
        ttk.Entry(search_fields_frame, textvariable=self.parking_search_vehicle_var, width=15).grid(row=0, column=5, padx=(0, 15), sticky="w")
        
        # Buttons
        button_frame = ttk.Frame(search_fields_frame)
        button_frame.grid(row=0, column=6, sticky="e")
        
        ttk.Button(button_frame, text="Search", command=self.search_parking, style="Small.TButton").pack(side="left", padx=(0, 5))
        ttk.Button(button_frame, text="Clear", command=self.clear_parking_search, style="Small.TButton").pack(side="left", padx=(0, 5))
        ttk.Button(button_frame, text="Refresh", command=self.refresh_parking, style="Small.TButton").pack(side="left")
        
        # Main content area with treeview and action buttons
        content_frame = ttk.Frame(main_container)
        content_frame.pack(fill="both", expand=True)
        
        # Left side - Parking treeview
        left_frame = ttk.Frame(content_frame)
        left_frame.pack(side="left", fill="both", expand=True)
        
        # Treeview with scrollbars
        tree_frame = ttk.Frame(left_frame)
        tree_frame.pack(fill="both", expand=True)
        
        # Define columns
        parking_cols = ("slot_no", "member_name", "flat_no", "vehicle_number", "vehicle_model", "allocated_date")
        self.parking_tree = ttk.Treeview(tree_frame, columns=parking_cols, show="headings", height=15)
        
        # Define headings
        self.parking_tree.heading("slot_no", text="Slot No")
        self.parking_tree.heading("member_name", text="Member Name")
        self.parking_tree.heading("flat_no", text="Flat No")
        self.parking_tree.heading("vehicle_number", text="Vehicle Number")
        self.parking_tree.heading("vehicle_model", text="Vehicle Model")
        self.parking_tree.heading("allocated_date", text="Allocated Date")
        
        # Define column widths
        self.parking_tree.column("slot_no", width=80, anchor="center")
        self.parking_tree.column("member_name", width=150)
        self.parking_tree.column("flat_no", width=80, anchor="center")
        self.parking_tree.column("vehicle_number", width=120, anchor="center")
        self.parking_tree.column("vehicle_model", width=120)
        self.parking_tree.column("allocated_date", width=100, anchor="center")
        
        # Scrollbars
        parking_vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=self.parking_tree.yview)
        parking_hsb = ttk.Scrollbar(tree_frame, orient="horizontal", command=self.parking_tree.xview)
        self.parking_tree.configure(yscrollcommand=parking_vsb.set, xscrollcommand=parking_hsb.set)
        
        # Grid placement
        self.parking_tree.grid(row=0, column=0, sticky="nsew")
        parking_vsb.grid(row=0, column=1, sticky="ns")
        parking_hsb.grid(row=1, column=0, sticky="ew")
        
        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)
        
        # Right side - Action buttons
        right_frame = ttk.Frame(content_frame, width=150)
        right_frame.pack(side="right", fill="y", padx=(10, 0))
        right_frame.pack_propagate(False)
        
        ttk.Button(right_frame, text="Allocate Slot", command=self.allocate_parking_window, style="Accent.TButton").pack(fill="x", pady=(0, 5))
        ttk.Button(right_frame, text="Free Slot", command=self.free_parking_slot, style="Small.TButton").pack(fill="x", pady=(0, 5))
        ttk.Button(right_frame, text="Delete Slot", command=self.delete_parking_slot, style="Small.TButton").pack(fill="x", pady=(0, 5))
        ttk.Button(right_frame, text="View Details", command=self.view_parking_details, style="Small.TButton").pack(fill="x", pady=(0, 5))
        ttk.Button(right_frame, text="Export CSV", command=self.export_parking_csv, style="Small.TButton").pack(fill="x", pady=(0, 5))
        ttk.Button(right_frame, text="Print Report", command=self.print_parking_report, style="Small.TButton").pack(fill="x", pady=(0, 5))
        ttk.Button(right_frame, text="Slot Audit", command=self.parking_slot_audit, style="Small.TButton").pack(fill="x", pady=(0, 5))
        
        # Context menu for treeview
        self.parking_context_menu = tk.Menu(self.parking_tree, tearoff=0)
        self.parking_context_menu.add_command(label="View Details", command=self.view_parking_details)
        self.parking_context_menu.add_command(label="Free Slot", command=self.free_parking_slot)
        self.parking_context_menu.add_command(label="Delete Slot", command=self.delete_parking_slot)
        self.parking_context_menu.add_separator()
        self.parking_context_menu.add_command(label="Refresh", command=self.refresh_parking)
        
        # Bind events
        self.parking_tree.bind("<Button-3>", self._show_parking_context_menu)  # Right-click
        self.parking_tree.bind("<Double-1>", self.view_parking_details)  # Double-click
        
        # Initialize data
        self.refresh_parking()

    def _build_inventory_tab(self):
        frame = self.inventory_tab
        
        # Configure grid layout for better organization
        frame.columnconfigure(0, weight=3)
        frame.columnconfigure(1, weight=1)
        frame.rowconfigure(0, weight=1)
        
        # Main content area
        main_frame = ttk.Frame(frame)
        main_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 5), pady=5)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # Inventory items section
        inventory_frame = ttk.LabelFrame(main_frame, text="📦 Inventory Items", padding=10)
        inventory_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 10))
        inventory_frame.columnconfigure(0, weight=1)
        inventory_frame.rowconfigure(0, weight=1)
        
        # Inventory treeview
        cols = ("id", "item_name", "quantity", "unit", "min_required")
        self.inventory_tree = ttk.Treeview(inventory_frame, columns=cols, show="headings", height=8)
        for c in cols:
            self.inventory_tree.heading(c, text=c.replace("_", " ").title())
            self.inventory_tree.column(c, width=120)
        self.inventory_tree.grid(row=0, column=0, sticky="nsew")
        
        # Scrollbar for inventory tree
        inv_scrollbar = ttk.Scrollbar(inventory_frame, orient="vertical", command=self.inventory_tree.yview)
        inv_scrollbar.grid(row=0, column=1, sticky="ns")
        self.inventory_tree.configure(yscrollcommand=inv_scrollbar.set)
        
        # Flat-wise usage section
        flat_usage_frame = ttk.LabelFrame(main_frame, text="🏢 Flat-wise Inventory Usage", padding=10)
        flat_usage_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        flat_usage_frame.columnconfigure(0, weight=1)
        flat_usage_frame.rowconfigure(0, weight=1)
        
        # Flat usage treeview
        flat_cols = ("flat_no", "item_name", "quantity_used", "last_used")
        self.flat_usage_tree = ttk.Treeview(flat_usage_frame, columns=flat_cols, show="headings", height=6)
        for c in flat_cols:
            self.flat_usage_tree.heading(c, text=c.replace("_", " ").title())
            self.flat_usage_tree.column(c, width=120)
        self.flat_usage_tree.grid(row=0, column=0, sticky="nsew")
        
        # Scrollbar for flat usage tree
        flat_scrollbar = ttk.Scrollbar(flat_usage_frame, orient="vertical", command=self.flat_usage_tree.yview)
        flat_scrollbar.grid(row=0, column=1, sticky="ns")
        self.flat_usage_tree.configure(yscrollcommand=flat_scrollbar.set)
        
        # Event usage section
        event_usage_frame = ttk.LabelFrame(main_frame, text="🎉 Event-related Inventory Usage", padding=10)
        event_usage_frame.grid(row=2, column=0, sticky="nsew")
        event_usage_frame.columnconfigure(0, weight=1)
        event_usage_frame.rowconfigure(0, weight=1)
        
        # Event usage treeview
        event_cols = ("event_name", "item_name", "quantity_used", "date_used")
        self.event_usage_tree = ttk.Treeview(event_usage_frame, columns=event_cols, show="headings", height=6)
        for c in event_cols:
            self.event_usage_tree.heading(c, text=c.replace("_", " ").title())
            self.event_usage_tree.column(c, width=120)
        self.event_usage_tree.grid(row=0, column=0, sticky="nsew")
        
        # Scrollbar for event usage tree
        event_scrollbar = ttk.Scrollbar(event_usage_frame, orient="vertical", command=self.event_usage_tree.yview)
        event_scrollbar.grid(row=0, column=1, sticky="ns")
        self.event_usage_tree.configure(yscrollcommand=event_scrollbar.set)
        
        # Control panel on the right
        control_frame = ttk.Frame(frame, width=200)
        control_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 0), pady=5)
        control_frame.pack_propagate(False)
        
        # Action buttons
        actions_frame = ttk.LabelFrame(control_frame, text="Actions", padding=10)
        actions_frame.pack(fill="x", pady=(0, 10))
        
        ttk.Button(actions_frame, text="➕ Add Item", command=self.add_inventory_window, style="Small.TButton").pack(fill="x", pady=2)
        ttk.Button(actions_frame, text="📤 Use Item", command=self.use_inventory_window_enhanced, style="Small.TButton").pack(fill="x", pady=2)
        ttk.Button(actions_frame, text="🔄 Refresh", command=self.refresh_inventory_tab, style="Small.TButton").pack(fill="x", pady=2)
        
        # Export buttons
        export_frame = ttk.LabelFrame(control_frame, text="Export Data", padding=10)
        export_frame.pack(fill="x", pady=(0, 10))
        
        ttk.Button(export_frame, text="📋 Export Inventory", command=self.export_inventory_csv, style="Small.TButton").pack(fill="x", pady=2)
        ttk.Button(export_frame, text="📊 Export Usage Log", command=self.export_inventory_usage_csv, style="Small.TButton").pack(fill="x", pady=2)
        ttk.Button(export_frame, text="🏘️ Export Flat Usage", command=self.export_flat_usage_csv, style="Small.TButton").pack(fill="x", pady=2)
        ttk.Button(export_frame, text="🎊 Export Event Usage", command=self.export_event_usage_csv, style="Small.TButton").pack(fill="x", pady=2)
        
        # Summary section
        summary_frame = ttk.LabelFrame(control_frame, text="Summary", padding=10)
        summary_frame.pack(fill="x", pady=(0, 10), expand=True)
        
        self.total_items_label = ttk.Label(summary_frame, text="Total Items: 0")
        self.total_items_label.pack(anchor="w", pady=2)
        
        self.total_quantity_label = ttk.Label(summary_frame, text="Total Quantity: 0")
        self.total_quantity_label.pack(anchor="w", pady=2)
        
        self.low_stock_label = ttk.Label(summary_frame, text="Low Stock Items: 0", foreground="red")
        self.low_stock_label.pack(anchor="w", pady=2)
        
        # Initialize the tab
        self.refresh_inventory_tab()

    # --- Account Settings ---
    def _build_account_tab(self):
        frame = self.account_tab
        
        # Main container with modern styling
        main_frame = ttk.Frame(frame, padding=12, style="Card.TFrame")
        main_frame.pack(fill="both", expand=True, padx=12, pady=12)
        
        # Header
        ttk.Label(main_frame, text="Account Settings", style="Header.TLabel").pack(anchor="w", pady=(0, 12))
        
        # Current user info section
        info_frame = ttk.LabelFrame(main_frame, text="Current Account Information", padding=8)
        info_frame.pack(fill="x", pady=(0, 16))
        
        ttk.Label(info_frame, text=f"Current Username: {self.current_user}", font=("Segoe UI", 9)).pack(anchor="w", pady=4)
        ttk.Label(info_frame, text="Login Role: Administrator", font=("Segoe UI", 9)).pack(anchor="w", pady=4)
        
        # Get license manager for mode detection
        license_manager = LicenseManager()
        
        # License information section - ONLY show in Developer Mode
        if license_manager.developer_mode:
            license_frame = ttk.LabelFrame(main_frame, text="License Information", padding=8)
            license_frame.pack(fill="x", pady=(0, 16))
            
            # Get license info
            license_info = license_manager.get_license_info()
            machine_id = license_manager.get_machine_id()
            
            ttk.Label(license_frame, text=f"License Status: {license_info}", font=("Segoe UI", 9)).pack(anchor="w", pady=4)
            ttk.Label(license_frame, text=f"Machine ID: {machine_id}", font=("Segoe UI", 8), foreground="#6b7280").pack(anchor="w", pady=2)
            
            # Developer mode indicator
            ttk.Label(license_frame, text="🔧 Developer Mode - Full Access", font=("Segoe UI", 9, "bold"), foreground="#059669").pack(anchor="w", pady=2)
            
            # License management buttons - Developer only
            license_btn_frame = ttk.Frame(license_frame)
            license_btn_frame.pack(fill="x", pady=(8, 0))
            
            ttk.Button(license_btn_frame, text="View License Details", command=self.view_license_details, style="Small.TButton").pack(side="left", padx=(0, 8))
            ttk.Button(license_btn_frame, text="Copy Machine ID", command=lambda: self.copy_machine_id(machine_id), style="Small.TButton").pack(side="left", padx=(0, 8))
            ttk.Button(license_btn_frame, text="Generate Customer License", command=self.open_license_generator, style="Small.TButton").pack(side="left", padx=(0, 8))
            ttk.Button(license_btn_frame, text="System Analytics", command=self.open_system_analytics, style="Small.TButton").pack(side="left", padx=(0, 8))
            ttk.Button(license_btn_frame, text="License Control", command=self.open_license_control, style="Small.TButton").pack(side="left")
            
            # System tracking section - Developer Mode only
            tracking_frame = ttk.LabelFrame(main_frame, text="📊 System Tracking & Control", padding=8)
            tracking_frame.pack(fill="x", pady=(0, 16))
            
            # Get system statistics
            try:
                enhanced_manager = EnhancedLicenseManager()
                analytics = enhanced_manager.get_system_analytics()
                
                # Create analytics display in organized rows
                stats_frame = ttk.Frame(tracking_frame)
                stats_frame.pack(fill="x", pady=8)
                
                # Row 1: Customer and License counts
                row1_frame = ttk.Frame(stats_frame)
                row1_frame.pack(fill="x", pady=2)
                
                ttk.Label(row1_frame, text="👥 Total Customers:", font=("Segoe UI", 9)).pack(side="left")
                ttk.Label(row1_frame, text=str(analytics['total_customers']), font=("Segoe UI", 9, "bold"), foreground="#3b82f6").pack(side="left", padx=(5, 20))
                
                ttk.Label(row1_frame, text="✅ Active Licenses:", font=("Segoe UI", 9)).pack(side="left")
                ttk.Label(row1_frame, text=str(analytics['active_licenses']), font=("Segoe UI", 9, "bold"), foreground="#16a34a").pack(side="left", padx=(5, 0))
                
                # Row 2: Expired and Recent usage
                row2_frame = ttk.Frame(stats_frame)
                row2_frame.pack(fill="x", pady=2)
                
                ttk.Label(row2_frame, text="❌ Expired Licenses:", font=("Segoe UI", 9)).pack(side="left")
                ttk.Label(row2_frame, text=str(analytics['expired_licenses']), font=("Segoe UI", 9, "bold"), foreground="#dc2626").pack(side="left", padx=(5, 20))
                
                ttk.Label(row2_frame, text="📈 Recent Usage:", font=("Segoe UI", 9)).pack(side="left")
                ttk.Label(row2_frame, text=str(analytics['recent_usage']), font=("Segoe UI", 9, "bold"), foreground="#8b5cf6").pack(side="left", padx=(5, 0))
                
                # Summary message
                summary_text = f"Your software is running on {analytics['total_customers']} systems worldwide"
                ttk.Label(tracking_frame, text=summary_text, font=("Segoe UI", 8, "italic"), foreground="#6b7280").pack(pady=(8, 0))
                
            except Exception as e:
                # Fallback display if enhanced analytics not available
                ttk.Label(tracking_frame, text="📊 System Tracking: Basic Mode", font=("Segoe UI", 9)).pack(anchor="w", pady=4)
                ttk.Label(tracking_frame, text="Install customer_database.py for advanced analytics", font=("Segoe UI", 8), foreground="#6b7280").pack(anchor="w", pady=2)
            
            # Quick control buttons
            control_btn_frame = ttk.Frame(tracking_frame)
            control_btn_frame.pack(fill="x", pady=(8, 0))
            
            ttk.Button(control_btn_frame, text="🔄 Refresh Stats", command=self.refresh_system_stats, style="Small.TButton").pack(side="left", padx=(0, 8))
            ttk.Button(control_btn_frame, text="📋 Export Report", command=self.export_analytics_report, style="Small.TButton").pack(side="left", padx=(0, 8))
            ttk.Button(control_btn_frame, text="🛡️ Security Check", command=self.run_security_check, style="Small.TButton").pack(side="left")
        
        else:
            # Customer Mode - Show basic system information only
            customer_frame = ttk.LabelFrame(main_frame, text="System Information", padding=8)
            customer_frame.pack(fill="x", pady=(0, 16))
            
            ttk.Label(customer_frame, text="🏢 Customer Mode - Standard Access", font=("Segoe UI", 9, "bold"), foreground="#3b82f6").pack(anchor="w", pady=4)
            ttk.Label(customer_frame, text="Welcome to Colony Management System", font=("Segoe UI", 9)).pack(anchor="w", pady=2)
            ttk.Label(customer_frame, text="All features are available for your use", font=("Segoe UI", 8), foreground="#6b7280").pack(anchor="w", pady=2)
        
        # Change password section
        change_frame = ttk.LabelFrame(main_frame, text="Change Login Credentials", padding=8)
        change_frame.pack(fill="x", pady=(0, 16))
        
        # Create form in grid layout
        form_frame = ttk.Frame(change_frame)
        form_frame.pack(fill="x", pady=8)
        
        # Current password
        ttk.Label(form_frame, text="Current Password:", font=("Segoe UI", 8)).grid(row=0, column=0, sticky="w", padx=(0, 8), pady=4)
        self.current_password_var = tk.StringVar()
        ttk.Entry(form_frame, textvariable=self.current_password_var, show="*", width=25, font=("Segoe UI", 8)).grid(row=0, column=1, sticky="w", pady=4)
        
        # New username
        ttk.Label(form_frame, text="New Username:", font=("Segoe UI", 8)).grid(row=1, column=0, sticky="w", padx=(0, 8), pady=4)
        self.new_username_var = tk.StringVar(value=self.current_user)
        ttk.Entry(form_frame, textvariable=self.new_username_var, width=25, font=("Segoe UI", 8)).grid(row=1, column=1, sticky="w", pady=4)
        
        # New password
        ttk.Label(form_frame, text="New Password:", font=("Segoe UI", 8)).grid(row=2, column=0, sticky="w", padx=(0, 8), pady=4)
        self.new_password_var = tk.StringVar()
        ttk.Entry(form_frame, textvariable=self.new_password_var, show="*", width=25, font=("Segoe UI", 8)).grid(row=2, column=1, sticky="w", pady=4)
        
        # Confirm new password
        ttk.Label(form_frame, text="Confirm New Password:", font=("Segoe UI", 8)).grid(row=3, column=0, sticky="w", padx=(0, 8), pady=4)
        self.confirm_password_var = tk.StringVar()
        ttk.Entry(form_frame, textvariable=self.confirm_password_var, show="*", width=25, font=("Segoe UI", 8)).grid(row=3, column=1, sticky="w", pady=4)
        
        # Buttons
        button_frame = ttk.Frame(change_frame)
        button_frame.pack(fill="x", pady=8)
        
        ttk.Button(button_frame, text="Update Credentials", command=self.update_credentials, style="Accent.TButton").pack(side="left", padx=(0, 8))
        ttk.Button(button_frame, text="Clear Form", command=self.clear_account_form, style="Small.TButton").pack(side="left")
        
        # Instructions
        instructions_frame = ttk.LabelFrame(main_frame, text="Instructions", padding=8)
        instructions_frame.pack(fill="x")
        
        instructions = [
            "• Enter your current password to verify your identity",
            "• Choose a new username (must be unique)",
            "• Enter a new password (minimum 4 characters)",
            "• Confirm the new password by typing it again",
            "• Click 'Update Credentials' to save changes"
        ]
        
        for instruction in instructions:
            ttk.Label(instructions_frame, text=instruction, font=("Segoe UI", 8), foreground="#6b7280").pack(anchor="w", pady=1)
    
    def update_credentials(self):
        current_pwd = self.current_password_var.get().strip()
        new_username = self.new_username_var.get().strip()
        new_password = self.new_password_var.get().strip()
        confirm_password = self.confirm_password_var.get().strip()
        
        # Validation
        if not current_pwd:
            messagebox.showerror("Validation Error", "Please enter your current password")
            return
        
        if not new_username:
            messagebox.showerror("Validation Error", "Please enter a new username")
            return
            
        if len(new_password) < 4:
            messagebox.showerror("Validation Error", "New password must be at least 4 characters")
            return
            
        if new_password != confirm_password:
            messagebox.showerror("Validation Error", "New password and confirmation do not match")
            return
        
        # Verify current password using the secure validation method
        valid, role = self.db.validate_user(self.current_user, current_pwd)
        if not valid:
            messagebox.showerror("Authentication Error", "Current password is incorrect")
            return
        
        # Check if new username already exists (if different from current)
        if new_username != self.current_user:
            existing_user = self.db.fetchone("SELECT username FROM users WHERE username = ?", (new_username,))
            if existing_user:
                messagebox.showerror("Error", "Username already exists. Please choose a different username.")
                return
        
        try:
            # Generate new salt and hash for the new password
            import secrets
            import hashlib
            salt = secrets.token_hex(16)
            pwd_hash = hashlib.sha256((salt + new_password).encode("utf-8")).hexdigest()
            
            # Update credentials in database with secure hash
            self.db.execute("UPDATE users SET username = ?, salt = ?, password_hash = ? WHERE username = ?", 
                          (new_username, salt, pwd_hash, self.current_user))
            
            # Update current user reference
            self.current_user = new_username
            
            # Update window title
            self.title(f" Created By Santosh Kumar Jolhe contact no 9399876001 *Colony Maintenance* - Logged in as {self.current_user}")
            
            # Clear form
            self.clear_account_form()
            
            messagebox.showinfo("Success", "Login credentials updated successfully!\n\nNote: You will need to use the new credentials for your next login.")
            
        except Exception as e:
            messagebox.showerror("Database Error", f"Failed to update credentials: {str(e)}")
    
    def clear_account_form(self):
        self.current_password_var.set("")
        self.new_username_var.set(self.current_user)
        self.new_password_var.set("")
        self.confirm_password_var.set("")
    
    def view_license_details(self):
        """Show detailed license information"""
        license_manager = LicenseManager()
        license_info = license_manager.get_license_info()
        machine_id = license_manager.get_machine_id()
        
        # Create license details window
        details_window = tk.Toplevel(self)
        details_window.title("License Details")
        details_window.geometry("500x400")
        details_window.resizable(False, False)
        
        # Center the window
        details_window.transient(self)
        details_window.grab_set()
        
        main_frame = ttk.Frame(details_window, padding=20)
        main_frame.pack(fill="both", expand=True)
        
        # Title
        ttk.Label(main_frame, text="Software License Information", 
                 font=("Segoe UI", 14, "bold")).pack(pady=(0, 20))
        
        # License details
        details_text = f"""
License Status: {license_info}
Machine ID: {machine_id}

Software: Colony Maintenance Manager
Version: 2024 Professional
Developed by: Santosh Kumar Jolhe
Contact: +91 9399876001
Email: santoshkumarjolhe@gmail.com

This software is protected by copyright law.
Unauthorized copying or distribution is prohibited.

For license renewal or support:
- Contact the developer
- Provide your Machine ID for license generation
- Purchase additional licenses for multiple systems
"""
        
        text_widget = tk.Text(main_frame, height=18, width=60, wrap="word", 
                             font=("Segoe UI", 9), relief="flat", 
                             background="#f8fafc", padx=10, pady=10)
        text_widget.pack(fill="both", expand=True)
        text_widget.insert("1.0", details_text)
        text_widget.config(state="disabled")
        
        # Close button
        ttk.Button(main_frame, text="Close", command=details_window.destroy, 
                  style="Accent.TButton").pack(pady=(10, 0))
    
    def copy_machine_id(self, machine_id):
        """Copy machine ID to clipboard"""
        self.clipboard_clear()
        self.clipboard_append(machine_id)
        messagebox.showinfo("Copied", "Machine ID copied to clipboard!\n\nSend this ID to the developer to get your license key.", parent=self)
    
    def open_license_generator(self):
        """Open integrated license generator for developer"""
        # Create license generator window
        generator_window = tk.Toplevel(self)
        generator_window.title("Customer License Generator - Developer Mode")
        generator_window.geometry("600x650")
        generator_window.resizable(False, False)
        
        # Center the window
        generator_window.transient(self)
        generator_window.grab_set()
        
        main_frame = ttk.Frame(generator_window, padding=20)
        main_frame.pack(fill="both", expand=True)
        
        # Header
        ttk.Label(main_frame, text="🔑 Customer License Generator", 
                 font=("Segoe UI", 14, "bold")).pack(pady=(0, 20))
        
        # Customer info
        customer_frame = ttk.LabelFrame(main_frame, text="Customer Information", padding=10)
        customer_frame.pack(fill="x", pady=(0, 20))
        
        # Machine ID
        ttk.Label(customer_frame, text="Customer Machine ID:").pack(anchor="w")
        machine_id_var = tk.StringVar()
        ttk.Entry(customer_frame, textvariable=machine_id_var, width=40).pack(fill="x", pady=(5, 10))
        
        # Customer name
        ttk.Label(customer_frame, text="Customer Name:").pack(anchor="w")
        customer_name_var = tk.StringVar()
        ttk.Entry(customer_frame, textvariable=customer_name_var, width=40).pack(fill="x", pady=(5, 10))
        
        # Duration
        ttk.Label(customer_frame, text="License Duration:").pack(anchor="w")
        duration_frame = ttk.Frame(customer_frame)
        duration_frame.pack(fill="x", pady=(5, 10))
        
        duration_var = tk.StringVar(value="365")
        ttk.Radiobutton(duration_frame, text="30 Days", variable=duration_var, value="30").pack(anchor="w")
        ttk.Radiobutton(duration_frame, text="90 Days", variable=duration_var, value="90").pack(anchor="w")
        ttk.Radiobutton(duration_frame, text="1 Year (365 days)", variable=duration_var, value="365").pack(anchor="w")
        ttk.Radiobutton(duration_frame, text="2 Years (730 days)", variable=duration_var, value="730").pack(anchor="w")
        
        # Custom duration
        custom_frame = ttk.Frame(duration_frame)
        custom_frame.pack(fill="x", pady=(5, 0))
        
        custom_var = tk.BooleanVar()
        ttk.Checkbutton(custom_frame, text="Custom:", variable=custom_var).pack(side="left")
        custom_days_var = tk.StringVar(value="90")
        custom_entry = ttk.Entry(custom_frame, textvariable=custom_days_var, width=10)
        custom_entry.pack(side="left", padx=(10, 5))
        ttk.Label(custom_frame, text="days").pack(side="left")
        
        # License generation
        result_frame = ttk.LabelFrame(main_frame, text="Generated License", padding=15)
        result_frame.pack(fill="x", pady=(0, 15))
        
        ttk.Label(result_frame, text="License Key:").pack(anchor="w")
        license_key_var = tk.StringVar()
        license_entry = ttk.Entry(result_frame, textvariable=license_key_var, state="readonly", width=40)
        license_entry.pack(fill="x", pady=(5, 10))
        
        def generate_customer_license():
            customer = customer_name_var.get().strip()
            customer_machine_id = machine_id_var.get().strip().upper()
            
            if not customer or not customer_machine_id:
                messagebox.showerror("Error", "Please enter customer name and machine ID")
                return
            
            # Get duration
            if custom_var.get():
                try:
                    days = int(custom_days_var.get())
                except:
                    messagebox.showerror("Error", "Invalid custom duration")
                    return
            else:
                days = int(duration_var.get())
            
            # Generate license using advanced system if available
            try:
                enhanced_manager = EnhancedLicenseManager()
                license_key, license_data = enhanced_manager.generate_customer_license(
                    customer, "", "", "", customer_machine_id, days, 
                    f"Generated by {self.current_user} on {datetime.now().strftime('%Y-%m-%d')}"
                )
                
                if license_key:
                    license_key_var.set(license_key)
                    expiry_date = (datetime.now() + timedelta(days=days)).strftime('%d-%m-%Y')
                    messagebox.showinfo("Success", 
                                      f"🎉 Advanced License Generated!\n\n"
                                      f"Customer: {customer}\n"
                                      f"Duration: {days} days\n"
                                      f"Expires: {expiry_date}\n\n"
                                      f"License Key: {license_key}\n\n"
                                      f"📋 Customer added to tracking database\n"
                                      f"📈 Usage will be monitored in analytics")
                else:
                    raise Exception("Advanced license generation failed")
                    
            except Exception as e:
                # Fallback to basic license generation
                import secrets
                groups = []
                for _ in range(4):
                    group = ''.join(secrets.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') for _ in range(4))
                    groups.append(group)
                license_key = '-'.join(groups)
                
                license_key_var.set(license_key)
                expiry_date = (datetime.now() + timedelta(days=days)).strftime('%d-%m-%Y')
                messagebox.showinfo("Success", 
                                  f"License generated successfully!\n\n"
                                  f"Customer: {customer}\n"
                                  f"Duration: {days} days\n"
                                  f"Expires: {expiry_date}\n\n"
                                  f"License Key: {license_key}")
        
        # Buttons
        btn_frame = ttk.Frame(main_frame)
        btn_frame.pack(fill="x", pady=(20, 0))
        
        tk.Button(btn_frame, text="🔑 Generate License", 
                 command=generate_customer_license,
                 font=("Segoe UI", 10, "bold"), bg="#16a34a", fg="white",
                 relief="flat", padx=20, pady=8, cursor="hand2").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="📋 Copy License Key", 
                 command=lambda: self._copy_to_clipboard_simple(license_key_var.get(), generator_window),
                 font=("Segoe UI", 10), bg="#3b82f6", fg="white",
                 relief="flat", padx=20, pady=8, cursor="hand2").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="❌ Close", 
                 command=generator_window.destroy,
                 font=("Segoe UI", 10), bg="#6b7280", fg="white",
                 relief="flat", padx=20, pady=8, cursor="hand2").pack(side="right")
    
    def open_system_analytics(self):
        """Open comprehensive system analytics dashboard"""
        analytics_window = tk.Toplevel(self)
        analytics_window.title("📊 System Analytics Dashboard - Developer Mode")
        analytics_window.geometry("800x600")
        analytics_window.resizable(True, True)
        
        analytics_window.transient(self)
        analytics_window.grab_set()
        
        main_frame = ttk.Frame(analytics_window, padding=20)
        main_frame.pack(fill="both", expand=True)
        
        # Header
        ttk.Label(main_frame, text="📊 System Analytics Dashboard", 
                 font=("Segoe UI", 16, "bold")).pack(pady=(0, 20))
        
        # Create notebook for different analytics sections
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill="both", expand=True)
        
        # Overview tab
        overview_frame = ttk.Frame(notebook, padding=20)
        notebook.add(overview_frame, text="📈 Overview")
        
        try:
            enhanced_manager = EnhancedLicenseManager()
            analytics = enhanced_manager.get_system_analytics()
            
            # Create comprehensive analytics display
            analytics_text = (
                f"📊 SYSTEM STATISTICS\n\n"
                f"👥 Total Customers: {analytics['total_customers']}\n"
                f"✅ Active Licenses: {analytics['active_licenses']}\n"
                f"❌ Expired Licenses: {analytics['expired_licenses']}\n"
                f"📈 Recent Usage (30 days): {analytics['recent_usage']}\n\n"
                f"🎯 BUSINESS INSIGHTS\n\n"
                f"• Total Systems Running Your Software: {analytics['total_customers']}\n"
                f"• License Compliance Rate: {(analytics['active_licenses']/max(analytics['total_customers'],1)*100):.1f}%\n"
                f"• User Engagement: {analytics['recent_usage']} active users\n"
                f"• Revenue Protection: {analytics['total_customers']} licensed installations\n\n"
                f"🛡️ SECURITY STATUS\n\n"
                f"• All licenses machine-bound for security\n"
                f"• Remote license control available\n"
                f"• Comprehensive usage tracking active\n"
                f"• Anti-piracy measures operational\n\n"
                f"💡 RECOMMENDATIONS\n\n"
                f"• {'Excellent adoption rate!' if analytics['total_customers'] > 10 else 'Growing customer base'}\n"
                f"• {'Monitor expired licenses for renewals' if analytics['expired_licenses'] > 0 else 'All licenses current'}\n"
                f"• {'Strong user engagement' if analytics['recent_usage'] > analytics['total_customers']*0.5 else 'Consider user engagement campaigns'}\n"
            )
        except Exception as e:
            analytics_text = (
                "📊 BASIC ANALYTICS\n\n"
                "⚠️ Advanced analytics not available\n\n"
                "To enable comprehensive tracking:\n"
                "• Ensure customer_database.py is configured\n"
                "• Customer tracking will provide detailed insights\n"
                "• License usage patterns and trends\n\n"
                "🔧 SYSTEM STATUS\n\n"
                "• Developer mode: Active\n"
                "• License system: Operational\n"
                "• Security: Multi-factor authentication enabled\n\n"
                f"Error: {str(e)}"
            )
        
        text_widget = tk.Text(overview_frame, height=20, wrap="word", 
                             font=("Segoe UI", 10), relief="flat", background="#f8fafc")
        text_widget.pack(fill="both", expand=True)
        text_widget.insert("1.0", analytics_text)
        text_widget.config(state="disabled")
        
        # Customer list tab
        customers_frame = ttk.Frame(notebook, padding=20)
        notebook.add(customers_frame, text="👥 Customers")
        
        ttk.Label(customers_frame, text="Customer Database", 
                 font=("Segoe UI", 14, "bold")).pack(pady=(0, 10))
        
        customer_text = (
            "Customer tracking features:\n\n"
            "• Automatic customer registration on license generation\n"
            "• Machine ID tracking for each customer\n"
            "• License history and usage patterns\n"
            "• Contact information management\n\n"
            "Access customer database through customer_database.py\n"
            "or use the integrated license generator to add customers."
        )
        
        customer_widget = tk.Text(customers_frame, height=15, wrap="word", 
                                 font=("Segoe UI", 10), relief="flat", background="#f8fafc")
        customer_widget.pack(fill="both", expand=True)
        customer_widget.insert("1.0", customer_text)
        customer_widget.config(state="disabled")
        
        # Control buttons
        control_frame = ttk.Frame(analytics_window)
        control_frame.pack(fill="x", padx=20, pady=10)
        
        tk.Button(control_frame, text="🔄 Refresh Analytics", 
                 command=lambda: self.refresh_analytics_display(text_widget),
                 font=("Segoe UI", 10), bg="#6366f1", fg="white",
                 relief="flat", padx=20, pady=6, cursor="hand2").pack(side="left", padx=(0, 10))
        
        tk.Button(control_frame, text="💾 Export Report", 
                 command=self.export_analytics_report,
                 font=("Segoe UI", 10), bg="#059669", fg="white",
                 relief="flat", padx=20, pady=6, cursor="hand2").pack(side="left", padx=(0, 10))
        
        tk.Button(control_frame, text="❌ Close", 
                 command=analytics_window.destroy,
                 font=("Segoe UI", 10), bg="#6b7280", fg="white",
                 relief="flat", padx=20, pady=6, cursor="hand2").pack(side="right")
    
    def open_license_control(self):
        """Open remote license control panel"""
        control_window = tk.Toplevel(self)
        control_window.title("🛡️ Remote License Control - Developer Mode")
        control_window.geometry("600x500")
        control_window.resizable(False, False)
        
        control_window.transient(self)
        control_window.grab_set()
        
        main_frame = ttk.Frame(control_window, padding=20)
        main_frame.pack(fill="both", expand=True)
        
        # Header
        ttk.Label(main_frame, text="🛡️ Remote License Control Panel", 
                 font=("Segoe UI", 14, "bold")).pack(pady=(0, 20))
        
        # Warning message
        warning_frame = ttk.LabelFrame(main_frame, text="⚠️ Security Notice", padding=10)
        warning_frame.pack(fill="x", pady=(0, 20))
        
        warning_text = (
            "Remote license control allows you to:\n"
            "• Expire customer licenses instantly\n"
            "• Prevent software piracy\n"
            "• Control access to your software\n\n"
            "Use responsibly and only for legitimate purposes."
        )
        
        ttk.Label(warning_frame, text=warning_text, font=("Segoe UI", 9)).pack()
        
        # License control section
        control_section = ttk.LabelFrame(main_frame, text="License Management", padding=15)
        control_section.pack(fill="x", pady=(0, 20))
        
        # License key input
        ttk.Label(control_section, text="License Key to Control:").pack(anchor="w")
        license_control_var = tk.StringVar()
        ttk.Entry(control_section, textvariable=license_control_var, width=40).pack(fill="x", pady=(5, 10))
        
        # Action buttons
        action_frame = ttk.Frame(control_section)
        action_frame.pack(fill="x")
        
        def expire_license():
            license_key = license_control_var.get().strip()
            if not license_key:
                messagebox.showerror("Error", "Please enter a license key")
                return
            
            result = messagebox.askyesno("Confirm Action", 
                                       f"Are you sure you want to expire license:\n{license_key}\n\n"
                                       "This action cannot be undone and will immediately\n"
                                       "disable the customer's software access.")
            
            if result:
                try:
                    enhanced_manager = EnhancedLicenseManager()
                    success = enhanced_manager.expire_customer_license(license_key)
                    
                    if success:
                        messagebox.showinfo("Success", 
                                          f"✅ License expired successfully!\n\n"
                                          f"License Key: {license_key}\n"
                                          f"Status: Expired\n\n"
                                          "Customer will no longer be able to use the software.")
                        license_control_var.set("")  # Clear input
                    else:
                        messagebox.showerror("Error", "Failed to expire license. License key may not exist in database.")
                        
                except Exception as e:
                    messagebox.showerror("Error", f"License control failed: {str(e)}\n\nEnsure customer_database.py is properly configured.")
        
        def check_license_status():
            license_key = license_control_var.get().strip()
            if not license_key:
                messagebox.showerror("Error", "Please enter a license key")
                return
            
            try:
                enhanced_manager = EnhancedLicenseManager()
                license_info = enhanced_manager.customer_db.get_license_info(license_key) if enhanced_manager.customer_db else None
                
                if license_info:
                    messagebox.showinfo("License Information", 
                                      f"Customer: {license_info['customer_name']}\n"
                                      f"Email: {license_info['email'] or 'N/A'}\n"
                                      f"Company: {license_info['company'] or 'N/A'}\n"
                                      f"Issue Date: {license_info['issue_date']}\n"
                                      f"Expiry Date: {license_info['expiry_date']}\n"
                                      f"Duration: {license_info['duration_days']} days\n"
                                      f"Status: {license_info['status']}\n"
                                      f"Notes: {license_info['notes'] or 'None'}")
                else:
                    messagebox.showwarning("Not Found", "License key not found in database.")
                    
            except Exception as e:
                messagebox.showerror("Error", f"License lookup failed: {str(e)}")
        
        tk.Button(action_frame, text="🔍 Check Status", 
                 command=check_license_status,
                 font=("Segoe UI", 10), bg="#3b82f6", fg="white",
                 relief="flat", padx=20, pady=8, cursor="hand2").pack(side="left", padx=(0, 10))
        
        tk.Button(action_frame, text="❌ Expire License", 
                 command=expire_license,
                 font=("Segoe UI", 10, "bold"), bg="#dc2626", fg="white",
                 relief="flat", padx=20, pady=8, cursor="hand2").pack(side="left")
        
        # Instructions
        instructions_frame = ttk.LabelFrame(main_frame, text="Instructions", padding=10)
        instructions_frame.pack(fill="both", expand=True)
        
        instructions_text = (
            "How to use Remote License Control:\n\n"
            "1. Get license key from customer or your records\n"
            "2. Enter the license key in the field above\n"
            "3. Click 'Check Status' to view license information\n"
            "4. Click 'Expire License' to disable customer access\n\n"
            "Use cases for license expiry:\n"
            "• Customer requested refund\n"
            "• Suspected software piracy\n"
            "• License violation or misuse\n"
            "• Payment disputes\n\n"
            "Note: Expired licenses cannot be reactivated.\n"
            "Customer will need a new license key."
        )
        
        instruction_widget = tk.Text(instructions_frame, height=12, wrap="word", 
                                    font=("Segoe UI", 9), relief="flat", background="#f8fafc")
        instruction_widget.pack(fill="both", expand=True)
        instruction_widget.insert("1.0", instructions_text)
        instruction_widget.config(state="disabled")
        
        # Close button
        tk.Button(main_frame, text="❌ Close", 
                 command=control_window.destroy,
                 font=("Segoe UI", 10), bg="#6b7280", fg="white",
                 relief="flat", padx=20, pady=8, cursor="hand2").pack(pady=(20, 0))
        """Open integrated license generator for developer"""
        # Create license generator window
        generator_window = tk.Toplevel(self)
        generator_window.title("License Generator - Developer Mode")
        generator_window.geometry("600x650")  # Increased height to show buttons
        generator_window.resizable(False, False)
        
        # Center the window
        generator_window.transient(self)
        generator_window.grab_set()
        
        main_frame = ttk.Frame(generator_window, padding=20)
        main_frame.pack(fill="both", expand=True)
        
        # Header
        ttk.Label(main_frame, text="Customer License Generator", 
                 font=("Segoe UI", 16, "bold")).pack(pady=(0, 20))
        
        # Customer info
        info_frame = ttk.LabelFrame(main_frame, text="Customer Information", padding=15)
        info_frame.pack(fill="x", pady=(0, 15))
        
        # Customer name
        ttk.Label(info_frame, text="Customer Name:").pack(anchor="w")
        customer_name_var = tk.StringVar()
        ttk.Entry(info_frame, textvariable=customer_name_var, width=40).pack(fill="x", pady=(5, 10))
        
        # Machine ID
        ttk.Label(info_frame, text="Customer's Machine ID:").pack(anchor="w")
        machine_id_var = tk.StringVar()
        ttk.Entry(info_frame, textvariable=machine_id_var, width=40).pack(fill="x", pady=(5, 10))
        
        # Duration options
        ttk.Label(info_frame, text="License Duration:").pack(anchor="w")
        duration_frame = ttk.Frame(info_frame)
        duration_frame.pack(fill="x", pady=(5, 10))
        
        duration_var = tk.StringVar(value="365")
        ttk.Radiobutton(duration_frame, text="1 Year (365 days)", variable=duration_var, value="365").pack(anchor="w")
        ttk.Radiobutton(duration_frame, text="2 Years (730 days)", variable=duration_var, value="730").pack(anchor="w")
        
        # Custom duration
        custom_frame = ttk.Frame(duration_frame)
        custom_frame.pack(fill="x", pady=(5, 0))
        
        custom_var = tk.BooleanVar()
        ttk.Checkbutton(custom_frame, text="Custom:", variable=custom_var).pack(side="left")
        custom_days_var = tk.StringVar(value="90")
        custom_entry = ttk.Entry(custom_frame, textvariable=custom_days_var, width=10)
        custom_entry.pack(side="left", padx=(10, 5))
        ttk.Label(custom_frame, text="days").pack(side="left")
        
        # License generation
        result_frame = ttk.LabelFrame(main_frame, text="Generated License", padding=15)
        result_frame.pack(fill="x", pady=(0, 15))
        
        ttk.Label(result_frame, text="License Key:").pack(anchor="w")
        license_key_var = tk.StringVar()
        license_entry = ttk.Entry(result_frame, textvariable=license_key_var, state="readonly", width=40)
        license_entry.pack(fill="x", pady=(5, 10))
        
        def generate_customer_license():
            customer = customer_name_var.get().strip()
            customer_machine_id = machine_id_var.get().strip().upper()
            
            if not customer or not customer_machine_id:
                messagebox.showerror("Error", "Please enter customer name and machine ID")
                return
            
            # Get duration
            if custom_var.get():
                try:
                    days = int(custom_days_var.get())
                except:
                    messagebox.showerror("Error", "Invalid custom duration")
                    return
            else:
                days = int(duration_var.get())
            
            # Generate license using MD5 as per memory preference
            import hashlib
            license_string = f"{customer}{customer_machine_id}{days}COLONY_SOFTWARE_2024"
            license_hash = hashlib.md5(license_string.encode()).hexdigest()[:16].upper()
            license_key = f"{license_hash[:4]}-{license_hash[4:8]}-{license_hash[8:12]}-{license_hash[12:16]}"
            
            license_key_var.set(license_key)
            
            expiry_date = (datetime.now() + timedelta(days=days)).strftime('%d-%m-%Y')
            messagebox.showinfo("Success", 
                              f"License generated successfully!\n\n"
                              f"Customer: {customer}\n"
                              f"Duration: {days} days\n"
                              f"Expires: {expiry_date}\n\n"
                              f"License Key: {license_key}")
        
        # Use standard tkinter buttons to ensure text visibility
        btn_frame = ttk.Frame(main_frame)
        btn_frame.pack(fill="x", pady=(20, 0))
        
        # Create standard tkinter buttons which are more reliable for text display
        generate_btn = tk.Button(btn_frame, text="Generate License", 
                                command=generate_customer_license,
                                font=("Segoe UI", 9),
                                relief="raised",
                                bd=1,
                                padx=10, pady=6)
        generate_btn.pack(side="left", padx=(0, 10))
        
        copy_btn = tk.Button(btn_frame, text="Copy License Key", 
                            command=lambda: self._copy_to_clipboard_simple(license_key_var.get(), generator_window),
                            font=("Segoe UI", 9),
                            relief="raised",
                            bd=1,
                            padx=10, pady=6)
        copy_btn.pack(side="left", padx=(0, 10))
        
        close_btn = tk.Button(btn_frame, text="Close", 
                             command=generator_window.destroy,
                             font=("Segoe UI", 9),
                             relief="raised",
                             bd=1,
                             padx=10, pady=6)
        close_btn.pack(side="right")
    
    def _copy_to_clipboard_simple(self, text, parent_window):
        """Copy text to clipboard with simple notification"""
        if not text:
            messagebox.showwarning("Warning", "No license key to copy", parent=parent_window)
            return
        self.clipboard_clear()
        self.clipboard_append(text)
        messagebox.showinfo("Copied", "License key copied to clipboard!", parent=parent_window)
    
    def refresh_system_stats(self):
        """Refresh system statistics in Account Settings"""
        messagebox.showinfo("Refreshed", "System statistics have been refreshed!\n\nThe latest data is now displayed in Account Settings.")
        # Rebuild account tab to refresh statistics
        for widget in self.account_tab.winfo_children():
            widget.destroy()
        self._build_account_tab()
    
    def export_analytics_report(self):
        """Export analytics report to file"""
        try:
            import os
            from datetime import datetime
            
            # Create reports directory if it doesn't exist
            reports_dir = "reports"
            os.makedirs(reports_dir, exist_ok=True)
            
            # Generate report filename
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_file = os.path.join(reports_dir, f"analytics_report_{timestamp}.txt")
            
            # Basic report content
            report_content = (
                f"System Analytics Report\n"
                f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"="*50 + "\n\n"
                f"SYSTEM STATUS\n"
                f"-" * 20 + "\n"
                f"License System: Operational\n"
                f"Application: Colony Maintenance Manager\n"
                f"Version: 2024\n"
            )
            
            # Write report to file
            with open(report_file, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            messagebox.showinfo("Export Successful", f"Report exported to {report_file}")
                              
        except Exception as e:
            messagebox.showerror("Export Failed", f"Failed to export report: {str(e)}")

    def export_events_report(self):
        """Export events list to CSV (ID, Title, Date, Budget, Status)"""
        try:
            import os, csv
            from datetime import datetime
            # Ensure reports directory exists
            reports_dir = "reports"
            os.makedirs(reports_dir, exist_ok=True)
            # Filename with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            csv_file = os.path.join(reports_dir, f"events_report_{timestamp}.csv")
            # Fetch events data
            events = self.db.fetchall(
                """SELECT id, title, event_date, total_budget, status FROM events ORDER BY event_date"""
            )
            if not events:
                messagebox.showinfo("Export", "No events available to export")
                return
            # Write CSV
            with open(csv_file, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow(["ID", "Title", "Event Date", "Budget", "Status"])
                for ev in events:
                    writer.writerow([
                        ev["id"], ev["title"], ev["event_date"], ev["total_budget"], ev["status"]
                    ])
            messagebox.showinfo("Export Successful", f"Events report saved to {csv_file}")
        except Exception as e:
            messagebox.showerror("Export Failed", f"Failed to export events report:\n{str(e)}")
        try:
            import os
            from datetime import datetime

            
            # Create reports directory if it doesn't exist
            reports_dir = "reports"
            os.makedirs(reports_dir, exist_ok=True)
            
            # Generate report filename
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_file = os.path.join(reports_dir, f"system_analytics_{timestamp}.txt")
            
            # Get analytics data
            try:
                enhanced_manager = EnhancedLicenseManager()
                analytics = enhanced_manager.get_system_analytics()
                
                report_content = (
                    f"System Analytics Report\n"
                    f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                    f"="*50 + "\n\n"
                    f"SYSTEM OVERVIEW\n"
                    f"-" * 20 + "\n"
                    f"Total Customers: {analytics['total_customers']}\n"
                    f"Active Licenses: {analytics['active_licenses']}\n"
                    f"Expired Licenses: {analytics['expired_licenses']}\n"
                    f"Recent Usage (30 days): {analytics['recent_usage']}\n\n"
                    f"BUSINESS METRICS\n"
                    f"-" * 20 + "\n"
                    f"License Compliance Rate: {(analytics['active_licenses']/max(analytics['total_customers'],1)*100):.1f}%\n"
                    f"Customer Engagement: {(analytics['recent_usage']/max(analytics['total_customers'],1)*100):.1f}%\n\n"
                    f"SECURITY STATUS\n"
                    f"-" * 20 + "\n"
                    f"- All licenses machine-bound\n"
                    f"- Remote license control active\n"
                    f"- Usage tracking operational\n"
                    f"- Anti-piracy measures enabled\n\n"
                    f"SOFTWARE INFORMATION\n"
                    f"-" * 20 + "\n"
                    f"Application: Colony Maintenance Manager\n"
                    f"Version: 2024 Professional\n"
                    f"Developer: Santosh Kumar Jolhe\n"
                    f"Contact: +91 9399876001\n"
                    f"Email: santoshkumarjolhe@gmail.com\n"
                )
            except Exception as e:
                report_content = (
                    f"System Analytics Report\n"
                    f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                    f"="*50 + "\n\n"
                    f"BASIC SYSTEM STATUS\n"
                    f"-" * 20 + "\n"
                    f"License System: Operational\n"
                    f"Developer Mode: Active\n"
                    f"Security: Multi-factor authentication enabled\n\n"
                    f"Note: Advanced analytics requires customer_database.py\n"
                    f"Error: {str(e)}\n"
                )
            
            # Write report to file
            with open(report_file, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            messagebox.showinfo("Export Successful", 
                              f"Analytics report exported successfully!\n\n"
                              f"File: {report_file}\n\n"
                              f"The report contains comprehensive system statistics\n"
                              f"and business insights for your software.")
                              
        except Exception as e:
            messagebox.showerror("Export Failed", f"Failed to export analytics report:\n{str(e)}")
    
    def run_security_check(self):
        """Run comprehensive security check"""
        security_results = []
        
        # Check developer mode security
        license_manager = LicenseManager()
        if license_manager.developer_mode:
            security_results.append("✅ Developer mode: Properly secured with multi-factor authentication")
        else:
            security_results.append("✅ Customer mode: License validation active")
        
        # Check license system
        try:
            is_valid, message = license_manager.check_license()
            security_results.append(f"✅ License system: {message}")
        except Exception as e:
            security_results.append(f"⚠️ License system: Error - {str(e)}")
        
        # Check customer database
        try:
            enhanced_manager = EnhancedLicenseManager()
            analytics = enhanced_manager.get_system_analytics()
            security_results.append(f"✅ Customer tracking: {analytics['total_customers']} customers monitored")
        except Exception as e:
            security_results.append("⚠️ Customer tracking: Limited (basic mode)")
        
        # Check file integrity
        import os
        critical_files = [
            ("colony soft.py", "Main application"),
            ("customer_database.py", "Customer tracking"),
            ("developer.key", "Developer authentication")
        ]
        
        for filename, description in critical_files:
            if os.path.exists(filename):
                security_results.append(f"✅ {description}: File present")
            else:
                security_results.append(f"⚠️ {description}: File missing")
        
        # Display results
        result_text = "\n".join(security_results)
        messagebox.showinfo("Security Check Results", 
                           f"System Security Analysis\n\n{result_text}\n\n"
                           f"Overall Status: {'Secure' if '❌' not in result_text else 'Review Required'}")
    
    def refresh_analytics_display(self, text_widget):
        """Refresh analytics display in analytics window"""
        try:
            enhanced_manager = EnhancedLicenseManager()
            analytics = enhanced_manager.get_system_analytics()
            
            updated_text = (
                f"📊 SYSTEM STATISTICS (UPDATED)\n\n"
                f"👥 Total Customers: {analytics['total_customers']}\n"
                f"✅ Active Licenses: {analytics['active_licenses']}\n"
                f"❌ Expired Licenses: {analytics['expired_licenses']}\n"
                f"📈 Recent Usage (30 days): {analytics['recent_usage']}\n\n"
                f"🎯 BUSINESS INSIGHTS\n\n"
                f"• Total Systems Running Your Software: {analytics['total_customers']}\n"
                f"• License Compliance Rate: {(analytics['active_licenses']/max(analytics['total_customers'],1)*100):.1f}%\n"
                f"• User Engagement: {analytics['recent_usage']} active users\n"
                f"• Revenue Protection: {analytics['total_customers']} licensed installations\n\n"
                f"Last Updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            )
            
            text_widget.config(state="normal")
            text_widget.delete(1.0, tk.END)
            text_widget.insert(1.0, updated_text)
            text_widget.config(state="disabled")
            
        except Exception as e:
            messagebox.showerror("Refresh Failed", f"Failed to refresh analytics: {str(e)}")

    # --- Member CRUD (same logic as previous implementation) ---
    def add_member_window(self):
        w = tk.Toplevel(self)
        w.title("Add Member")
        w.geometry("420x340")
        # Configure a small button style for the "Today" shortcut
        style = ttk.Style(w)
        style.configure("Small.TButton", padding=(2, 1), font=("Segoe UI", 8))
        frm = ttk.Frame(w, padding=12)
        frm.pack(fill="both", expand=True)
        labels = [("Name", "name"), ("Phone", "phone"), ("Email", "email"), ("Flat No", "flat_no"), ("Monthly Rent", "monthly_rent"), ("Join Date", "join_date")]
        vars = {}
        r = 0
        for lbl, key in labels:
            ttk.Label(frm, text=lbl + ":").grid(row=r, column=0, sticky="w", pady=6)
            v = tk.StringVar()
            if key == "join_date":
                # Create entry with smaller width and a button to autofill today's date
                entry = ttk.Entry(frm, textvariable=v, width=26)
                entry.grid(row=r, column=1, pady=6, sticky="w")
                ttk.Button(frm, text="Today", style="Small.TButton", command=lambda var=v: var.set(date.today().strftime("%d-%m-%Y"))).grid(row=r, column=2, padx=2)
            else:
                ttk.Entry(frm, textvariable=v, width=36).grid(row=r, column=1, pady=6)
            vars[key] = v
            r += 1

        ttk.Label(frm, text="Member Type:").grid(row=r, column=0, sticky="w", pady=6)
        member_type_var = tk.StringVar(value="Flat Owner / Tenant")
        member_type_combo = ttk.Combobox(frm, textvariable=member_type_var, values=["Flat Owner", "Row House Owner", "Tenant"], width=34, state="readonly")
        member_type_combo.grid(row=r, column=1, pady=6)
        r += 1

        def save():
            name = vars["name"].get().strip()
            if not name:
                messagebox.showerror("Validation", "Name required", parent=w)
                return
            try:
                monthly = float(vars["monthly_rent"].get() or 0)
            except Exception:
                messagebox.showerror("Validation", "Monthly fee numeric", parent=w)
                return
            
            join_date_str = vars["join_date"].get().strip()
            if not join_date_str:
                join_date = date.today()
            else:
                try:
                    join_date = datetime.strptime(join_date_str, "%d-%m-%Y").date()
                except ValueError:
                    messagebox.showerror("Validation", "Invalid Join Date format. Use DD-MM-YYYY", parent=w)
                    return

            self.db.execute("INSERT INTO members (name, phone, email, flat_no, join_date, monthly_rent, member_type) VALUES (?, ?, ?, ?, ?, ?, ?)",
                            (name, vars["phone"].get().strip(), vars["email"].get().strip(), vars["flat_no"].get().strip(), join_date, monthly, member_type_var.get()))
            messagebox.showinfo("Saved", "Member added", parent=w)
            w.destroy()
            self.refresh_members()

        ttk.Button(frm, text="Save", command=save, style="Accent.TButton").grid(row=r, column=0, columnspan=2, sticky="ew", pady=8)

    def edit_member_window(self):
        sel = self.members_tree.selection()
        if not sel:
            messagebox.showwarning("Select", "Select member to edit")
            return
        member_id = self.members_tree.item(sel[0])["values"][1]
        member = self.db.fetchone("SELECT * FROM members WHERE id=?", (member_id,))
        if not member:
            messagebox.showerror("Not found", "Member not found")
            return
        w = tk.Toplevel(self)
        w.title("Edit Member")
        w.geometry("420x340")
        frm = ttk.Frame(w, padding=12)
        frm.pack(fill="both", expand=True)
        labels = [("Name", "name"), ("Phone", "phone"), ("Email", "email"), ("Flat No", "flat_no"), ("Monthly Rent", "monthly_rent")]
        vars = {}
        r = 0
        for lbl, key in labels:
            ttk.Label(frm, text=lbl + ":").grid(row=r, column=0, sticky="w", pady=6)
            v = tk.StringVar(value=str(member[key]) if member[key] is not None else "")
            ttk.Entry(frm, textvariable=v, width=36).grid(row=r, column=1, pady=6)
            vars[key] = v
            r += 1

        ttk.Label(frm, text="Member Type:").grid(row=r, column=0, sticky="w", pady=6)
        member_type_var = tk.StringVar(value=member["member_type"] if member["member_type"] is not None else "Flat Owner / Tenant")
        member_type_combo = ttk.Combobox(frm, textvariable=member_type_var, values=["Flat Owner", "Row House Owner", "Tenant"], width=34, state="readonly")
        member_type_combo.grid(row=r, column=1, pady=6)
        r += 1

        def save():
            name = vars["name"].get().strip()
            if not name:
                messagebox.showerror("Validation", "Name required", parent=w)
                return
            try:
                monthly = float(vars["monthly_rent"].get() or 0)
            except Exception:
                messagebox.showerror("Validation", "Monthly fee numeric", parent=w)
                return
            self.db.execute("UPDATE members SET name=?, phone=?, email=?, flat_no=?, monthly_rent=?, member_type=? WHERE id=?",
                            (name, vars["phone"].get().strip(), vars["email"].get().strip(), vars["flat_no"].get().strip(), monthly, member_type_var.get(), member_id))
            messagebox.showinfo("Updated", "Member updated", parent=w)
            w.destroy()
            self.refresh_members()

        ttk.Button(frm, text="Update", command=save, style="Accent.TButton").grid(row=r, column=0, columnspan=2, sticky="ew", pady=8)

    def delete_member(self):
        sel = self.members_tree.selection()
        if not sel:
            messagebox.showwarning("Select", "Select member to delete")
            return
        member_id = self.members_tree.item(sel[0])["values"][1]
        if messagebox.askyesno("Confirm", "Delete selected member and ALL their related data (payments, complaints, parking)?"):
            # Remove related data first (manual cascade)
            self.db.execute("DELETE FROM payments WHERE member_id=?", (member_id,))
            self.db.execute("DELETE FROM complaints WHERE member_id=?", (member_id,))
            self.db.execute("DELETE FROM parking WHERE member_id=?", (member_id,))
            # Finally remove the member
            self.db.execute("DELETE FROM members WHERE id=?", (member_id,))
            # Refresh all dependent views
            self.refresh_members()
            self.refresh_payments()
            self.refresh_complaints()
            messagebox.showinfo("Deleted", "Member and all related data deleted successfully")

    def export_members_csv(self):
        rows = self.db.fetchall("SELECT id, name, flat_no, phone, email, monthly_rent, join_date FROM members")
        if not rows:
            messagebox.showinfo("Export", "No members to export")
            return
        filename = os.path.join(EXPORT_DIR, f"members_{datetime.now().strftime('%d-%m-%Y_%H%M%S')}.csv")
        cols = ["id", "name", "flat_no", "phone", "email", "monthly_rent", "join_date"]
        export_rows_to_csv(rows, cols, filename)
        open_file_in_default_app(filename)

    def open_consolidated_report(self):
        sel = self.members_tree.selection()
        if not sel:
            messagebox.showwarning("Select", "Select member to generate report")
            return
        member_id = self.members_tree.item(sel[0])["values"][1]
        report_file = self.generate_member_report(member_id)
        if report_file:
            open_file_in_default_app(report_file)

    def generate_member_report(self, member_id):
        """Generate consolidated HTML report for a member and return file path"""
        member = self.db.fetchone("SELECT * FROM members WHERE id=?", (member_id,))
        if not member:
            messagebox.showerror("Error", "Member not found")
            return None

        # Fetch payments
        payments = self.db.fetchall(
            "SELECT amount, date, note, payment_mode, payment_type FROM payments WHERE member_id=? ORDER BY date ASC",
            (member_id,)
        )

        # Build HTML report
        html_parts = [
            "<html><head><meta charset='utf-8'><title>Member Report</title>",
            "<style>table{border-collapse:collapse;width:100%;}th,td{border:1px solid #ccc;padding:4px;}th{background:#f1f5f9;} button#printBtn{margin:10px 0;padding:6px 12px;font-size:14px;}</style>",
            "<script>function doPrint(){window.print();}</script></head><body>",
            "<button id='printBtn' onclick='doPrint()'>🖨️ Print</button>",
            "<h2>Consolidated Member Report</h2>",
            "<h3>Member Details</h3>",
            "<table>"
        ]
        detail_fields = [
            ("Name", member["name"]),
            ("Flat No", member["flat_no"]),
            ("Phone", member["phone"]),
            ("Email", member["email"]),
            ("Member Type", member["member_type"]),
            ("Monthly Rent", member["monthly_rent"]),
            ("Join Date", member["join_date"]),
        ]
        for label, value in detail_fields:
            html_parts.append(f"<tr><th>{label}</th><td>{value}</td></tr>")
            
        html_parts.append("</table>")

        # Compute financial summary
        monthly_rent = member["monthly_rent"] or 0
        total_paid = member["total_paid_amount"] or 0
        due_amount = max(monthly_rent - total_paid, 0)
        balance_amount = max(total_paid - monthly_rent, 0)

        # Append financial summary rows
        summary_rows = [
            ("Total Paid Amount", total_paid),
            ("Due Amount", due_amount),
            ("Balance Amount", balance_amount)
        ]
        for label, value in summary_rows:
            html_parts.append(f"<tr><th>{label}</th><td>{value}</td></tr>")
        html_parts.append("</table>")

        # Payments section
        html_parts.append("<h3>Payments</h3>")
        if payments:
            payment_total = sum(p['amount'] for p in payments)
            html_parts.append("<table><tr><th>S No</th><th>Amount</th><th>Date</th><th>Note</th><th>Mode</th><th>Type</th></tr>")
            for idx, p in enumerate(payments, 1):
                html_parts.append(
                    f"<tr><td>{idx}</td><td>{p['amount']}</td><td>{p['date']}</td><td>{p['note']}</td><td>{p['payment_mode']}</td><td>{p['payment_type']}</td></tr>"
                )
            html_parts.append(f"<tr><th>Total</th><td>{payment_total}</td><td colspan='4'></td></tr>")
            html_parts.append("</table>")
        else:
            html_parts.append("<p>No payment records.</p>")

        # Event Contributions section
        html_parts.append("<h3>Event Contributions</h3>")
        event_contribs = self.db.fetchall(
            """SELECT e.title as event_title, ec.amount, ec.contribution_date, ec.note
               FROM event_contributions ec
               LEFT JOIN events e ON e.id = ec.event_id
               WHERE ec.member_id=? ORDER BY ec.contribution_date ASC""",
            (member_id,)
        )
        if event_contribs:
            event_total = sum(r['amount'] for r in event_contribs)
            html_parts.append("<table><tr><th>S No</th><th>Event Title</th><th>Amount</th><th>Date</th><th>Note</th></tr>")
            for idx, r in enumerate(event_contribs, 1):
                html_parts.append(
                    f"<tr><td>{idx}</td><td>{r['event_title']}</td><td>{r['amount']}</td><td>{r['contribution_date']}</td><td>{r['note']}</td></tr>"
                )
            html_parts.append(f"<tr><th>Total</th><td></td><td>{event_total}</td><td colspan='2'></td></tr>")
            html_parts.append("</table>")
        else:
            html_parts.append("<p>No event contribution records.</p>")

        # Footer
        html_parts.append("<hr><p style='font-size:12px;text-align:center;'>Created by Santosh Kumar Jolhe | Contact: 9399876001 | Email: santoshjolhe1@gmail.com</p>")

        # Close HTML
        html_parts.append("</body></html>")
        html_content = "\n".join(html_parts)

        reports_dir = os.path.join(EXPORT_DIR, "member_reports")
        os.makedirs(reports_dir, exist_ok=True)
        filename = os.path.join(reports_dir, f"member_{member_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html")
        with open(filename, "w", encoding="utf-8") as fp:
            fp.write(html_content)
        return filename

    def refresh_members(self):
        for i in self.members_tree.get_children():
            self.members_tree.delete(i)

        name_query = self.search_name_var.get().strip()
        flat_no_query = self.search_flat_no_var.get().strip()

        sql_query = "SELECT id, name, flat_no, phone, email, monthly_rent, join_date, member_type, total_paid_amount, last_payment_date FROM members"
        params = []
        conditions = []

        if name_query:
            conditions.append("name LIKE ?")
            params.append(f'%{name_query}%')
        if flat_no_query:
            conditions.append("flat_no LIKE ?")
            params.append(f'%{flat_no_query}%')

        if conditions:
            sql_query += " WHERE " + " AND ".join(conditions)
        sql_query += " ORDER BY id ASC"

        # Fetch members
        rows = self.db.fetchall(sql_query, tuple(params))

        # Initialize totals
        rent_total = 0.0
        paid_total = 0.0
        balance_total = 0.0
        advance_total = 0.0
        for idx, r in enumerate(rows, start=1):
            if r["join_date"]:
                try:
                    formatted_join_date = datetime.strptime(str(r["join_date"]), "%Y-%m-%d").strftime("%d-%m-%Y")
                except Exception:
                    try:
                        formatted_join_date = datetime.strptime(str(r["join_date"]), "%d-%m-%Y").strftime("%d-%m-%Y")
                    except Exception:
                        formatted_join_date = str(r["join_date"])
            else:
                formatted_join_date = ""
            
            # Calculate payment status
            monthly_rent = r["monthly_rent"]
            # Calculate total paid Rent amount only (exclude other payment types)
            paid_rent_row = self.db.fetchone("SELECT SUM(amount) as total FROM payments WHERE member_id=? AND payment_type='Rent'", (r["id"],))
            total_paid_amount = paid_rent_row["total"] if paid_rent_row and paid_rent_row["total"] is not None else 0.0
            last_payment_date_str = r["last_payment_date"]
            payment_status = "N/A"

            if monthly_rent is not None and monthly_rent > 0:
                if last_payment_date_str:
                    try:
                        last_payment_date = datetime.strptime(last_payment_date_str, '%d-%m-%Y').date()
                        today = date.today()
                        # Assuming monthly payments, if last payment was more than a month ago, it's overdue.
                        if (today.year - last_payment_date.year) * 12 + (today.month - last_payment_date.month) > 1:
                            payment_status = "Overdue"
                        elif total_paid_amount >= monthly_rent:
                            payment_status = "Paid"
                        else:
                            payment_status = "Pending"
                    except Exception:
                        payment_status = "Pending"
                else:
                    payment_status = "Pending (No Payment Yet)"
            else:
                payment_status = "N/A (No Rent Set)"

            # Calculate balance amount (amount still due)
            # For consistency, use total_paid_amount which includes all payments
            if monthly_rent is not None and total_paid_amount is not None:
                balance_amount = max(monthly_rent - total_paid_amount, 0)
            else:
                balance_amount = "N/A"

            advance_amount = max(total_paid_amount - monthly_rent, 0) if monthly_rent else 0

            self.members_tree.insert("", tk.END, values=(idx, r["id"], r["name"], r["flat_no"], r["phone"], r["email"], r["monthly_rent"], formatted_join_date, r["member_type"], total_paid_amount, balance_amount, advance_amount, payment_status))

            # accumulate totals
            try:
                rent_total += float(monthly_rent or 0)
            except Exception:
                pass
            try:
                paid_total += float(total_paid_amount or 0)
            except Exception:
                pass
            try:
                balance_total += float(balance_amount or 0)
            except Exception:
                pass
            try:
                advance_total += float(advance_amount or 0)
            except Exception:
                pass

        member_rows = self.db.fetchall("SELECT id, name, flat_no FROM members ORDER BY id ASC")
        member_values = [f'{r["id"]} - {r["name"]} ({r["flat_no"]})' for r in member_rows]
        self.payment_member_cb['values'] = member_values
        self.member_id_map = {f'{r["id"]} - {r["name"]} ({r["flat_no"]})': r["id"] for r in member_rows}
        self.member_dropdown_for_parking = dict(self.member_id_map)

        # insert totals row in treeview
        # first remove any previous totals row
        for item in self.members_tree.get_children():
            if "totals" in self.members_tree.item(item, "tags"):
                self.members_tree.delete(item)
        self.members_tree.insert("", tk.END, values=("", "", "", "", "", "", f"{rent_total:.2f}", "", "", f"{paid_total:.2f}", f"{balance_total:.2f}", f"{advance_total:.2f}", ""), tags=("totals",))

        # update totals labels
        if hasattr(self, "total_rent_var"):
            self.total_rent_var.set(f"{rent_total:.2f}")
            self.total_paid_var.set(f"{paid_total:.2f}")
            self.total_balance_var.set(f"{balance_total:.2f}")
            self.total_advance_var.set(f"{advance_total:.2f}")

    # --- Payments logic ---
    def add_payment(self):
        sel = self.payment_member_cb.get()
        if not sel:
            messagebox.showwarning("Select", "Select a member")
            return
        member_id = self.member_id_map.get(sel)
        try:
            payment_type = self.payment_type_var.get()
            if payment_type == "Rent":
                entered_amount_str = self.payment_amount_var.get().strip()
                if entered_amount_str:
                    try:
                        amount = float(entered_amount_str)
                    except ValueError:
                        messagebox.showerror("Validation", "Enter numeric amount")
                        return
                else:
                    member_data = self.db.fetchone("SELECT monthly_rent FROM members WHERE id = ?", (member_id,))
                    if member_data and member_data["monthly_rent"] is not None:
                        try:
                            amount = float(member_data["monthly_rent"])
                        except ValueError:
                            messagebox.showerror("Validation", "Monthly rent is not a valid number.")
                            return
                    else:
                        messagebox.showwarning("Rent Payment", "Selected member does not have a monthly rent set.")
                        return
            else:
                amount = float(self.payment_amount_var.get())
            payment_mode = self.payment_mode_var.get()
        except ValueError:
            messagebox.showerror("Validation", "Enter numeric amount")
            return
        note = self.payment_note_var.get().strip()
        payment_date_str = self.payment_date_var.get()
        try:
            payment_date = datetime.strptime(payment_date_str, '%d-%m-%Y').date()
        except ValueError:
            messagebox.showerror("Validation", "Invalid date format. Please use DD-MM-YYYY.")
            return
        self.db.execute("INSERT INTO payments (member_id, amount, date, note, payment_mode, payment_type) VALUES (?, ?, ?, ?, ?, ?)",
                        (member_id, amount, payment_date.strftime('%d-%m-%Y'), note, payment_mode, payment_type))
        
        # Update last_payment_date and total_paid_amount in members table
        # For last_payment_date, only consider Rent payments
        rent_payments = self.db.fetchall("SELECT amount, date FROM payments WHERE member_id=? AND payment_type='Rent'", (member_id,))
        all_payments = self.db.fetchall("SELECT amount, date FROM payments WHERE member_id=?", (member_id,))
        
        # Calculate total of Rent payments only (exclude other payment types)
        new_total_paid_amount = sum(p["amount"] for p in rent_payments)
        
        latest_payment_date = None
        if rent_payments:
            # Parse dates robustly and pick latest
            parsed_dates = []
            for p in rent_payments:
                dstr = p["date"]
                pd = None
                for fmt in ("%d-%m-%Y", "%Y-%m-%d"):
                    try:
                        pd = datetime.strptime(str(dstr), fmt).date()
                        break
                    except Exception:
                        continue
                if pd:
                    parsed_dates.append(pd)
            if parsed_dates:
                latest_payment_date = max(parsed_dates).strftime('%d-%m-%Y')

        self.db.execute("UPDATE members SET last_payment_date=?, total_paid_amount=? WHERE id=?",
                        (latest_payment_date, new_total_paid_amount, member_id))
        self.db.conn.commit()
        self.refresh_all()
        # Clear form fields after successful addition
        self.payment_member_cb.set("")
        self.payment_amount_var.set("")
        self.payment_date_var.set("")
        self.payment_mode_var.set("")
        self.payment_type_var.set("")
        self.payment_note_var.set("")
        self.refresh_payments()
        self.refresh_all()

    def delete_payment(self):
        sel = self.payments_tree.selection()
        if not sel:
            messagebox.showwarning("Select", "Select payment to delete")
            return
        payment_id = self.payments_tree.item(sel[0])["values"][1]
        if messagebox.askyesno("Confirm", "Delete selected payment?"):
            self.db.execute("DELETE FROM payments WHERE id=?", (payment_id,))
            self.refresh_payments()
            self.refresh_all()

    def generate_payment_slip(self):
        """Generate, save and print payment slip for selected payment"""
        sel = self.payments_tree.selection()
        if not sel:
            messagebox.showwarning("Select", "Select payment to generate slip")
            return
        payment_id = self.payments_tree.item(sel[0])["values"][1]
        payment = self.db.fetchone("SELECT * FROM payments WHERE id=?", (payment_id,))
        if not payment:
            messagebox.showerror("Error", "Payment not found")
            return
        member = self.db.fetchone("SELECT * FROM members WHERE id=?", (payment["member_id"],))
        if not member:
            messagebox.showerror("Error", "Member not found")
            return

        # Construct HTML
        html_content = f"""
        <html><head><meta charset='utf-8'><title>Payment Slip</title>
        <style>
            body {{ font-family: 'Segoe UI', sans-serif; margin: 40px; }}
            h2 {{ text-align: center; }}
            table {{ width: 100%; border-collapse: collapse; margin-top: 20px; }}
            td, th {{ border: 1px solid #444; padding: 8px; }}
        </style></head><body>
        <h2>Payment Receipt</h2>
        <table>
            <tr><th>Receipt No</th><td>{payment_id}</td></tr>
            <tr><th>Date</th><td>{payment['date']}</td></tr>
            <tr><th>Member</th><td>{member['name']} ({member['flat_no']})</td></tr>
            <tr><th>Payment Type</th><td>{payment['payment_type']}</td></tr>
            <tr><th>Payment Mode</th><td>{payment['payment_mode']}</td></tr>
            <tr><th>Amount</th><td>{payment['amount']}</td></tr>
            <tr><th>Note</th><td>{payment['note']}</td></tr>
        </table>
        <p style='text-align:center; margin-top:40px;'>Thank you for your payment!</p>
        <script>window.onload = function() {{ window.print(); }};</script>
        </body></html>"""

        # Save file
        filename = f"receipt_{payment_id}_{datetime.now().strftime('%Y%m%d%H%M%S')}.html"
        file_path = os.path.join(RECEIPT_DIR, filename)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            # open browser
            webbrowser.open(f'file://{file_path}')
            try:
                os.startfile(file_path, 'print')
            except Exception:
                pass
            messagebox.showinfo("Receipt Generated", f"Receipt saved to:\n{file_path}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate receipt:\n{e}")

    def edit_payment_window(self):
        sel = self.payments_tree.selection()
        if not sel:
            messagebox.showwarning("Select", "Select payment to edit")
            return
        payment_id = self.payments_tree.item(sel[0])["values"][1]
        payment = self.db.fetchone("SELECT * FROM payments WHERE id=?", (payment_id,))
        if not payment:
            messagebox.showerror("Error", "Payment not found")
            return

        w = tk.Toplevel(self)
        w.title("Edit Payment")
        w.geometry("400x400")
        frm = ttk.Frame(w, padding=10)
        frm.pack(fill="both", expand=True)

        labels = [("Member ID", "member_id"), ("Amount", "amount"), ("Date", "date"), ("Note", "note"), ("Payment Mode", "payment_mode"), ("Payment Type", "payment_type")]
        vars = {}
        r = 0

        # Member ID (read-only for now)
        ttk.Label(frm, text="Member:").grid(row=r, column=0, sticky="w", pady=6)
        member_name = self.db.fetchone("SELECT name, flat_no FROM members WHERE id=?", (payment["member_id"],))
        member_display = f'{payment["member_id"]} - {member_name["name"]} ({member_name["flat_no"]})' if member_name else payment["member_id"]
        ttk.Label(frm, text=member_display).grid(row=r, column=1, sticky="w", pady=6)
        r += 1

        # Amount
        ttk.Label(frm, text="Amount:").grid(row=r, column=0, sticky="w", pady=6)
        amount_var = tk.StringVar(value=str(payment["amount"]))
        ttk.Entry(frm, textvariable=amount_var, width=30).grid(row=r, column=1, pady=6)
        vars["amount"] = amount_var
        r += 1

        # Payment Date
        ttk.Label(frm, text="Payment Date (DD-MM-YYYY):").grid(row=r, column=0, sticky="w", pady=6)
        payment_date_var = tk.StringVar(value=payment["date"])
        ttk.Entry(frm, textvariable=payment_date_var, width=30).grid(row=r, column=1, pady=6)
        vars["date"] = payment_date_var
        r += 1

        # Date (read-only for now, or use a date picker)
        ttk.Label(frm, text="Date:").grid(row=r, column=0, sticky="w", pady=6)
        ttk.Label(frm, text=payment["date"]).grid(row=r, column=1, sticky="w", pady=6)
        r += 1

        # Note
        ttk.Label(frm, text="Note:").grid(row=r, column=0, sticky="w", pady=6)
        note_var = tk.StringVar(value=payment["note"])
        ttk.Entry(frm, textvariable=note_var, width=30).grid(row=r, column=1, pady=6)
        vars["note"] = note_var
        r += 1

        # Payment Mode
        ttk.Label(frm, text="Payment Mode:").grid(row=r, column=0, sticky="w", pady=6)
        payment_mode_var = tk.StringVar(value=payment["payment_mode"])
        payment_mode_combo = ttk.Combobox(frm, textvariable=payment_mode_var, values=["Cash", "UPI", "Bank Transfer"], state="readonly", width=28)
        payment_mode_combo.grid(row=r, column=1, pady=6)
        vars["payment_mode"] = payment_mode_var
        r += 1

        # Payment Type
        ttk.Label(frm, text="Payment Type:").grid(row=r, column=0, sticky="w", pady=6)
        payment_type_var = tk.StringVar(value=payment["payment_type"])
        payment_type_combo = ttk.Combobox(frm, textvariable=payment_type_var, values=["Rent", "Maintenance charge", "Amenities", "Corpus Fund", "Other"], state="readonly", width=28)
        payment_type_combo.grid(row=r, column=1, pady=6)
        vars["payment_type"] = payment_type_var
        r += 1

        def save_payment_edit():
            try:
                new_amount = float(amount_var.get())
            except ValueError:
                messagebox.showerror("Validation", "Amount must be numeric", parent=w)
                return
            new_note = note_var.get().strip()
            new_payment_mode = payment_mode_var.get()
            new_payment_type = payment_type_var.get()

            new_payment_date_str = payment_date_var.get()
            try:
                new_payment_date = datetime.strptime(new_payment_date_str, '%d-%m-%Y').date()
            except ValueError:
                messagebox.showerror("Validation", "Invalid date format. Please use DD-MM-YYYY.", parent=w)
                return

            self.db.execute("UPDATE payments SET amount=?, note=?, payment_mode=?, payment_type=?, date=? WHERE id=?",
                            (new_amount, new_note, new_payment_mode, new_payment_type, new_payment_date.strftime('%d-%m-%Y'), payment_id))

            # Update member's last_payment_date and total_paid_amount
            # For last_payment_date, only consider Rent payments
            member_id = payment["member_id"]
            rent_payments = self.db.fetchall("SELECT amount, date FROM payments WHERE member_id=? AND payment_type='Rent'", (member_id,))
            all_payments = self.db.fetchall("SELECT amount, date FROM payments WHERE member_id=?", (member_id,))

            # Calculate total of Rent payments only
            new_total_paid_amount = sum(p["amount"] for p in rent_payments)

            latest_payment_date = None
            if rent_payments:
                parsed_dates = []
                for p in rent_payments:
                    dstr = p["date"]
                    pd = None
                    for fmt in ("%d-%m-%Y", "%Y-%m-%d"):
                        try:
                            pd = datetime.strptime(str(dstr), fmt).date()
                            break
                        except Exception:
                            continue
                    if pd:
                        parsed_dates.append(pd)
                if parsed_dates:
                    latest_payment_date = max(parsed_dates).strftime('%d-%m-%Y')

            self.db.execute("UPDATE members SET total_paid_amount=?, last_payment_date=? WHERE id=?",
                            (new_total_paid_amount, latest_payment_date, member_id))

            messagebox.showinfo("Updated", "Payment updated", parent=w)
            w.destroy()
            self.refresh_payments()
            self.refresh_all()

        ttk.Button(frm, text="Update", command=save_payment_edit, style="Accent.TButton").grid(row=r, column=0, columnspan=2, sticky="ew", pady=8)

    def _on_payment_type_selected(self, event):
        selected_type = self.payment_type_var.get()
        if selected_type == "Rent":
            # Only auto-fill if amount field is currently empty to avoid overwriting user input
            if not self.payment_amount_var.get().strip():
                sel_member = self.payment_member_cb.get()
                if sel_member:
                    member_id = self.member_id_map.get(sel_member)
                    if member_id:
                        member_data = self.db.fetchone("SELECT monthly_rent FROM members WHERE id = ?", (member_id,))
                        if member_data and member_data["monthly_rent"] is not None:
                            self.payment_amount_var.set(member_data["monthly_rent"])
                        else:
                            self.payment_amount_var.set("")
                    else:
                        self.payment_amount_var.set("")
                else:
                    self.payment_amount_var.set("")
        else:
            # Clear auto-filled value only if field has not been edited by user (i.e., matches member's rent)
            self.payment_amount_var.set("")

    def _on_payment_member_selected(self, event):
        selected_type = self.payment_type_var.get()
        if selected_type == "Rent":
            # Only auto-fill if amount field is currently empty to avoid overwriting user input
            if not self.payment_amount_var.get().strip():
                sel_member = self.payment_member_cb.get()
                if sel_member:
                    member_id = self.member_id_map.get(sel_member)
                    if member_id:
                        member_data = self.db.fetchone("SELECT monthly_rent FROM members WHERE id = ?", (member_id,))
                        if member_data and member_data["monthly_rent"] is not None:
                            self.payment_amount_var.set(member_data["monthly_rent"])
                        else:
                            self.payment_amount_var.set("")
                    else:
                        self.payment_amount_var.set("")
                else:
                    self.payment_amount_var.set("")

    def refresh_payments(self):
        """Refresh payments table showing all payments (filtering handled in Dashboard)"""
        # Clear existing rows
        for i in self.payments_tree.get_children():
            self.payments_tree.delete(i)
        
        sql_query = """
            SELECT p.id, m.flat_no, m.name as member, p.amount, p.date, p.note, p.payment_mode, p.payment_type, p.payment_status
            FROM payments p LEFT JOIN members m ON p.member_id = m.id
            ORDER BY p.id DESC
        """

        rows = self.db.fetchall(sql_query)
        for idx, r in enumerate(rows, start=1):
            self.payments_tree.insert("", tk.END, values=(
                idx, 
                r["id"], 
                r["flat_no"] or "N/A", 
                r["member"] or "N/A", 
                r["amount"], 
                r["date"], 
                r["note"], 
                r["payment_mode"], 
                r["payment_type"], 
                r["payment_status"] if r["payment_status"] is not None else "Paid"
            ))
        # ---- Insert totals row ----
        # Sum only payments that are marked as Paid (or have no explicit status)
        total_amount = sum(row["amount"] for row in rows if (row["payment_status"] is None or str(row["payment_status"]).strip().lower() == "paid"))
        # Remove existing totals row if present
        for item in self.payments_tree.get_children():
            if "totals" in self.payments_tree.item(item, "tags"):
                self.payments_tree.delete(item)
        self.payments_tree.insert("", tk.END, values=("", "", "", "", f"{total_amount:.2f}", "", "", "", "", ""), tags=("totals",))

    def register_complaint_window(self):
        """Enhanced register complaint window with priority and better validation"""
        w = tk.Toplevel(self)
        w.title("Register Complaint")
        w.geometry("500x450")
        w.resizable(False, False)
        w.grab_set()  # Make modal
        
        frm = ttk.Frame(w, padding=15)
        frm.pack(fill="both", expand=True)
        
        # Member selection
        ttk.Label(frm, text="Member:", font=("Segoe UI", 9, "bold")).grid(row=0, column=0, sticky="w", pady=(0, 5))
        member_cb = ttk.Combobox(frm, values=list(self.member_id_map.keys()), state="readonly", width=45)
        member_cb.grid(row=0, column=1, pady=(0, 10), sticky="ew")
        
        # Auto-focus on member selection
        member_cb.focus_set()
        
        # Title
        ttk.Label(frm, text="Title:", font=("Segoe UI", 9, "bold")).grid(row=1, column=0, sticky="w", pady=(0, 5))
        title_var = tk.StringVar()
        title_entry = ttk.Entry(frm, textvariable=title_var, width=45)
        title_entry.grid(row=1, column=1, pady=(0, 10), sticky="ew")
        
        # Priority
        ttk.Label(frm, text="Priority:", font=("Segoe UI", 9, "bold")).grid(row=2, column=0, sticky="w", pady=(0, 5))
        priority_var = tk.StringVar(value="Medium")
        priority_combo = ttk.Combobox(frm, textvariable=priority_var, 
                                     values=["High", "Medium", "Low"], 
                                     state="readonly", width=20)
        priority_combo.grid(row=2, column=1, pady=(0, 10), sticky="w")
        
        # Description
        ttk.Label(frm, text="Description:", font=("Segoe UI", 9, "bold")).grid(row=3, column=0, sticky="nw", pady=(0, 5))
        desc_text = tk.Text(frm, height=8, width=45, wrap=tk.WORD)
        desc_text.grid(row=3, column=1, pady=(0, 15), sticky="ew")
        
        frm.columnconfigure(1, weight=1)

        def save():
            member_sel = member_cb.get()
            if not member_sel:
                messagebox.showerror("Validation", "Please select a member", parent=w)
                member_cb.focus_set()
                return
            mid = self.member_id_map[member_sel]
            title = title_var.get().strip()
            desc = desc_text.get("1.0", tk.END).strip()
            priority = priority_var.get()
            
            if not title:
                messagebox.showerror("Validation", "Title is required", parent=w)
                title_entry.focus_set()
                return
            
            if len(title) < 5:
                messagebox.showerror("Validation", "Title must be at least 5 characters long", parent=w)
                title_entry.focus_set()
                return
                
            try:
                self.db.execute("""
                    INSERT INTO complaints (member_id, title, description, date, status, priority) 
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (mid, title, desc, date.today(), "Open", priority))
                
                w.destroy()
                self.refresh_complaints()
                messagebox.showinfo("Success", f"Complaint '{title}' registered successfully!\n\nPriority: {priority}\nStatus: Open")
            except Exception as e:
                messagebox.showerror("Database Error", f"Failed to register complaint:\n{str(e)}", parent=w)

        # Keyboard shortcuts
        def on_enter_key(event):
            if event.widget == desc_text:
                return  # Allow Enter in text area
            save()
        
        def on_escape_key(event):
            w.destroy()
        
        w.bind('<Return>', on_enter_key)
        w.bind('<Escape>', on_escape_key)
        
        # Buttons frame
        btn_frame = ttk.Frame(frm)
        btn_frame.grid(row=4, column=0, columnspan=2, pady=(10, 0), sticky="ew")
        
        tk.Button(btn_frame, text="Register Complaint", command=save,
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=20, pady=6,
                 bg="#16a34a", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Cancel", command=w.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=20, pady=6).pack(side="right")

    def refresh_complaints(self):
        """Enhanced refresh complaints with flat number and filtering"""
        for i in self.complaints_tree.get_children():
            self.complaints_tree.delete(i)
        
        # Base query with all fields including flat_no and priority
        base_query = """
            SELECT c.id, m.name as member, m.flat_no, c.title, c.date, c.status, 
                   COALESCE(c.priority, 'Medium') as priority
            FROM complaints c 
            LEFT JOIN members m ON c.member_id = m.id
        """
        
        # Build WHERE clause based on search criteria
        conditions = []
        params = []
        
        # Check if search variables exist and have values
        if hasattr(self, 'search_member_var') and self.search_member_var.get().strip():
            conditions.append("m.name LIKE ?")
            params.append(f"%{self.search_member_var.get().strip()}%")
        
        if hasattr(self, 'search_flat_var') and self.search_flat_var.get().strip():
            conditions.append("m.flat_no LIKE ?")
            params.append(f"%{self.search_flat_var.get().strip()}%")
        
        if hasattr(self, 'search_title_var') and self.search_title_var.get().strip():
            conditions.append("c.title LIKE ?")
            params.append(f"%{self.search_title_var.get().strip()}%")
        
        if hasattr(self, 'filter_status_var') and self.filter_status_var.get() != "All":
            conditions.append("c.status = ?")
            params.append(self.filter_status_var.get())
        
        if hasattr(self, 'filter_priority_var') and self.filter_priority_var.get() != "All":
            conditions.append("COALESCE(c.priority, 'Medium') = ?")
            params.append(self.filter_priority_var.get())
        
        # Build final query
        if conditions:
            query = base_query + " WHERE " + " AND ".join(conditions)
        else:
            query = base_query
        
        query += " ORDER BY c.date DESC"
        
        rows = self.db.fetchall(query, tuple(params))
        
        for r in rows:
            # Color code based on status and priority
            status_tag = ""
            if r["status"] == "Open":
                status_tag = "open_status"
            elif r["status"] == "In Progress":
                status_tag = "progress_status"
            elif r["status"] == "Closed":
                status_tag = "closed_status"
            
            # Override with high priority tag if needed
            if r["priority"] == "High":
                status_tag = "high_priority"
            
            self.complaints_tree.insert("", tk.END, values=(
                r["id"], 
                r["member"] or "N/A", 
                r["flat_no"] or "N/A",
                r["title"], 
                r["date"], 
                r["status"], 
                r["priority"]
            ), tags=(status_tag,))
        
        # Configure row colors based on status and priority
        self.complaints_tree.tag_configure("open_status", background="#fef2f2")  # Light red
        self.complaints_tree.tag_configure("progress_status", background="#fefce8")  # Light yellow
        self.complaints_tree.tag_configure("closed_status", background="#f0fdf4")  # Light green
        self.complaints_tree.tag_configure("high_priority", background="#fce7f3", foreground="#be185d")  # Pink for high priority
        
        # Update statistics
        self.update_complaint_statistics()
    
    def search_complaints(self):
        """Search complaints based on filter criteria"""
        self.refresh_complaints()
    
    def clear_complaint_search(self):
        """Clear all search filters"""
        if hasattr(self, 'search_member_var'):
            self.search_member_var.set("")
        if hasattr(self, 'search_flat_var'):
            self.search_flat_var.set("")
        if hasattr(self, 'search_title_var'):
            self.search_title_var.set("")
        if hasattr(self, 'filter_status_var'):
            self.filter_status_var.set("All")
        if hasattr(self, 'filter_priority_var'):
            self.filter_priority_var.set("All")
        self.refresh_complaints()
    
    def edit_complaint_window(self):
        """Enhanced edit complaint window with improved validation and UX"""
        selection = self.complaints_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select a complaint to edit")
            return
        
        complaint_id = self.complaints_tree.item(selection[0])["values"][0]
        complaint = self.db.fetchone("SELECT * FROM complaints WHERE id=?", (complaint_id,))
        
        if not complaint:
            messagebox.showerror("Error", "Complaint not found")
            return
        
        w = tk.Toplevel(self)
        w.title("Edit Complaint")
        w.geometry("500x520")
        w.resizable(False, False)
        w.grab_set()  # Make modal
        
        frm = ttk.Frame(w, padding=15)
        frm.pack(fill="both", expand=True)
        
        # Get member info for display
        member = self.db.fetchone("SELECT name, flat_no FROM members WHERE id=?", (complaint["member_id"],))
        member_display = f"{member['name']} (Flat {member['flat_no']})" if member else "Unknown Member"
        
        # Member info (read-only)
        ttk.Label(frm, text="Member:", font=("Segoe UI", 9, "bold")).grid(row=0, column=0, sticky="w", pady=(0, 5))
        ttk.Label(frm, text=member_display, font=("Segoe UI", 9)).grid(row=0, column=1, sticky="w", pady=(0, 10))
        
        # Title
        ttk.Label(frm, text="Title:", font=("Segoe UI", 9, "bold")).grid(row=1, column=0, sticky="w", pady=(0, 5))
        title_var = tk.StringVar(value=complaint["title"] or "")
        title_entry = ttk.Entry(frm, textvariable=title_var, width=50)
        title_entry.grid(row=1, column=1, pady=(0, 10), sticky="ew")
        title_entry.focus_set()  # Auto-focus
        
        # Priority
        ttk.Label(frm, text="Priority:", font=("Segoe UI", 9, "bold")).grid(row=2, column=0, sticky="w", pady=(0, 5))
        priority_var = tk.StringVar(value=complaint["priority"] if complaint["priority"] else "Medium")
        priority_combo = ttk.Combobox(frm, textvariable=priority_var, 
                                     values=["High", "Medium", "Low"], 
                                     state="readonly", width=20)
        priority_combo.grid(row=2, column=1, pady=(0, 10), sticky="w")
        
        # Status
        ttk.Label(frm, text="Status:", font=("Segoe UI", 9, "bold")).grid(row=3, column=0, sticky="w", pady=(0, 5))
        status_var = tk.StringVar(value=complaint["status"] or "Open")
        status_combo = ttk.Combobox(frm, textvariable=status_var, 
                                   values=["Open", "In Progress", "Closed"], 
                                   state="readonly", width=20)
        status_combo.grid(row=3, column=1, pady=(0, 10), sticky="w")
        
        # Description
        ttk.Label(frm, text="Description:", font=("Segoe UI", 9, "bold")).grid(row=4, column=0, sticky="nw", pady=(0, 5))
        desc_text = tk.Text(frm, height=8, width=50, wrap=tk.WORD)
        desc_text.insert("1.0", complaint["description"] or "")
        desc_text.grid(row=4, column=1, pady=(0, 15), sticky="ew")
        
        # Resolution (if status is Closed)
        ttk.Label(frm, text="Resolution:", font=("Segoe UI", 9, "bold")).grid(row=5, column=0, sticky="nw", pady=(0, 5))
        resolution_text = tk.Text(frm, height=4, width=50, wrap=tk.WORD)
        resolution_text.insert("1.0", complaint["resolution"] or "")
        resolution_text.grid(row=5, column=1, pady=(0, 15), sticky="ew")
        
        frm.columnconfigure(1, weight=1)
        
        def update():
            title = title_var.get().strip()
            if not title:
                messagebox.showerror("Validation", "Title is required", parent=w)
                title_entry.focus_set()
                return
            
            if len(title) < 5:
                messagebox.showerror("Validation", "Title must be at least 5 characters long", parent=w)
                title_entry.focus_set()
                return
            
            desc = desc_text.get("1.0", tk.END).strip()
            resolution = resolution_text.get("1.0", tk.END).strip()
            
            # Validate resolution if status is Closed
            if status_var.get() == "Closed" and not resolution:
                result = messagebox.askyesno("Confirmation", 
                    "Status is set to 'Closed' but no resolution is provided.\n\nDo you want to continue anyway?", 
                    parent=w)
                if not result:
                    resolution_text.focus_set()
                    return
            
            try:
                # Update complaint
                update_data = {
                    "title": title,
                    "description": desc,
                    "priority": priority_var.get(),
                    "status": status_var.get(),
                    "resolution": resolution
                }
                
                # If status changed to Closed, add resolved_date
                if status_var.get() == "Closed" and complaint["status"] != "Closed":
                    update_data["resolved_date"] = date.today()
                
                # Build update query
                set_clause = ", ".join([f"{key}=?" for key in update_data.keys()])
                values = list(update_data.values()) + [complaint_id]
                
                self.db.execute(f"UPDATE complaints SET {set_clause} WHERE id=?", tuple(values))
                
                w.destroy()
                self.refresh_complaints()
                messagebox.showinfo("Success", f"Complaint '{title}' updated successfully!\n\nStatus: {status_var.get()}\nPriority: {priority_var.get()}")
            except Exception as e:
                messagebox.showerror("Database Error", f"Failed to update complaint:\n{str(e)}", parent=w)
        
        # Keyboard shortcuts
        def on_escape_key(event):
            w.destroy()
        
        w.bind('<Escape>', on_escape_key)
        
        # Buttons frame
        btn_frame = ttk.Frame(frm)
        btn_frame.grid(row=6, column=0, columnspan=2, pady=(10, 0), sticky="ew")
        
        tk.Button(btn_frame, text="Update Complaint", command=update,
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=20, pady=6,
                 bg="#3b82f6", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Cancel", command=w.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=20, pady=6).pack(side="right")
    
    def delete_complaint(self):
        """Enhanced delete complaint with better confirmation and safety checks"""
        selection = self.complaints_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select a complaint to delete")
            return
        
        complaint_id = self.complaints_tree.item(selection[0])["values"][0]
        complaint = self.db.fetchone("SELECT title, status, date FROM complaints WHERE id=?", (complaint_id,))
        
        if not complaint:
            messagebox.showerror("Error", "Complaint not found")
            return
        
        # Enhanced confirmation dialog with complaint details
        confirm_msg = f"""Are you sure you want to delete this complaint?

📋 Title: {complaint['title']}
📅 Date: {complaint['date']}
📊 Status: {complaint['status']}

⚠️ WARNING: This action cannot be undone!"""
        
        if messagebox.askyesno("Confirm Delete", confirm_msg, icon="warning"):
            try:
                self.db.execute("DELETE FROM complaints WHERE id=?", (complaint_id,))
                self.refresh_complaints()
                messagebox.showinfo("Success", f"Complaint '{complaint['title']}' deleted successfully!")
            except Exception as e:
                messagebox.showerror("Database Error", f"Failed to delete complaint:\n{str(e)}")
    
    def view_complaint_details(self):
        """View detailed complaint information"""
        selection = self.complaints_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select a complaint to view details")
            return
        
        complaint_id = self.complaints_tree.item(selection[0])["values"][0]
        complaint = self.db.fetchone("SELECT * FROM complaints WHERE id=?", (complaint_id,))
        
        if not complaint:
            messagebox.showerror("Error", "Complaint not found")
            return
        
        # Get member info
        member = self.db.fetchone("SELECT name, flat_no, phone FROM members WHERE id=?", (complaint["member_id"],))
        
        w = tk.Toplevel(self)
        w.title(f"Complaint Details - {complaint['title']}")
        w.geometry("600x500")
        w.resizable(True, True)
        
        main_frame = ttk.Frame(w, padding=15)
        main_frame.pack(fill="both", expand=True)
        
        # Header
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill="x", pady=(0, 15))
        
        ttk.Label(header_frame, text=f"Complaint #{complaint['id']}", 
                 font=("Segoe UI", 14, "bold")).pack(anchor="w")
        ttk.Label(header_frame, text=f"Status: {complaint['status']}", 
                 font=("Segoe UI", 10), foreground="#059669" if complaint['status'] == 'Closed' else "#dc2626").pack(anchor="w")
        
        # Details in a scrollable text widget
        details_frame = ttk.Frame(main_frame)
        details_frame.pack(fill="both", expand=True, pady=(10, 0))
        
        details_text = tk.Text(details_frame, wrap="word", font=("Segoe UI", 10), relief="flat", background="#f8fafc")
        details_scroll = ttk.Scrollbar(details_frame, orient="vertical", command=details_text.yview)
        details_text.configure(yscrollcommand=details_scroll.set)
        
        details_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        details_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Format complaint details
        details = f"""
📋 COMPLAINT INFORMATION


🏷️  Title: {complaint['title']}
📅  Date: {complaint['date']}
⚠️  Priority: {complaint['priority'] if complaint['priority'] else 'Medium'}
📊  Status: {complaint['status']}

👤 MEMBER DETAILS

🏠  Name: {member['name'] if member else 'Unknown'}
🏢  Flat No: {member['flat_no'] if member else 'N/A'}
📞  Phone: {member['phone'] if member and member['phone'] else 'N/A'}

📝 DESCRIPTION

{complaint['description'] or 'No description provided'}
"""
        
        if complaint['status'] == 'Closed' and complaint.get('resolution'):
            details += f"""

✅ RESOLUTION

{complaint['resolution']}
📅 Resolved Date: {complaint.get('resolved_date', 'N/A')}
"""
        
        details_text.insert("1.0", details)
        details_text.config(state="disabled")
        
        # Buttons
        btn_frame = ttk.Frame(main_frame)
        btn_frame.pack(fill="x", pady=(15, 0))
        
        tk.Button(btn_frame, text="Edit Complaint", 
                 command=lambda: [w.destroy(), self.edit_complaint_window()],
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=15, pady=6,
                 bg="#3b82f6", fg="white").pack(side="left", padx=(0, 10))
        
        if complaint['status'] != 'Closed':
            tk.Button(btn_frame, text="Resolve Complaint", 
                     command=lambda: [w.destroy(), self.resolve_complaint()],
                     font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=15, pady=6,
                     bg="#059669", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Close", command=w.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=15, pady=6).pack(side="right")
    
    def update_complaint_statistics(self):
        """Update complaint statistics display"""
        try:
            # Total complaints
            total_complaints = self.db.fetchone("SELECT COUNT(*) as count FROM complaints")["count"]
            
            # Status-wise counts
            open_count = self.db.fetchone("SELECT COUNT(*) as count FROM complaints WHERE status='Open'")["count"]
            progress_count = self.db.fetchone("SELECT COUNT(*) as count FROM complaints WHERE status='In Progress'")["count"]
            closed_count = self.db.fetchone("SELECT COUNT(*) as count FROM complaints WHERE status='Closed'")["count"]
            
            # Update labels
            if hasattr(self, 'complaint_stats_labels'):
                self.complaint_stats_labels['total'].config(text=f"Total Complaints: {total_complaints}")
                self.complaint_stats_labels['open'].config(text=f"Open: {open_count}")
                self.complaint_stats_labels['in_progress'].config(text=f"In Progress: {progress_count}")
                self.complaint_stats_labels['closed'].config(text=f"Closed: {closed_count}")
            
        except Exception as e:
            print(f"Error updating complaint statistics: {e}")

    def resolve_complaint(self):
        """Enhanced resolve complaint with better validation and notification"""
        sel = self.complaints_tree.selection()
        if not sel:
            messagebox.showwarning("Select", "Please select a complaint to resolve")
            return
        
        comp_id = self.complaints_tree.item(sel[0])["values"][0]
        comp = self.db.fetchone("SELECT * FROM complaints WHERE id=?", (comp_id,))
        if not comp:
            messagebox.showerror("Not found", "Complaint not found")
            return
        if comp["status"] == "Closed":
            messagebox.showinfo("Info", "This complaint is already closed")
            return
        
        def do_resolve():
            resolution = txt.get("1.0", tk.END).strip()
            if not resolution:
                result = messagebox.askyesno("Confirmation", 
                    "No resolution text provided. Do you want to close the complaint anyway?", 
                    parent=res_win)
                if not result:
                    txt.focus_set()
                    return
            
            try:
                self.db.execute("UPDATE complaints SET status=?, resolution=?, resolved_date=? WHERE id=?",
                                ("Closed", resolution, date.today(), comp_id))
                res_win.destroy()
                self.refresh_complaints()
                
                # Enhanced success message
                messagebox.showinfo("Success", 
                    f"Complaint resolved successfully!\n\n"
                    f"Title: {comp['title']}\n"
                    f"Resolution Date: {date.today().strftime('%d-%m-%Y')}\n"
                    f"Status: Closed")
            except Exception as e:
                messagebox.showerror("Database Error", f"Failed to resolve complaint:\n{str(e)}", parent=res_win)

        res_win = tk.Toplevel(self)
        res_win.title("Resolve Complaint")
        res_win.geometry("500x350")
        res_win.grab_set()  # Make modal
        res_win.resizable(True, True)
        
        # Header with complaint info
        header_frame = ttk.Frame(res_win, padding=10)
        header_frame.pack(fill="x")
        
        ttk.Label(header_frame, text=f"Resolving Complaint: {comp['title']}", 
                 font=("Segoe UI", 12, "bold")).pack(anchor="w")
        ttk.Label(header_frame, text=f"Date: {comp['date']} | Priority: {comp['priority'] if comp['priority'] else 'Medium'}", 
                 font=("Segoe UI", 9)).pack(anchor="w", pady=(5, 0))
        
        # Resolution text area
        text_frame = ttk.Frame(res_win, padding=10)
        text_frame.pack(fill="both", expand=True)
        
        ttk.Label(text_frame, text="Resolution Details:", font=("Segoe UI", 9, "bold")).pack(anchor="w", pady=(0, 5))
        txt = tk.Text(text_frame, height=10, wrap=tk.WORD, font=("Segoe UI", 9))
        txt.pack(fill="both", expand=True)
        txt.focus_set()  # Auto-focus
        
        # Buttons
        btn_frame = ttk.Frame(res_win, padding=10)
        btn_frame.pack(fill="x")
        
        tk.Button(btn_frame, text="Resolve & Close", command=do_resolve,
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=20, pady=6,
                 bg="#059669", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Cancel", command=res_win.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=20, pady=6).pack(side="right")
        
        # Keyboard shortcuts
        def on_ctrl_enter(event):
            do_resolve()
        
        def on_escape(event):
            res_win.destroy()
        
        res_win.bind('<Control-Return>', on_ctrl_enter)
        res_win.bind('<Escape>', on_escape)
    
    def mark_complaint_urgent(self):
        """Mark selected complaint as high priority"""
        selection = self.complaints_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select a complaint to mark as urgent")
            return
        
        complaint_id = self.complaints_tree.item(selection[0])["values"][0]
        complaint = self.db.fetchone("SELECT title, priority FROM complaints WHERE id=?", (complaint_id,))
        
        if not complaint:
            messagebox.showerror("Error", "Complaint not found")
            return
        
        if complaint['priority'] == 'High':
            messagebox.showinfo("Info", "This complaint is already marked as High Priority")
            return
        
        try:
            self.db.execute("UPDATE complaints SET priority='High' WHERE id=?", (complaint_id,))
            self.refresh_complaints()
            messagebox.showinfo("Success", f"Complaint '{complaint['title']}' has been marked as HIGH PRIORITY!")
        except Exception as e:
            messagebox.showerror("Database Error", f"Failed to update priority:\n{str(e)}")
    
    def send_complaint_reminder(self):
        """Send reminder about selected complaint"""
        selection = self.complaints_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select a complaint to send reminder")
            return
        
        complaint_id = self.complaints_tree.item(selection[0])["values"][0]
        complaint = self.db.fetchone("SELECT c.*, m.name, m.phone FROM complaints c LEFT JOIN members m ON c.member_id = m.id WHERE c.id=?", (complaint_id,))
        
        if not complaint:
            messagebox.showerror("Error", "Complaint not found")
            return
        
        # Create reminder dialog
        w = tk.Toplevel(self)
        w.title("Send Complaint Reminder")
        w.geometry("450x300")
        w.grab_set()
        
        frm = ttk.Frame(w, padding=15)
        frm.pack(fill="both", expand=True)
        
        # Complaint info
        info_text = f"""Complaint Details:

Title: {complaint['title']}
Member: {complaint['name']} (Phone: {complaint['phone'] or 'N/A'})
Date: {complaint['date']}
Status: {complaint['status']}
Priority: {complaint['priority'] if complaint['priority'] else 'Medium'}

Reminder Message:"""
        
        ttk.Label(frm, text=info_text, font=("Segoe UI", 9)).pack(anchor="w", pady=(0, 10))
        
        # Message text area
        msg_text = tk.Text(frm, height=8, wrap=tk.WORD)
        default_msg = f"Dear {complaint['name']},\n\nThis is a reminder about your complaint:\n'{complaint['title']}'\n\nSubmitted on: {complaint['date']}\nCurrent Status: {complaint['status']}\n\nWe are working to resolve this issue. Thank you for your patience.\n\nBest regards,\nColony Management"
        msg_text.insert("1.0", default_msg)
        msg_text.pack(fill="both", expand=True, pady=(0, 15))
        
        def send_reminder():
            message = msg_text.get("1.0", tk.END).strip()
            if not message:
                messagebox.showerror("Validation", "Please enter a reminder message", parent=w)
                return
            
            # In a real application, you would send SMS/email here
            # For now, we'll just show a success message
            w.destroy()
            messagebox.showinfo("Reminder Sent", f"Reminder sent successfully!\n\nTo: {complaint['name']}\nPhone: {complaint['phone'] or 'N/A'}\n\nNote: In a full implementation, this would send an actual SMS/email.")
        
        # Buttons
        btn_frame = ttk.Frame(frm)
        btn_frame.pack(fill="x")
        
        tk.Button(btn_frame, text="Send Reminder", command=send_reminder,
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=20, pady=6,
                 bg="#7c3aed", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Cancel", command=w.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=20, pady=6).pack(side="right")

    def export_complaints_csv(self):
        """Enhanced export complaints with all fields including flat number and priority"""
        try:
            rows = self.db.fetchall("""
                SELECT c.id, m.name as member, m.flat_no, c.title, c.description, c.date, 
                       c.status, COALESCE(c.priority, 'Medium') as priority, c.resolution, c.resolved_date
                FROM complaints c LEFT JOIN members m ON c.member_id=m.id
                ORDER BY c.date DESC
            """)
            if not rows:
                messagebox.showinfo("Export", "No complaints to export")
                return
            
            filename = os.path.join(EXPORT_DIR, f"complaints_{datetime.now().strftime('%d%m%Y_%H%M%S')}.csv")
            cols = ["id", "member", "flat_no", "title", "description", "date", "status", "priority", "resolution", "resolved_date"]
            export_rows_to_csv(rows, cols, filename)
            open_file_in_default_app(filename)
        
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export complaints:\n{str(e)}")

    def generate_member_contrib_slip(self):
        """Generate contribution payment slip for selected member across filtered event"""
        sel_key = self.filter_member_var.get()
        if not sel_key:
            messagebox.showwarning("Selection Required", "Please select a member first")
            return
        member_id = self.member_filter_map[sel_key]
        # fetch member details
        member = self.db.fetchone("SELECT name, flat_no FROM members WHERE id=?", (member_id,))
        if not member:
            messagebox.showerror("Error", "Member not found")
            return
        # Fetch contributions of this member for selected event (current selection)
        selected = self.events_tree.selection()
        if not selected:
            messagebox.showwarning("Selection Required", "Please select an event in the list to generate slip")
            return
        event_id = self.events_tree.item(selected[0])['values'][0]
        event = self.db.fetchone("SELECT title, event_date FROM events WHERE id=?", (event_id,))
        contribs = self.db.fetchall("""
            SELECT amount, contribution_date, note FROM event_contributions
            WHERE event_id=? AND member_id=? ORDER BY contribution_date ASC
        """, (event_id, member_id))
        if not contribs:
            messagebox.showinfo("No Data", "This member has no contribution records for the selected event")
            return
        total = sum(c['amount'] for c in contribs)
        # Build lines for PDF slip
        from datetime import datetime
        lines = [
            "Society Contribution Payment Slip",
            f"Member: {member['name']} (Flat {member['flat_no']})",
            f"Event: {event['title']} ({event['event_date']})",
            "",
            "Details:",
        ]
        for idx, c in enumerate(contribs, 1):
            lines.append(f" {idx}. {c['contribution_date']} - ₹{c['amount']:.0f} ({c['note']})")
        lines.append("")
        lines.append(f"Total Contributed: ₹{total:.0f}")

        # --- Generate PDF using ReportLab ---
        try:
            from reportlab.pdfgen import canvas  # Lazy import to avoid global dependency if unused
            from reportlab.lib.pagesizes import A4
        except ImportError:
            messagebox.showerror("Dependency Missing", "ReportLab library not found. Please run 'pip install reportlab' and try again.")
            return

        import os
        pdf_path = os.path.join(EXPORT_DIR, f"contrib_slip_{member_id}_{event_id}_{datetime.now().strftime('%d%m%Y_%H%M%S')}.pdf")
        c = canvas.Canvas(pdf_path, pagesize=A4)
        width, height = A4
        y = height - 50  # Start 50px from top
        for line in lines:
            c.drawString(40, y, line)
            y -= 18  # Line height
            # Add new page if required
            if y < 50:
                c.showPage()
                y = height - 50
        c.save()

        open_file_in_default_app(pdf_path)
        messagebox.showinfo("Slip Generated", f"Contribution slip saved to:\n{pdf_path}")

    # --- Events ---
    def add_event_window(self):
        """Enhanced add event window with budget tracking"""
        w = tk.Toplevel(self)
        w.title("Add Event")
        w.geometry("520x450")
        w.resizable(False, False)
        
        frm = ttk.Frame(w, padding=15)
        frm.pack(fill="both", expand=True)
        
        # Event Title
        ttk.Label(frm, text="Event Title:", font=("Segoe UI", 9, "bold")).grid(row=0, column=0, sticky="w", pady=(0, 5))
        title = tk.StringVar()
        ttk.Entry(frm, textvariable=title, width=50).grid(row=0, column=1, pady=(0, 10), sticky="ew")
        
        # Event Date
        ttk.Label(frm, text="Event Date (DD-MM-YYYY):", font=("Segoe UI", 9, "bold")).grid(row=1, column=0, sticky="w", pady=(0, 5))
        ed = tk.StringVar(value=date.today().strftime("%d-%m-%Y"))
        ttk.Entry(frm, textvariable=ed, width=20).grid(row=1, column=1, pady=(0, 10), sticky="w")
        
        # Total Budget
        ttk.Label(frm, text="Total Budget (₹):", font=("Segoe UI", 9, "bold")).grid(row=2, column=0, sticky="w", pady=(0, 5))
        budget = tk.StringVar(value="0")
        ttk.Entry(frm, textvariable=budget, width=20).grid(row=2, column=1, pady=(0, 10), sticky="w")
        
        # Status
        ttk.Label(frm, text="Status:", font=("Segoe UI", 9, "bold")).grid(row=3, column=0, sticky="w", pady=(0, 5))
        status = tk.StringVar(value="Planned")
        status_combo = ttk.Combobox(frm, textvariable=status, values=["Planned", "Active", "Completed", "Cancelled"], 
                                   state="readonly", width=18)
        status_combo.grid(row=3, column=1, pady=(0, 10), sticky="w")
        
        # Description
        ttk.Label(frm, text="Description:", font=("Segoe UI", 9, "bold")).grid(row=4, column=0, sticky="nw", pady=(0, 5))
        desc = tk.Text(frm, height=8, width=50, wrap=tk.WORD)
        desc.grid(row=4, column=1, pady=(0, 15), sticky="ew")
        
        # Configure grid weights
        frm.columnconfigure(1, weight=1)
        
        def save():
            t = title.get().strip()
            if not t:
                messagebox.showerror("Validation", "Event title is required", parent=w)
                return
                
            try:
                d = datetime.strptime(ed.get().strip(), "%d-%m-%Y").date()
            except Exception:
                messagebox.showerror("Validation", "Date must be in DD-MM-YYYY format", parent=w)
                return
                
            try:
                budget_val = float(budget.get().strip() or "0")
            except ValueError:
                messagebox.showerror("Validation", "Budget must be a valid number", parent=w)
                return
            
            self.db.execute("""
                INSERT INTO events (title, description, event_date, posted_date, total_budget, status) 
                VALUES (?, ?, ?, ?, ?, ?)
            """, (t, desc.get("1.0", tk.END).strip(), d, date.today(), budget_val, status.get()))
            
            w.destroy()
            self.refresh_events()
            messagebox.showinfo("Success", f"Event '{t}' added successfully!")
        
        # Buttons frame
        btn_frame = ttk.Frame(frm)
        btn_frame.grid(row=5, column=0, columnspan=2, pady=(10, 0), sticky="ew")
        
        tk.Button(btn_frame, text="Add Event", command=save,
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=20, pady=6,
                 bg="#16a34a", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Cancel", command=w.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=20, pady=6).pack(side="right")

    def refresh_events_legacy(self):
        # Legacy refresh method - replaced by enhanced version
        pass

    def export_events_csv(self):
        rows = self.db.fetchall("SELECT id, title, description, event_date, posted_date FROM events")
        if not rows:
            messagebox.showinfo("Export", "No events to export")
            return
        filename = os.path.join(EXPORT_DIR, f"events_{datetime.now().strftime('%d%m%Y_%H%M%S')}.csv")
        cols = ["id", "title", "description", "event_date", "posted_date"]
        export_rows_to_csv(rows, cols, filename)
        open_file_in_default_app(filename)

    # Enhanced Event Management Methods will be added later
    def edit_event_window(self):
        """Edit selected event - Full implementation"""
        selection = self.events_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select an event to edit")
            return
        
        event_id = self.events_tree.item(selection[0])["values"][0]

        event = self.db.fetchone("SELECT * FROM events WHERE id=?", (event_id,))

        if not event:
            messagebox.showerror("Error", "Event not found")
            return

        w = tk.Toplevel(self)
        w.title("Edit Event")
        w.geometry("520x450")
        w.resizable(False, False)

        frm = ttk.Frame(w, padding=15)
        frm.pack(fill="both", expand=True)

        ttk.Label(frm, text="Event Title:", font=("Segoe UI", 9, "bold")).grid(row=0, column=0, sticky="w", pady=(0, 5))
        title = tk.StringVar(value=event["title"] or "")
        ttk.Entry(frm, textvariable=title, width=50).grid(row=0, column=1, pady=(0, 10), sticky="ew")

        ttk.Label(frm, text="Event Date (DD-MM-YYYY):", font=("Segoe UI", 9, "bold")).grid(row=1, column=0, sticky="w", pady=(0, 5))
        existing_date = ""
        if event["event_date"]:
            try:
                if isinstance(event["event_date"], str):
                    for fmt in ("%Y-%m-%d", "%d-%m-%Y"):
                        try:
                            dt = datetime.strptime(event["event_date"], fmt)
                            existing_date = dt.strftime("%d-%m-%Y")
                            break
                        except ValueError:
                            continue
                else:
                    existing_date = event["event_date"].strftime("%d-%m-%Y")
            except Exception:
                existing_date = str(event["event_date"])

        ed = tk.StringVar(value=existing_date)
        ttk.Entry(frm, textvariable=ed, width=20).grid(row=1, column=1, pady=(0, 10), sticky="w")

        ttk.Label(frm, text="Total Budget (₹):", font=("Segoe UI", 9, "bold")).grid(row=2, column=0, sticky="w", pady=(0, 5))
        budget = tk.StringVar(value=str(event["total_budget"] or "0"))
        ttk.Entry(frm, textvariable=budget, width=20).grid(row=2, column=1, pady=(0, 10), sticky="w")

        ttk.Label(frm, text="Status:", font=("Segoe UI", 9, "bold")).grid(row=3, column=0, sticky="w", pady=(0, 5))
        status = tk.StringVar(value=event["status"] or "Planned")
        status_combo = ttk.Combobox(frm, textvariable=status, values=["Planned", "Active", "Completed", "Cancelled"],
                                    state="readonly", width=18)
        status_combo.grid(row=3, column=1, pady=(0, 10), sticky="w")

        ttk.Label(frm, text="Description:", font=("Segoe UI", 9, "bold")).grid(row=4, column=0, sticky="nw", pady=(0, 5))
        desc = tk.Text(frm, height=8, width=50, wrap=tk.WORD)
        desc.insert("1.0", event["description"] or "")
        desc.grid(row=4, column=1, pady=(0, 15), sticky="ew")

        frm.columnconfigure(1, weight=1)

        def update():
            t = title.get().strip()
            if not t:
                messagebox.showerror("Validation", "Event title is required", parent=w)
                return

            try:
                d = datetime.strptime(ed.get().strip(), "%d-%m-%Y").date()
            except Exception:
                messagebox.showerror("Validation", "Date must be in DD-MM-YYYY format", parent=w)
                return

            try:
                budget_val = float(budget.get().strip() or "0")
            except ValueError:
                messagebox.showerror("Validation", "Budget must be a valid number", parent=w)
                return

            self.db.execute(
                """
                UPDATE events SET title=?, description=?, event_date=?, total_budget=?, status=?
                WHERE id=?
                """, (t, desc.get("1.0", tk.END).strip(), d, budget_val, status.get(), event_id))

            w.destroy()
            self.refresh_events()
            messagebox.showinfo("Success", f"Event '{t}' updated successfully!")

        btn_frame = ttk.Frame(frm)
        btn_frame.grid(row=5, column=0, columnspan=2, pady=(10, 0), sticky="ew")

        tk.Button(btn_frame, text="Update Event", command=update,
                  font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=20, pady=6,
                  bg="#3b82f6", fg="white").pack(side="left", padx=(0, 10))

        tk.Button(btn_frame, text="Cancel", command=w.destroy,
                  font=("Segoe UI", 9), relief="raised", bd=1, padx=20, pady=6).pack(side="right")
        
        # End of edit_event_window

    def _show_parking_context_menu(self, event):
        """Show context menu for parking treeview"""
        # Select the item under cursor
        item = self.parking_tree.identify_row(event.y)
        if item:
            self.parking_tree.selection_set(item)
            try:
                self.parking_context_menu.tk_popup(event.x_root, event.y_root)
            finally:
                self.parking_context_menu.grab_release()
    
    def export_parking_csv(self):
        """Export parking data to CSV"""
        rows = self.db.fetchall("""
            SELECT p.slot_no, m.name as member_name, m.flat_no, p.vehicle_number, 
                   p.vehicle_model, p.allocated_date
            FROM parking p
            LEFT JOIN members m ON p.member_id = m.id
            ORDER BY p.slot_no
        """)
        
        if not rows:
            messagebox.showinfo("Export", "No parking data to export")
            return
        
        try:
            filename = os.path.join(EXPORT_DIR, f"parking_{datetime.now().strftime('%d%m%Y_%H%M%S')}.csv")
            cols = ["slot_no", "member_name", "flat_no", "vehicle_number", "vehicle_model", "allocated_date"]
            export_rows_to_csv(rows, cols, filename)
            messagebox.showinfo("Export Success", f"Parking data exported to {filename}")
            open_file_in_default_app(filename)
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export parking data:\n{str(e)}")
    
    def print_parking_report(self):
        """Generate parking allocation report PDF and open it"""
        # Fetch parking allocation data
        rows = self.db.fetchall(
            """
            SELECT p.slot_no, m.name as member_name, m.flat_no, p.vehicle_number, 
                   p.vehicle_model, p.allocated_date
            FROM parking p
            LEFT JOIN members m ON p.member_id = m.id
            ORDER BY p.slot_no
            """
        )

        if not rows:
            messagebox.showinfo("Print Report", "कोई पार्किंग डेटा उपलब्ध नहीं है जिसे रिपोर्ट में शामिल किया जा सके।")
            return

        # Lazy-import ReportLab so that rest of the app works even if dependency is missing
        try:
            from reportlab.lib.pagesizes import A4, landscape
            from reportlab.lib import colors
            from reportlab.platypus import (
                SimpleDocTemplate,
                Table,
                TableStyle,
                Paragraph,
                Spacer,
            )
            from reportlab.lib.styles import getSampleStyleSheet
            from reportlab.lib.units import inch
        except ImportError:
            messagebox.showerror(
                "Dependency Missing",
                "ReportLab लाइब्रेरी अनुपलब्ध है। कृपया ‛pip install reportlab’ चलाएँ और दोबारा प्रयास करें।",
            )
            return

        import os

        pdf_path = os.path.join(
            EXPORT_DIR,
            f"parking_report_{datetime.now().strftime('%d%m%Y_%H%M%S')}.pdf",
        )

        # Prepare table data (header + rows)
        data = [
            [
                "Slot No",
                "Member Name",
                "Flat No",
                "Vehicle No",
                "Vehicle Model",
                "Allocated Date",
            ]
        ]
        for r in rows:
            data.append(
                [
                    r["slot_no"],
                    r["member_name"] or "-",
                    r["flat_no"] or "-",
                    r["vehicle_number"] or "-",
                    r["vehicle_model"] or "-",
                    r["allocated_date"] or "-",
                ]
            )

        # Build PDF
        doc = SimpleDocTemplate(
            pdf_path,
            pagesize=landscape(A4),
            leftMargin=30,
            rightMargin=30,
            topMargin=30,
            bottomMargin=30,
        )

        styles = getSampleStyleSheet()
        flow = []
        flow.append(Paragraph("Parking Allocation Report", styles["Title"]))
        flow.append(Spacer(1, 12))
        flow.append(
            Paragraph(
                f"Generated: {datetime.now().strftime('%d-%m-%Y %H:%M:%S')}",
                styles["Normal"],
            )
        )
        flow.append(Spacer(1, 12))

        # Create table with styling
        table = Table(
            data,
            repeatRows=1,
            colWidths=[1 * inch, 2.2 * inch, 1 * inch, 1.7 * inch, 1.8 * inch, 1.3 * inch],
        )
        style = TableStyle(
            [
                ("BACKGROUND", (0, 0), (-1, 0), colors.lightgrey),
                ("GRID", (0, 0), (-1, -1), 0.25, colors.black),
                ("FONT", (0, 0), (-1, 0), "Helvetica-Bold"),
                ("ALIGN", (0, 0), (-1, -1), "CENTER"),
            ]
        )
        table.setStyle(style)
        flow.append(table)

        try:
            doc.build(flow)
        except Exception as e:
            messagebox.showerror("Print Error", f"PDF जेनरेट करने में विफल:\n{str(e)}")
            return

        # Open the generated PDF in default viewer
        try:
            open_file_in_default_app(pdf_path)
            messagebox.showinfo("Print Report", f"PDF रिपोर्ट सफलतापूर्वक सहेजी गई:\n{pdf_path}")
        except Exception:
            # Even if opening fails, PDF is generated; inform user
            messagebox.showinfo("Print Report", f"PDF रिपोर्ट सफलतापूर्वक सहेजी गई:\n{pdf_path}\n\n(फ़ाइल खोलने में त्रुटि हुई)")
    
    def parking_slot_audit(self):
        """Perform parking slot audit"""
        try:
            # This would typically perform an audit of parking slots
            # For now, we'll just show a message with audit information
            total_slots = self.db.fetchone("SELECT COUNT(*) as count FROM parking")["count"]
            allocated_slots = self.db.fetchone("SELECT COUNT(*) as count FROM parking WHERE member_id IS NOT NULL")["count"]
            free_slots = total_slots - allocated_slots
            
            audit_info = f"""
Parking Slot Audit Report
=========================

Total Parking Slots: {total_slots}
Allocated Slots: {allocated_slots}
Free Slots: {free_slots}

Last Audit: {datetime.now().strftime('%d-%m-%Y %H:%M:%S')}
            """
            
            messagebox.showinfo("Parking Slot Audit", audit_info)
        except Exception as e:
            messagebox.showerror("Audit Error", f"Failed to perform parking audit:\n{str(e)}")

        event = self.db.fetchone("SELECT * FROM events WHERE id=?", (event_id,))
        
        if not event:
            messagebox.showerror("Error", "Event not found")
            return
        
        w = tk.Toplevel(self)
        w.title("Edit Event")
        w.geometry("520x450")
        w.resizable(False, False)
        
        frm = ttk.Frame(w, padding=15)
        frm.pack(fill="both", expand=True)
        
        # Pre-fill with existing data
        ttk.Label(frm, text="Event Title:", font=("Segoe UI", 9, "bold")).grid(row=0, column=0, sticky="w", pady=(0, 5))
        title = tk.StringVar(value=event["title"] or "")
        ttk.Entry(frm, textvariable=title, width=50).grid(row=0, column=1, pady=(0, 10), sticky="ew")
        
        ttk.Label(frm, text="Event Date (DD-MM-YYYY):", font=("Segoe UI", 9, "bold")).grid(row=1, column=0, sticky="w", pady=(0, 5))
        # Format existing date
        existing_date = ""
        if event["event_date"]:
            try:
                if isinstance(event["event_date"], str):
                    # Try to parse existing date
                    for fmt in ("%Y-%m-%d", "%d-%m-%Y"):
                        try:
                            dt = datetime.strptime(event["event_date"], fmt)
                            existing_date = dt.strftime("%d-%m-%Y")
                            break
                        except ValueError:
                            continue
                else:
                    existing_date = event["event_date"].strftime("%d-%m-%Y")
            except:
                existing_date = str(event["event_date"])
        
        ed = tk.StringVar(value=existing_date)
        ttk.Entry(frm, textvariable=ed, width=20).grid(row=1, column=1, pady=(0, 10), sticky="w")
        
        ttk.Label(frm, text="Total Budget (₹):", font=("Segoe UI", 9, "bold")).grid(row=2, column=0, sticky="w", pady=(0, 5))
        budget = tk.StringVar(value=str(event["total_budget"] or "0"))
        ttk.Entry(frm, textvariable=budget, width=20).grid(row=2, column=1, pady=(0, 10), sticky="w")
        
        ttk.Label(frm, text="Status:", font=("Segoe UI", 9, "bold")).grid(row=3, column=0, sticky="w", pady=(0, 5))
        status = tk.StringVar(value=event["status"] or "Planned")
        status_combo = ttk.Combobox(frm, textvariable=status, values=["Planned", "Active", "Completed", "Cancelled"], 
                                   state="readonly", width=18)
        status_combo.grid(row=3, column=1, pady=(0, 10), sticky="w")
        
        ttk.Label(frm, text="Description:", font=("Segoe UI", 9, "bold")).grid(row=4, column=0, sticky="nw", pady=(0, 5))
        desc = tk.Text(frm, height=8, width=50, wrap=tk.WORD)
        desc.insert("1.0", event["description"] or "")
        desc.grid(row=4, column=1, pady=(0, 15), sticky="ew")
        
        frm.columnconfigure(1, weight=1)
        
        def update():
            t = title.get().strip()
            if not t:
                messagebox.showerror("Validation", "Event title is required", parent=w)
                return
                
            try:
                d = datetime.strptime(ed.get().strip(), "%d-%m-%Y").date()
            except Exception:
                messagebox.showerror("Validation", "Date must be in DD-MM-YYYY format", parent=w)
                return
                
            try:
                budget_val = float(budget.get().strip() or "0")
            except ValueError:
                messagebox.showerror("Validation", "Budget must be a valid number", parent=w)
                return
            
            self.db.execute("""
                UPDATE events SET title=?, description=?, event_date=?, total_budget=?, status=? 
                WHERE id=?
            """, (t, desc.get("1.0", tk.END).strip(), d, budget_val, status.get(), event_id))
            
            w.destroy()
            self.refresh_events()
            messagebox.showinfo("Success", f"Event '{t}' updated successfully!")
        
        btn_frame = ttk.Frame(frm)
        btn_frame.grid(row=5, column=0, columnspan=2, pady=(10, 0), sticky="ew")
        
        tk.Button(btn_frame, text="Update Event", command=update,
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=20, pady=6,
                 bg="#3b82f6", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Cancel", command=w.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=20, pady=6).pack(side="right")
        
    def delete_event(self):
        """Delete selected event - Basic implementation"""
        selection = self.events_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select an event to delete")
            return
        
        event_id = self.events_tree.item(selection[0])["values"][0]
        event = self.db.fetchone("SELECT title FROM events WHERE id=?", (event_id,))
        
        if not event:
            messagebox.showerror("Error", "Event not found")
            return
        
        if messagebox.askyesno("Confirm Delete", f"Are you sure you want to delete '{event['title']}'?"):
            self.db.execute("DELETE FROM events WHERE id=?", (event_id,))
            self.refresh_events()
            messagebox.showinfo("Success", f"Event '{event['title']}' deleted successfully!")
    
    def add_contribution_window(self):
        """Add member contribution for an event"""
        # First check if there's a selected event
        selection = self.events_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select an event first to add contribution")
            return
        
        event_id = self.events_tree.item(selection[0])["values"][0]
        event = self.db.fetchone("SELECT * FROM events WHERE id=?", (event_id,))
        
        if not event:
            messagebox.showerror("Error", "Event not found")
            return
        
        w = tk.Toplevel(self)
        w.title(f"Add Contribution - {event['title']}")
        w.geometry("500x380")
        w.resizable(False, False)
        
        frm = ttk.Frame(w, padding=15)
        frm.pack(fill="both", expand=True)
        
        # Event info header
        header_frame = ttk.Frame(frm)
        header_frame.grid(row=0, column=0, columnspan=2, pady=(0, 15), sticky="ew")
        
        ttk.Label(header_frame, text=f"Event: {event['title']}", 
                 font=("Segoe UI", 10, "bold")).pack(anchor="w")
        ttk.Label(header_frame, text=f"Budget: ₹{event['total_budget'] or 0:.0f}", 
                 font=("Segoe UI", 9), foreground="#3b82f6").pack(anchor="w")
        
        # Member selection
        ttk.Label(frm, text="Select Member:", font=("Segoe UI", 9, "bold")).grid(row=1, column=0, sticky="w", pady=(0, 5))
        
        # Get all members for dropdown
        members = self.db.fetchall("SELECT id, name, flat_no FROM members ORDER BY name")
        member_options = {f"{m['name']} (Flat {m['flat_no']})": m['id'] for m in members}
        
        member_var = tk.StringVar()
        member_combo = ttk.Combobox(frm, textvariable=member_var, 
                                   values=list(member_options.keys()), 
                                   state="readonly", width=35)
        member_combo.grid(row=1, column=1, pady=(0, 10), sticky="ew")
        
        # Contribution amount
        ttk.Label(frm, text="Contribution Amount (₹):", font=("Segoe UI", 9, "bold")).grid(row=2, column=0, sticky="w", pady=(0, 5))
        amount = tk.StringVar()
        ttk.Entry(frm, textvariable=amount, width=20).grid(row=2, column=1, pady=(0, 10), sticky="w")
        
        # Note/Comment
        ttk.Label(frm, text="Note (Optional):", font=("Segoe UI", 9, "bold")).grid(row=3, column=0, sticky="nw", pady=(0, 5))
        note_text = tk.Text(frm, height=4, width=35, wrap=tk.WORD)
        note_text.grid(row=3, column=1, pady=(0, 15), sticky="ew")
        
        frm.columnconfigure(1, weight=1)
        
        def save_contribution():
            selected_member = member_var.get().strip()
            if not selected_member:
                messagebox.showerror("Validation", "Please select a member", parent=w)
                return
            
            amount_str = amount.get().strip()
            if not amount_str:
                messagebox.showerror("Validation", "Please enter contribution amount", parent=w)
                return
            
            try:
                amount_val = float(amount_str)
                if amount_val <= 0:
                    messagebox.showerror("Validation", "Amount must be greater than 0", parent=w)
                    return
            except ValueError:
                messagebox.showerror("Validation", "Please enter a valid amount", parent=w)
                return
            
            member_id = member_options[selected_member]
            note_val = note_text.get("1.0", tk.END).strip()
            
            # Check if member already contributed to this event
            existing = self.db.fetchone(
                "SELECT id FROM event_contributions WHERE event_id=? AND member_id=?", 
                (event_id, member_id)
            )
            
            if existing:
                if not messagebox.askyesno("Existing Contribution", 
                    "This member has already contributed to this event. Do you want to add another contribution?", parent=w):
                    return
            
            self.db.execute("""
                INSERT INTO event_contributions (event_id, member_id, amount, contribution_date, note) 
                VALUES (?, ?, ?, ?, ?)
            """, (event_id, member_id, amount_val, date.today(), note_val))
            
            w.destroy()
            self.refresh_events()
            messagebox.showinfo("Success", f"Contribution of ₹{amount_val:.0f} added successfully!")
        
        # Buttons frame
        btn_frame = ttk.Frame(frm)
        btn_frame.grid(row=4, column=0, columnspan=2, pady=(10, 0), sticky="ew")
        
        tk.Button(btn_frame, text="Add Contribution", command=save_contribution,
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=20, pady=6,
                 bg="#059669", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Cancel", command=w.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=20, pady=6).pack(side="right")
        
    def view_contributions_window(self):
        """View contributions for an event"""
        # First check if there's a selected event
        selection = self.events_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select an event to view contributions")
            return
        
        event_id = self.events_tree.item(selection[0])["values"][0]
        event = self.db.fetchone("SELECT * FROM events WHERE id=?", (event_id,))
        
        if not event:
            messagebox.showerror("Error", "Event not found")
            return
        
        w = tk.Toplevel(self)
        w.title(f"Contributions - {event['title']}")
        w.geometry("700x500")
        w.resizable(True, True)
        
        main_frame = ttk.Frame(w, padding=10)
        main_frame.pack(fill="both", expand=True)
        
        # Header with event info
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill="x", pady=(0, 15))
        
        ttk.Label(header_frame, text=f"Event: {event['title']}", 
                 font=("Segoe UI", 12, "bold")).pack(anchor="w")
        
        # Event statistics row
        stats_frame = ttk.Frame(header_frame)
        stats_frame.pack(fill="x", pady=(5, 0))
        
        # Get total contributions for this event
        total_contrib = self.db.fetchone(
            "SELECT COALESCE(SUM(amount), 0) as total FROM event_contributions WHERE event_id=?", 
            (event_id,)
        )["total"]
        
        # Count of contributors
        contrib_count = self.db.fetchone(
            "SELECT COUNT(DISTINCT member_id) as count FROM event_contributions WHERE event_id=?", 
            (event_id,)
        )["count"]
        
        ttk.Label(stats_frame, text=f"Budget: ₹{event['total_budget'] or 0:.0f}", 
                 font=("Segoe UI", 9), foreground="#3b82f6").pack(side="left", padx=(0, 20))
        ttk.Label(stats_frame, text=f"Total Collected: ₹{total_contrib:.0f}", 
                 font=("Segoe UI", 9), foreground="#059669").pack(side="left", padx=(0, 20))
        ttk.Label(stats_frame, text=f"Contributors: {contrib_count}", 
                 font=("Segoe UI", 9), foreground="#7c3aed").pack(side="left")
        
        # Progress bar for budget completion
        progress_frame = ttk.Frame(header_frame)
        progress_frame.pack(fill="x", pady=(10, 0))
        
        ttk.Label(progress_frame, text="Budget Progress:", 
                 font=("Segoe UI", 9, "bold")).pack(anchor="w")
        
        progress_bar = ttk.Progressbar(progress_frame, length=400, mode='determinate')
        progress_bar.pack(anchor="w", pady=(2, 0))
        
        # Calculate progress percentage
        budget = event['total_budget'] or 1  # Avoid division by zero
        progress_value = min((total_contrib / budget) * 100, 100)
        progress_bar['value'] = progress_value
        
        ttk.Label(progress_frame, text=f"{progress_value:.1f}% Complete", 
                 font=("Segoe UI", 8)).pack(anchor="w", pady=(2, 0))
        
        # Contributions list
        list_frame = ttk.Frame(main_frame)
        list_frame.pack(fill="both", expand=True, pady=(10, 0))
        
        ttk.Label(list_frame, text="Contribution Details:", 
                 font=("Segoe UI", 10, "bold")).pack(anchor="w", pady=(0, 5))
        
        # Tree for contributions
        tree_frame = ttk.Frame(list_frame)
        tree_frame.pack(fill="both", expand=True)
        
        contrib_columns = ("id", "member", "flat_no", "amount", "date", "note")
        contrib_tree = ttk.Treeview(tree_frame, columns=contrib_columns, show="headings", height=12)
        
        # Configure columns
        column_config = {
            "id": ("ID", 50, "center"),
            "member": ("Member Name", 150, "w"),
            "flat_no": ("Flat No", 80, "center"),
            "amount": ("Amount (₹)", 100, "center"),
            "date": ("Date", 100, "center"),
            "note": ("Note", 200, "w")
        }
        
        for col, (header, width, anchor) in column_config.items():
            contrib_tree.heading(col, text=header)
            contrib_tree.column(col, width=width, anchor=anchor)
        
        # Add scrollbar for contributions tree
        contrib_scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=contrib_tree.yview)
        contrib_tree.configure(yscrollcommand=contrib_scrollbar.set)
        
        contrib_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        contrib_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Contributions will be loaded manually below
        # self.load_contributions_data(contrib_tree)
        
        # Complaints tree
        complaints_columns = ("id", "member", "flat_no", "title", "date", "status", "priority")
        self.complaints_tree = ttk.Treeview(tree_frame, columns=complaints_columns, show="headings", height=12)
        
        # Configure columns
        column_config = {
            "id": ("ID", 50, "center"),
            "member": ("Member Name", 150, "w"),
            "flat_no": ("Flat No", 80, "center"),
            "title": ("Complaint Title", 200, "w"),
            "date": ("Date", 100, "center"),
            "status": ("Status", 80, "center"),
            "priority": ("Priority", 80, "center")
        }
        
        for col, (header, width, anchor) in column_config.items():
            self.complaints_tree.heading(col, text=header)
            self.complaints_tree.column(col, width=width, anchor=anchor)
        contributions = self.db.fetchall("""
            SELECT ec.id, m.name, m.flat_no, ec.amount, ec.contribution_date, ec.note
            FROM event_contributions ec
            JOIN members m ON ec.member_id = m.id
            WHERE ec.event_id = ?
            ORDER BY ec.contribution_date DESC
        """, (event_id,))
        
        for contrib in contributions:
            contrib_tree.insert("", tk.END, values=(
                contrib["id"],
                contrib["name"],
                contrib["flat_no"],
                f"₹{contrib['amount']:.0f}",
                contrib["contribution_date"],
                contrib["note"] or "No note"
            ))
        
        # Buttons frame
        btn_frame = ttk.Frame(main_frame)
        btn_frame.pack(fill="x", pady=(15, 0))
        
        tk.Button(btn_frame, text="Add New Contribution", 
                 command=lambda: [w.destroy(), self.add_contribution_window()],
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=15, pady=6,
                 bg="#059669", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Export to CSV", 
                 command=lambda: self.export_contributions_csv(event_id, event['title']),
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=15, pady=6,
                 bg="#3b82f6", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Close", command=w.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=15, pady=6).pack(side="right")
        
        # Show message if no contributions
        if not contributions:
            ttk.Label(list_frame, text="No contributions yet for this event.", 
                     font=("Segoe UI", 9), foreground="#6b7280").pack(pady=20)
        
    def add_festival_events(self):
        """Show dialog to add preset or custom festival events"""
        # Preset festivals template
        presets = [
            ("Holi Celebration", "Festival of colors celebration"),
            ("Diwali Festival", "Festival of lights celebration"),
            ("Navratri Celebration", "Nine nights celebration"),
            ("Christmas Celebration", "Christmas party celebration"),
        ]

        # --- UI Dialog ---
        w = tk.Toplevel(self)
        w.title("Add Festival Events")
        w.geometry("400x400")
        w.resizable(False, False)

        frm = ttk.Frame(w, padding=10)
        frm.pack(fill="both", expand=True)

        ttk.Label(frm, text="Select Festival Events to Add:", font=("Segoe UI", 10, "bold")).pack(anchor="w", pady=(0, 8))

        # Checkbox list for presets
        preset_vars = []
        for title, _ in presets:
            var = tk.BooleanVar(value=False)
            chk = ttk.Checkbutton(frm, text=title, variable=var)
            chk.pack(anchor="w")
            preset_vars.append((var, title))

        ttk.Separator(frm).pack(fill="x", pady=10)

        ttk.Label(frm, text="Add Custom Festival Event (optional):", font=("Segoe UI", 10, "bold")).pack(anchor="w", pady=(0, 6))
        ttk.Label(frm, text="Title:").pack(anchor="w")
        custom_title_var = tk.StringVar()
        ttk.Entry(frm, textvariable=custom_title_var).pack(fill="x", pady=(0, 6))
        ttk.Label(frm, text="Description:").pack(anchor="w")
        custom_desc_var = tk.StringVar()
        ttk.Entry(frm, textvariable=custom_desc_var).pack(fill="x")

        def add_selected():
            added = 0
            # Add selected presets
            for var, title in preset_vars:
                if var.get():
                    desc = next(d for t, d in presets if t == title)
                    if not self.db.fetchone("SELECT id FROM events WHERE title = ?", (title,)):
                        event_date = date.today()  # Use today by default; could customize further
                        self.db.execute(
                            "INSERT INTO events (title, description, event_date, posted_date, status) VALUES (?, ?, ?, ?, ?)",
                            (title, desc, event_date, date.today(), "Planned")
                        )
                        added += 1
            # Add custom festival if provided
            c_title = custom_title_var.get().strip()
            if c_title:
                c_desc = custom_desc_var.get().strip()
                if not self.db.fetchone("SELECT id FROM events WHERE title = ?", (c_title,)):
                    self.db.execute(
                        "INSERT INTO events (title, description, event_date, posted_date, status) VALUES (?, ?, ?, ?, ?)",
                        (c_title, c_desc or "Custom festival event", date.today(), date.today(), "Planned")
                    )
                    added += 1
            if added:
                self.refresh_events()
                messagebox.showinfo("Success", f"{added} festival event(s) added!", parent=w)
            else:
                messagebox.showinfo("Info", "No new events added (they may already exist).", parent=w)
            w.destroy()

        ttk.Button(frm, text="Add Selected", command=add_selected, style="Accent.TButton").pack(pady=12)
        ttk.Button(frm, text="Cancel", command=w.destroy).pack()

    
    def export_contributions_csv(self, event_id, event_title):
        
        """Export contributions for a specific event to CSV"""
        contributions = self.db.fetchall("""
            SELECT ec.id, m.name as member_name, m.flat_no, ec.amount, 
                   ec.contribution_date, ec.note
            FROM event_contributions ec
            JOIN members m ON ec.member_id = m.id
            WHERE ec.event_id = ?
            ORDER BY ec.contribution_date DESC
        """, (event_id,))
        
        if not contributions:
            messagebox.showinfo("Export", "No contributions to export for this event")
            return
        
        import os
        from datetime import datetime
        
        # Create filename
        safe_title = "".join(c for c in event_title if c.isalnum() or c in (' ', '-', '_')).rstrip()
        filename = os.path.join(EXPORT_DIR, f"contributions_{safe_title}_{datetime.now().strftime('%d%m%Y_%H%M%S')}.csv")
        
        cols = ["id", "member_name", "flat_no", "amount", "contribution_date", "note"]
        export_rows_to_csv(contributions, cols, filename)
        open_file_in_default_app(filename)
        
    def update_event_statistics(self):
        """Update event statistics display with real data"""
        try:
            # Total events count
            total_events = self.db.fetchone("SELECT COUNT(*) as count FROM events")["count"]
            
            # Upcoming events (future events) – handle both ISO ('YYYY-MM-DD') and custom 'DD-MM-YYYY' formats
            upcoming_rows = self.db.fetchall("SELECT event_date FROM events")
            from datetime import datetime, date as _dt_date
            upcoming_count = 0
            for r in upcoming_rows:
                raw = r['event_date']
                if not raw:
                    continue
                try:
                    # Try ISO format first
                    ev_date = datetime.strptime(raw, "%Y-%m-%d").date()
                except ValueError:
                    try:
                        # Fallback to DD-MM-YYYY
                        ev_date = datetime.strptime(raw, "%d-%m-%Y").date()
                    except ValueError:
                        # Unknown format – skip
                        continue
                if ev_date >= _dt_date.today():
                    upcoming_count += 1
            
            # Total budget across all events
            total_budget = self.db.fetchone("""
                SELECT COALESCE(SUM(total_budget), 0) as total FROM events
            """)["total"]
            
            # Total collected contributions
            total_collected = self.db.fetchone("""
                SELECT COALESCE(SUM(amount), 0) as total FROM event_contributions
            """)["total"]
            
            # Update labels
            self.event_stats_labels['total'].config(text=f"Total Events: {total_events}")
            self.event_stats_labels['upcoming'].config(text=f"Upcoming: {upcoming_count}")
            self.event_stats_labels['budget'].config(text=f"Total Budget: ₹{total_budget:.0f}")
            self.event_stats_labels['collected'].config(text=f"Total Collected: ₹{total_collected:.0f}")
            
        except Exception as e:
            print(f"Error updating event statistics: {e}")
            # Set default values on error
            self.event_stats_labels['total'].config(text="Total Events: 0")
            self.event_stats_labels['upcoming'].config(text="Upcoming: 0")
            self.event_stats_labels['budget'].config(text="Total Budget: ₹0")
            self.event_stats_labels['collected'].config(text="Total Collected: ₹0")

    # --- Staff ---
    def add_staff_window(self):
        """Enhanced add staff window with better UI and validation"""
        w = tk.Toplevel(self)
        w.title("Add Staff Member")
        w.geometry("500x420")
        w.resizable(False, False)
        w.grab_set()  # Make modal
        
        frm = ttk.Frame(w, padding=15)
        frm.pack(fill="both", expand=True)
        
        # Staff Name
        ttk.Label(frm, text="Staff Name:", font=("Segoe UI", 9, "bold")).grid(row=0, column=0, sticky="w", pady=(0, 5))
        name_var = tk.StringVar()
        name_entry = ttk.Entry(frm, textvariable=name_var, width=45)
        name_entry.grid(row=0, column=1, pady=(0, 10), sticky="ew")
        name_entry.focus_set()  # Auto-focus
        
        # Role/Position
        ttk.Label(frm, text="Role/Position:", font=("Segoe UI", 9, "bold")).grid(row=1, column=0, sticky="w", pady=(0, 5))
        role_var = tk.StringVar()
        role_combo = ttk.Combobox(frm, textvariable=role_var, width=42,
                                 values=["Security Guard", "Maintenance", "Cleaner", "Gardener", "Electrician", "Plumber", "Manager", "Supervisor", "Other"])
        role_combo.grid(row=1, column=1, pady=(0, 10), sticky="ew")
        
        # Phone Number
        ttk.Label(frm, text="Phone Number:", font=("Segoe UI", 9, "bold")).grid(row=2, column=0, sticky="w", pady=(0, 5))
        phone_var = tk.StringVar()
        phone_entry = ttk.Entry(frm, textvariable=phone_var, width=45)
        phone_entry.grid(row=2, column=1, pady=(0, 10), sticky="ew")
        
        # Salary
        ttk.Label(frm, text="Monthly Salary (₹):", font=("Segoe UI", 9, "bold")).grid(row=3, column=0, sticky="w", pady=(0, 5))
        salary_var = tk.StringVar()
        salary_entry = ttk.Entry(frm, textvariable=salary_var, width=45)
        salary_entry.grid(row=3, column=1, pady=(0, 10), sticky="ew")
        
        # Status
        ttk.Label(frm, text="Status:", font=("Segoe UI", 9, "bold")).grid(row=4, column=0, sticky="w", pady=(0, 5))
        status_var = tk.StringVar(value="Active")
        status_combo = ttk.Combobox(frm, textvariable=status_var, 
                                   values=["Active", "Inactive", "On Leave"], 
                                   state="readonly", width=20)
        status_combo.grid(row=4, column=1, pady=(0, 15), sticky="w")
        
        frm.columnconfigure(1, weight=1)
        
        def save():
            name = name_var.get().strip()
            role = role_var.get().strip()
            phone = phone_var.get().strip()
            salary_str = salary_var.get().strip()
            status = status_var.get()
            
            # Validation
            if not name:
                messagebox.showerror("Validation", "Staff name is required", parent=w)
                name_entry.focus_set()
                return
            
            if len(name) < 2:
                messagebox.showerror("Validation", "Name must be at least 2 characters long", parent=w)
                name_entry.focus_set()
                return
            
            if not role:
                messagebox.showerror("Validation", "Role/Position is required", parent=w)
                role_combo.focus_set()
                return
            
            if phone and len(phone) < 10:
                messagebox.showerror("Validation", "Phone number must be at least 10 digits", parent=w)
                phone_entry.focus_set()
                return
            
            try:
                salary = float(salary_str) if salary_str else 0.0
                if salary < 0:
                    messagebox.showerror("Validation", "Salary cannot be negative", parent=w)
                    salary_entry.focus_set()
                    return
            except ValueError:
                messagebox.showerror("Validation", "Please enter a valid salary amount", parent=w)
                salary_entry.focus_set()
                return
            
            try:
                self.db.execute("""
                    INSERT INTO staff (name, role, phone, salary, joined_date, status) 
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (name, role, phone, salary, date.today(), status))
                
                w.destroy()
                self.refresh_staff()
                messagebox.showinfo("Success", f"Staff member '{name}' added successfully!\n\nRole: {role}\nSalary: ₹{salary:.0f}\nStatus: {status}")
            except Exception as e:
                messagebox.showerror("Database Error", f"Failed to add staff member:\n{str(e)}", parent=w)
        
        # Keyboard shortcuts
        def on_enter_key(event):
            save()
        
        def on_escape_key(event):
            w.destroy()
        
        w.bind('<Return>', on_enter_key)
        w.bind('<Escape>', on_escape_key)
        
        # Buttons frame
        btn_frame = ttk.Frame(frm)
        btn_frame.grid(row=5, column=0, columnspan=2, pady=(10, 0), sticky="ew")
        
        tk.Button(btn_frame, text="Add Staff", command=save,
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=20, pady=6,
                 bg="#16a34a", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Cancel", command=w.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=20, pady=6).pack(side="right")

    def refresh_staff(self):
        """Enhanced refresh staff with filtering and search support"""
        for i in self.staff_tree.get_children():
            self.staff_tree.delete(i)
        
        # Build query with search and filter conditions
        query = "SELECT id, name, role, phone, salary, joined_date, status FROM staff WHERE 1=1"
        params = []
        
        # Apply search filters if they exist
        if hasattr(self, 'search_staff_name_var') and self.search_staff_name_var.get().strip():
            query += " AND name LIKE ?"
            params.append(f"%{self.search_staff_name_var.get().strip()}%")
        
        if hasattr(self, 'search_staff_role_var') and self.search_staff_role_var.get().strip():
            query += " AND role LIKE ?"
            params.append(f"%{self.search_staff_role_var.get().strip()}%")
        
        if hasattr(self, 'filter_staff_status_var') and self.filter_staff_status_var.get() != "All":
            query += " AND status = ?"
            params.append(self.filter_staff_status_var.get())
        
        query += " ORDER BY name"
        
        try:
            rows = self.db.fetchall(query, params)
            for r in rows:
                # Handle missing status column for older data
                try:
                    status = r['status'] if 'status' in r.keys() else "Active"
                except (IndexError, KeyError):
                    status = "Active"
                self.staff_tree.insert("", tk.END, values=(
                    r["id"], r["name"], r["role"], r["phone"], 
                    r["salary"], r["joined_date"], status
                ))
        except Exception as e:
            # Graceful fallback if status column doesn't exist
            try:
                rows = self.db.fetchall("SELECT id, name, role, phone, salary, joined_date FROM staff ORDER BY name")
                for r in rows:
                    self.staff_tree.insert("", tk.END, values=(
                        r["id"], r["name"], r["role"], r["phone"], 
                        r["salary"], r["joined_date"], "Active"
                    ))
            except Exception as inner_e:
                print(f"Error loading staff data: {inner_e}")
        
        # Update statistics
        self.update_staff_statistics()

    def edit_staff_window(self):
        """Enhanced edit staff window with validation"""
        sel = self.staff_tree.selection()
        if not sel:
            messagebox.showwarning("Selection Required", "Please select a staff member to edit")
            return
        
        staff_id = self.staff_tree.item(sel[0])["values"][0]
        try:
            staff = self.db.fetchone("SELECT * FROM staff WHERE id=?", (staff_id,))
            if not staff:
                messagebox.showerror("Error", "Staff member not found")
                return
        except Exception as e:
            messagebox.showerror("Database Error", f"Failed to load staff data:\n{str(e)}")
            return
        
        w = tk.Toplevel(self)
        w.title(f"Edit Staff - {staff['name']}")
        w.geometry("500x450")
        w.resizable(False, False)
        w.grab_set()  # Make modal
        
        frm = ttk.Frame(w, padding=15)
        frm.pack(fill="both", expand=True)
        
        # Staff Name
        ttk.Label(frm, text="Staff Name:", font=("Segoe UI", 9, "bold")).grid(row=0, column=0, sticky="w", pady=(0, 5))
        name_var = tk.StringVar(value=staff['name'])
        name_entry = ttk.Entry(frm, textvariable=name_var, width=45)
        name_entry.grid(row=0, column=1, pady=(0, 10), sticky="ew")
        name_entry.focus_set()
        
        # Role/Position
        ttk.Label(frm, text="Role/Position:", font=("Segoe UI", 9, "bold")).grid(row=1, column=0, sticky="w", pady=(0, 5))
        role_var = tk.StringVar(value=staff['role'])
        role_combo = ttk.Combobox(frm, textvariable=role_var, width=42,
                                 values=["Security Guard", "Maintenance", "Cleaner", "Gardener", "Electrician", "Plumber", "Manager", "Supervisor", "Other"])
        role_combo.grid(row=1, column=1, pady=(0, 10), sticky="ew")
        
        # Phone Number
        ttk.Label(frm, text="Phone Number:", font=("Segoe UI", 9, "bold")).grid(row=2, column=0, sticky="w", pady=(0, 5))
        phone_var = tk.StringVar(value=staff['phone'] if staff['phone'] else '')
        phone_entry = ttk.Entry(frm, textvariable=phone_var, width=45)
        phone_entry.grid(row=2, column=1, pady=(0, 10), sticky="ew")
        
        # Salary
        ttk.Label(frm, text="Monthly Salary (₹):", font=("Segoe UI", 9, "bold")).grid(row=3, column=0, sticky="w", pady=(0, 5))
        salary_var = tk.StringVar(value=str(staff['salary']) if staff['salary'] else '')
        salary_entry = ttk.Entry(frm, textvariable=salary_var, width=45)
        salary_entry.grid(row=3, column=1, pady=(0, 10), sticky="ew")
        
        # Status
        ttk.Label(frm, text="Status:", font=("Segoe UI", 9, "bold")).grid(row=4, column=0, sticky="w", pady=(0, 5))
        try:
            status_value = staff['status'] if 'status' in staff.keys() else 'Active'
        except (IndexError, KeyError):
            status_value = 'Active'
        status_var = tk.StringVar(value=status_value)
        status_combo = ttk.Combobox(frm, textvariable=status_var, 
                                   values=["Active", "Inactive", "On Leave"], 
                                   state="readonly", width=20)
        status_combo.grid(row=4, column=1, pady=(0, 15), sticky="w")
        
        frm.columnconfigure(1, weight=1)
        
        def save():
            name = name_var.get().strip()
            role = role_var.get().strip()
            phone = phone_var.get().strip()
            salary_str = salary_var.get().strip()
            status = status_var.get()
            
            # Validation
            if not name:
                messagebox.showerror("Validation", "Staff name is required", parent=w)
                name_entry.focus_set()
                return
            
            if len(name) < 2:
                messagebox.showerror("Validation", "Name must be at least 2 characters long", parent=w)
                name_entry.focus_set()
                return
            
            if not role:
                messagebox.showerror("Validation", "Role/Position is required", parent=w)
                role_combo.focus_set()
                return
            
            if phone and len(phone) < 10:
                messagebox.showerror("Validation", "Phone number must be at least 10 digits", parent=w)
                phone_entry.focus_set()
                return
            
            try:
                salary = float(salary_str) if salary_str else 0.0
                if salary < 0:
                    messagebox.showerror("Validation", "Salary cannot be negative", parent=w)
                    salary_entry.focus_set()
                    return
            except ValueError:
                messagebox.showerror("Validation", "Please enter a valid salary amount", parent=w)
                salary_entry.focus_set()
                return
            
            try:
                self.db.execute("""
                    UPDATE staff SET name=?, role=?, phone=?, salary=?, status=?
                    WHERE id=?
                """, (name, role, phone, salary, status, staff_id))
                
                w.destroy()
                self.refresh_staff()
                messagebox.showinfo("Success", f"Staff member '{name}' updated successfully!\n\nRole: {role}\nSalary: ₹{salary:.0f}\nStatus: {status}")
            except Exception as e:
                messagebox.showerror("Database Error", f"Failed to update staff member:\n{str(e)}", parent=w)
        
        # Keyboard shortcuts
        def on_enter_key(event):
            save()
        
        def on_escape_key(event):
            w.destroy()
        
        w.bind('<Return>', on_enter_key)
        w.bind('<Escape>', on_escape_key)
        
        # Buttons frame
        btn_frame = ttk.Frame(frm)
        btn_frame.grid(row=5, column=0, columnspan=2, pady=(10, 0), sticky="ew")
        
        tk.Button(btn_frame, text="Update Staff", command=save,
                 font=("Segoe UI", 9, "bold"), relief="raised", bd=1, padx=20, pady=6,
                 bg="#3b82f6", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Cancel", command=w.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=20, pady=6).pack(side="right")

    def delete_staff(self):
        """Delete staff with confirmation"""
        sel = self.staff_tree.selection()
        if not sel:
            messagebox.showwarning("Selection Required", "Please select a staff member to delete")
            return
        
        staff_data = self.staff_tree.item(sel[0])["values"]
        staff_id = staff_data[0]
        staff_name = staff_data[1]
        
        # Confirmation dialog
        result = messagebox.askyesno(
            "Confirm Deletion", 
            f"Are you sure you want to delete staff member '{staff_name}'?\n\n"
            f"This action cannot be undone.",
            icon="warning"
        )
        
        if result:
            try:
                self.db.execute("DELETE FROM staff WHERE id=?", (staff_id,))
                self.refresh_staff()
                messagebox.showinfo("Success", f"Staff member '{staff_name}' has been deleted successfully.")
            except Exception as e:
                messagebox.showerror("Database Error", f"Failed to delete staff member:\n{str(e)}")

    def view_staff_details(self):
        """View detailed staff information"""
        sel = self.staff_tree.selection()
        if not sel:
            messagebox.showwarning("Selection Required", "Please select a staff member to view details")
            return
        
        staff_id = self.staff_tree.item(sel[0])["values"][0]
        try:
            staff = self.db.fetchone("SELECT * FROM staff WHERE id=?", (staff_id,))
            if not staff:
                messagebox.showerror("Error", "Staff member not found")
                return
        except Exception as e:
            messagebox.showerror("Database Error", f"Failed to load staff data:\n{str(e)}")
            return
        
        w = tk.Toplevel(self)
        w.title(f"Staff Details - {staff['name']}")
        w.geometry("450x350")
        w.resizable(False, False)
        w.grab_set()
        
        frm = ttk.Frame(w, padding=20)
        frm.pack(fill="both", expand=True)
        
        # Header
        header_frame = ttk.Frame(frm)
        header_frame.pack(fill="x", pady=(0, 15))
        
        ttk.Label(header_frame, text="👤 Staff Details", font=("Segoe UI", 14, "bold")).pack(side="left")
        
        # Status indicator
        try:
            status = staff['status'] if 'status' in staff.keys() else 'Active'
        except (IndexError, KeyError):
            status = 'Active'
        status_color = {"Active": "#16a34a", "Inactive": "#dc2626", "On Leave": "#f59e0b"}.get(status, "#6b7280")
        status_label = tk.Label(header_frame, text=status, font=("Segoe UI", 9, "bold"), 
                               fg=status_color, bg=w.cget('bg'))
        status_label.pack(side="right")
        
        # Details frame
        details_frame = ttk.Frame(frm)
        details_frame.pack(fill="both", expand=True)
        
        details = [
            ("Staff ID:", staff['id']),
            ("Name:", staff['name']),
            ("Role/Position:", staff['role']),
            ("Phone Number:", staff['phone'] if staff['phone'] else 'Not provided'),
            ("Monthly Salary:", f"₹{staff['salary']:.0f}" if staff['salary'] else '₹0'),
            ("Joined Date:", staff['joined_date'] if staff['joined_date'] else 'Not available'),
            ("Status:", status)
        ]
        
        for i, (label, value) in enumerate(details):
            ttk.Label(details_frame, text=label, font=("Segoe UI", 9, "bold")).grid(
                row=i, column=0, sticky="w", pady=8, padx=(0, 15)
            )
            ttk.Label(details_frame, text=str(value), font=("Segoe UI", 9)).grid(
                row=i, column=1, sticky="w", pady=8
            )
        
        # Action buttons
        btn_frame = ttk.Frame(frm)
        btn_frame.pack(fill="x", pady=(20, 0))
        
        tk.Button(btn_frame, text="Edit Staff", command=lambda: [w.destroy(), self.edit_staff_window()],
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=15, pady=6,
                 bg="#3b82f6", fg="white").pack(side="left", padx=(0, 10))
        
        tk.Button(btn_frame, text="Close", command=w.destroy,
                 font=("Segoe UI", 9), relief="raised", bd=1, padx=15, pady=6).pack(side="right")

    def clear_staff_search(self):
        """Clear all search filters"""
        if hasattr(self, 'search_staff_name_var'):
            self.search_staff_name_var.set('')
        if hasattr(self, 'search_staff_role_var'):
            self.search_staff_role_var.set('')
        if hasattr(self, 'filter_staff_status_var'):
            self.filter_staff_status_var.set('All')
        self.refresh_staff()

    def mark_staff_present(self):
        """Mark selected staff as present/active"""
        sel = self.staff_tree.selection()
        if not sel:
            messagebox.showwarning("Selection Required", "Please select a staff member")
            return
        
        staff_data = self.staff_tree.item(sel[0])["values"]
        staff_id = staff_data[0]
        staff_name = staff_data[1]
        
        try:
            self.db.execute("UPDATE staff SET status='Active' WHERE id=?", (staff_id,))
            self.refresh_staff()
            messagebox.showinfo("Success", f"Staff member '{staff_name}' marked as Present/Active")
        except Exception as e:
            messagebox.showerror("Database Error", f"Failed to update staff status:\n{str(e)}")

    def mark_staff_leave(self):
        """Mark selected staff as on leave"""
        sel = self.staff_tree.selection()
        if not sel:
            messagebox.showwarning("Selection Required", "Please select a staff member")
            return
        
        staff_data = self.staff_tree.item(sel[0])["values"]
        staff_id = staff_data[0]
        staff_name = staff_data[1]
        
        try:
            self.db.execute("UPDATE staff SET status='On Leave' WHERE id=?", (staff_id,))
            self.refresh_staff()
            messagebox.showinfo("Success", f"Staff member '{staff_name}' marked as On Leave")
        except Exception as e:
            messagebox.showerror("Database Error", f"Failed to update staff status:\n{str(e)}")   

    def update_staff_statistics(self):
        """Update staff statistics display"""
        try:
            # Get total staff count
            total_count = self.db.fetchone("SELECT COUNT(*) as count FROM staff")["count"]
            
            # Get active staff count
            active_count = self.db.fetchone("SELECT COUNT(*) as count FROM staff WHERE status='Active'")["count"]
            
            # Get on leave count
            leave_count = self.db.fetchone("SELECT COUNT(*) as count FROM staff WHERE status='On Leave'")["count"]
            
            # Get total salary
            total_salary = self.db.fetchone("SELECT COALESCE(SUM(salary), 0) as total FROM staff WHERE status='Active'")["total"]
            
            # Update labels if they exist
            if hasattr(self, 'staff_stats_labels'):
                self.staff_stats_labels['total'].config(text=f"Total Staff: {total_count}")
                self.staff_stats_labels['active'].config(text=f"Active: {active_count}")
                self.staff_stats_labels['on_leave'].config(text=f"On Leave: {leave_count}")
                self.staff_stats_labels['total_salary'].config(text=f"Total Salary: ₹{total_salary:.0f}")
        except Exception as e:
            print(f"Error updating staff statistics: {e}")

    def refresh_parking(self):
        """Refresh parking data in the treeview and update statistics"""
        # Clear existing items
        for item in self.parking_tree.get_children():
            self.parking_tree.delete(item)
        
        # Fetch parking data with member information
        rows = self.db.fetchall("""
            SELECT p.slot_no, m.name as member_name, m.flat_no, p.vehicle_number, 
                   p.vehicle_model, p.allocated_date
            FROM parking p
            LEFT JOIN members m ON p.member_id = m.id
            ORDER BY p.slot_no
        """)
        
        # Insert data into treeview
        for row in rows:
            self.parking_tree.insert("", tk.END, values=(
                row["slot_no"],
                row["member_name"] or "N/A",
                row["flat_no"] or "N/A",
                row["vehicle_number"] or "N/A",
                row["vehicle_model"] or "N/A",
                row["allocated_date"] or "N/A"
            ))
        
        # Update statistics
        self.update_parking_statistics()
    
    def search_parking(self):
        """Search parking slots based on filter criteria"""
        # Clear existing items
        for item in self.parking_tree.get_children():
            self.parking_tree.delete(item)
        
        # Get filter values
        slot_filter = self.parking_search_slot_var.get().strip()
        member_filter = self.parking_search_member_var.get().strip()
        vehicle_filter = self.parking_search_vehicle_var.get().strip()
        
        # Build query based on filters
        base_query = """
            SELECT p.slot_no, m.name as member_name, m.flat_no, p.vehicle_number, 
                   p.vehicle_model, p.allocated_date
            FROM parking p
            LEFT JOIN members m ON p.member_id = m.id
        """
        
        conditions = []
        params = []
        
        if slot_filter:
            conditions.append("p.slot_no LIKE ?")
            params.append(f"%{slot_filter}%")
            
        if member_filter:
            conditions.append("m.name LIKE ?")
            params.append(f"%{member_filter}%")
            
        if vehicle_filter:
            conditions.append("p.vehicle_number LIKE ?")
            params.append(f"%{vehicle_filter}%")
        
        if conditions:
            query = base_query + " WHERE " + " AND ".join(conditions)
        else:
            query = base_query
            
        query += " ORDER BY p.slot_no"
        
        # Execute query
        rows = self.db.fetchall(query, tuple(params))
        
        # Insert data into treeview
        for row in rows:
            self.parking_tree.insert("", tk.END, values=(
                row["slot_no"],
                row["member_name"] or "N/A",
                row["flat_no"] or "N/A",
                row["vehicle_number"] or "N/A",
                row["vehicle_model"] or "N/A",
                row["allocated_date"] or "N/A"
            ))
    
    def clear_parking_search(self):
        """Clear all parking search filters"""
        self.parking_search_slot_var.set("")
        self.parking_search_member_var.set("")
        self.parking_search_vehicle_var.set("")
        self.refresh_parking()
    
    def update_parking_statistics(self):
        """Update parking statistics display with enhanced information"""
        try:
            # Total slots
            total_slots = self.db.fetchone("SELECT COUNT(*) as count FROM parking")["count"]
            
            # Allocated slots
            allocated_slots = self.db.fetchone("SELECT COUNT(*) as count FROM parking WHERE member_id IS NOT NULL")["count"]
            
            # Free slots
            free_slots = total_slots - allocated_slots
            
            # Calculate utilization percentage
            utilization = (allocated_slots / total_slots * 100) if total_slots > 0 else 0
            
            # Update labels with enhanced formatting and color coding
            if hasattr(self, 'parking_stats_labels'):
                self.parking_stats_labels['total'].config(text=f"Total Slots: {total_slots}")
                self.parking_stats_labels['allocated'].config(text=f"Allocated: {allocated_slots} ({utilization:.1f}%)", foreground="#dc2626")
                self.parking_stats_labels['free'].config(text=f"Free: {free_slots} ({100-utilization:.1f}%)", foreground="#16a34a")
        except Exception as e:
            print(f"Error updating parking statistics: {e}")

                
    def allocate_parking_window(self):
        """Open window to allocate a parking slot to a member with enhanced UI"""
        w = tk.Toplevel(self)
        w.title("🅿️ Allocate Parking Slot")
        w.geometry("520x450")
        w.resizable(False, False)
        w.grab_set()
        
        # Main frame with better styling
        main_frame = ttk.Frame(w, padding=20)
        main_frame.pack(fill="both", expand=True)
        
        # Header with better formatting
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill="x", pady=(0, 20))
        
        ttk.Label(header_frame, text="🅿️ Allocate Parking Slot", font=("Segoe UI", 16, "bold")).pack(side="left")
        ttk.Label(header_frame, text="Assign a parking slot to a member", 
                 font=("Segoe UI", 10), foreground="#6b7280").pack(side="right")
        
        # Form frame with better organization
        form_frame = ttk.LabelFrame(main_frame, text="Allocation Details", padding=15)
        form_frame.pack(fill="both", expand=True)
        
        # Slot number with better styling
        ttk.Label(form_frame, text="Slot Number:", font=("Segoe UI", 9, "bold")).grid(row=0, column=0, sticky="w", pady=(0, 12))
        slot_var = tk.StringVar()
        slot_entry = ttk.Entry(form_frame, textvariable=slot_var, width=35, font=("Segoe UI", 10))
        slot_entry.grid(row=0, column=1, sticky="ew", pady=(0, 12))
        slot_entry.focus_set()
        
        # Member selection with better styling
        ttk.Label(form_frame, text="Member:", font=("Segoe UI", 9, "bold")).grid(row=1, column=0, sticky="w", pady=(0, 12))
        member_var = tk.StringVar()
        member_cb = ttk.Combobox(form_frame, textvariable=member_var, values=list(self.member_dropdown_for_parking.keys()), 
                                state="readonly", width=33, font=("Segoe UI", 10))
        member_cb.grid(row=1, column=1, sticky="ew", pady=(0, 12))
        
        # Vehicle number with better styling
        ttk.Label(form_frame, text="Vehicle Number:", font=("Segoe UI", 9, "bold")).grid(row=2, column=0, sticky="w", pady=(0, 12))
        vehicle_no_var = tk.StringVar()
        ttk.Entry(form_frame, textvariable=vehicle_no_var, width=35, font=("Segoe UI", 10)).grid(row=2, column=1, sticky="ew", pady=(0, 12))
        
        # Vehicle model with better styling
        ttk.Label(form_frame, text="Vehicle Model:", font=("Segoe UI", 9, "bold")).grid(row=3, column=0, sticky="w", pady=(0, 12))
        vehicle_model_var = tk.StringVar()
        ttk.Entry(form_frame, textvariable=vehicle_model_var, width=35, font=("Segoe UI", 10)).grid(row=3, column=1, sticky="ew", pady=(0, 12))
        
        # Allocated date with better styling
        ttk.Label(form_frame, text="Allocated Date:", font=("Segoe UI", 9, "bold")).grid(row=4, column=0, sticky="w", pady=(0, 12))
        date_frame = ttk.Frame(form_frame)
        date_frame.grid(row=4, column=1, sticky="ew", pady=(0, 12))
        
        allocated_date_var = tk.StringVar(value=datetime.now().strftime("%d-%m-%Y"))
        date_entry = ttk.Entry(date_frame, textvariable=allocated_date_var, width=18, font=("Segoe UI", 10))
        date_entry.pack(side="left")
        
        # Date picker button with better styling
        def pick_date():
            try:
                from tkcalendar import DateEntry
                cal_window = tk.Toplevel(w)
                cal_window.title("Select Date")
                cal_window.geometry("300x250")
                cal_window.transient(w)
                cal_window.grab_set()
                
                cal = DateEntry(cal_window, date_pattern='dd-mm-yyyy', width=12, 
                               background='darkblue', foreground='white', borderwidth=2, font=("Segoe UI", 10))
                cal.pack(pady=20)
                
                def set_date():
                    allocated_date_var.set(cal.get_date().strftime("%d-%m-%Y"))
                    cal_window.destroy()
                
                ttk.Button(cal_window, text="Select", command=set_date, style="Accent.TButton").pack(pady=10)
            except ImportError:
                messagebox.showwarning("Date Picker", "Calendar widget not available. Please enter date manually (DD-MM-YYYY).", parent=w)
        
        ttk.Button(date_frame, text="📅 Calendar", command=pick_date, style="Small.TButton").pack(side="left", padx=(10, 0))
        
        # Configure grid
        form_frame.columnconfigure(1, weight=1)
        
        def save_allocation():
            slot_no = slot_var.get().strip().upper()
            member_selection = member_var.get().strip()
            vehicle_number = vehicle_no_var.get().strip().upper()
            vehicle_model = vehicle_model_var.get().strip()
            allocated_date = allocated_date_var.get().strip()
            
            # Validation with better user guidance
            if not slot_no:
                messagebox.showerror("Validation Error", "Slot number is required", parent=w)
                slot_entry.focus_set()
                return
                
            if not member_selection:
                messagebox.showerror("Validation Error", "Please select a member", parent=w)
                member_cb.focus_set()
                return
                
            if not vehicle_number:
                messagebox.showerror("Validation Error", "Vehicle number is required", parent=w)
                return
                
            # Validate date format
            try:
                datetime.strptime(allocated_date, "%d-%m-%Y")
            except ValueError:
                messagebox.showerror("Validation Error", "Invalid date format. Please use DD-MM-YYYY", parent=w)
                return
            
            # Check if slot is already allocated
            existing = self.db.fetchone("SELECT slot_no FROM parking WHERE slot_no=?", (slot_no,))
            if existing:
                messagebox.showerror("Allocation Error", f"Slot {slot_no} is already allocated", parent=w)
                slot_entry.focus_set()
                return
            
            # Get member ID
            member_id = self.member_dropdown_for_parking.get(member_selection)
            if not member_id:
                messagebox.showerror("Error", "Invalid member selection", parent=w)
                return
            
            try:
                # Insert parking allocation
                self.db.execute("""
                    INSERT INTO parking (slot_no, member_id, vehicle_number, vehicle_model, allocated_date)
                    VALUES (?, ?, ?, ?, ?)
                """, (slot_no, member_id, vehicle_number, vehicle_model, allocated_date))
                
                messagebox.showinfo("Success", f"🅿️ Parking slot {slot_no} successfully allocated to\n{member_selection}", parent=w)
                w.destroy()
                self.refresh_parking()
            except Exception as e:
                messagebox.showerror("Database Error", f"Failed to allocate parking slot:\n{str(e)}", parent=w)
        
        # Keyboard shortcuts
        def on_enter_key(event):
            save_allocation()
        
        def on_escape_key(event):
            w.destroy()
        
        w.bind("<Return>", on_enter_key)
        w.bind("<Escape>", on_escape_key)
        
        # Buttons with better styling and organization
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill="x", pady=(20, 0))
        
        ttk.Button(button_frame, text="Allocate Slot", command=save_allocation, 
                  style="Accent.TButton").pack(side="left", padx=(0, 10))
        ttk.Button(button_frame, text="Cancel", command=w.destroy, style="Small.TButton").pack(side="left")
        
        # Help text with better formatting
        ttk.Label(main_frame, text="💡 Tip: Press Enter to save, Escape to cancel", 
                 font=("Segoe UI", 8), foreground="#6b7280").pack(anchor="w", pady=(15, 0))
    
    def free_parking_slot(self):
        """Free/Release a parking slot"""
        selection = self.parking_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select a parking slot to free")
            return
        
        # Get selected item details
        item = self.parking_tree.item(selection[0])
        slot_no = item["values"][0]
        member_name = item["values"][1]
        
        # Confirm action
        if not messagebox.askyesno("Confirm", f"Are you sure you want to free parking slot {slot_no} allocated to {member_name}?"):
            return
        
        try:
            # Update the parking record to remove member association
            self.db.execute("""
                UPDATE parking 
                SET member_id = NULL, vehicle_number = NULL, vehicle_model = NULL, allocated_date = NULL
                WHERE slot_no = ?
            """, (slot_no,))
            
            messagebox.showinfo("Success", f"Parking slot {slot_no} has been freed successfully")
            self.refresh_parking()
        except Exception as e:
            messagebox.showerror("Database Error", f"Failed to free parking slot:\n{str(e)}")
    
    def delete_parking_slot(self):
        """Permanently delete a parking slot record"""
        selection = self.parking_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "कृपया पहले कोई पार्किंग स्लॉट चुनें")
            return

        item = self.parking_tree.item(selection[0])
        slot_no = item["values"][0]

        if not messagebox.askyesno(
            "Confirm Delete",
            f"क्या आप वाक़ई पार्किंग स्लॉट {slot_no} को स्थायी रूप से हटाना चाहते हैं? \nइससे संबंधित सभी जानकारी मिट जाएगी।",
        ):
            return

        try:
            self.db.execute("DELETE FROM parking WHERE slot_no = ?", (slot_no,))
            messagebox.showinfo("Deleted", f"स्लॉट {slot_no} सफलतापूर्वक हटाया गया।")
            self.refresh_parking()
        except Exception as e:
            messagebox.showerror("Database Error", f"स्लॉट हटाने में त्रुटि:\n{str(e)}")

    def free_parking_slot_direct(self, slot_no):
        """Directly free a parking slot (used for member deletion)"""
        try:
            self.db.execute("""
                UPDATE parking 
                SET member_id = NULL, vehicle_number = NULL, vehicle_model = NULL, allocated_date = NULL
                WHERE slot_no = ?
            """, (slot_no,))
        except Exception as e:
            print(f"Error freeing parking slot {slot_no}: {e}")

    def view_parking_details(self, event=None):
        """View detailed information about a parking slot"""
        selection = self.parking_tree.selection()
        if not selection:
            messagebox.showwarning("Selection Required", "Please select a parking slot to view details")
            return
        
        # Get selected item details
        item = self.parking_tree.item(selection[0])
        slot_no = item["values"][0]
        
        # Fetch full parking details
        parking_data = self.db.fetchone("""
            SELECT p.slot_no, m.name as member_name, m.flat_no, m.phone, 
                   p.vehicle_number, p.vehicle_model, p.allocated_date
            FROM parking p
            LEFT JOIN members m ON p.member_id = m.id
            WHERE p.slot_no = ?
        """, (slot_no,))
        
        if not parking_data:
            messagebox.showerror("Error", "Parking slot not found")
            return
        
        # Create details window
        w = tk.Toplevel(self)
        w.title(f"Parking Slot Details - {slot_no}")
        w.geometry("550x450")
        w.resizable(False, False)
        w.grab_set()
        
        # Main frame
        main_frame = ttk.Frame(w, padding=15)
        main_frame.pack(fill="both", expand=True)
        
        # Header with icon
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill="x", pady=(0, 15))
        
        ttk.Label(header_frame, text=f"🅿️ Parking Slot: {slot_no}", font=("Segoe UI", 16, "bold")).pack(side="left")
        
        # Status indicator
        status = "Allocated" if parking_data["member_name"] else "Free"
        status_color = "#16a34a" if status == "Allocated" else "#dc2626"
        status_bg = "#dcfce7" if status == "Allocated" else "#fee2e2"
        
        status_label = tk.Label(header_frame, text=status, font=("Segoe UI", 10, "bold"), 
                               fg=status_color, bg=status_bg, padx=10, pady=5, relief="solid", bd=1)
        status_label.pack(side="right")
        
        # Details grid
        details_frame = ttk.LabelFrame(main_frame, text="Slot Information", padding=15)
        details_frame.pack(fill="both", expand=True)
        
        # Create grid layout for details
        row = 0
        
        if parking_data["member_name"]:
            # Member Information Section
            member_frame = ttk.LabelFrame(details_frame, text="Member Information", padding=10)
            member_frame.grid(row=row, column=0, columnspan=2, sticky="ew", pady=(0, 15))
            member_frame.columnconfigure(1, weight=1)
            
            ttk.Label(member_frame, text="Member Name:", font=("Segoe UI", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3)
            ttk.Label(member_frame, text=f"{parking_data['member_name']} ({parking_data['flat_no'] or 'N/A'})", 
                     font=("Segoe UI", 9)).grid(row=0, column=1, sticky="w", pady=3, padx=(10, 0))
            
            ttk.Label(member_frame, text="Phone:", font=("Segoe UI", 9, "bold")).grid(row=1, column=0, sticky="w", pady=3)
            ttk.Label(member_frame, text=parking_data["phone"] or "N/A", font=("Segoe UI", 9)).grid(row=1, column=1, sticky="w", pady=3, padx=(10, 0))
            
            row += 1
            
            # Vehicle Information Section
            vehicle_frame = ttk.LabelFrame(details_frame, text="Vehicle Information", padding=10)
            vehicle_frame.grid(row=row, column=0, columnspan=2, sticky="ew", pady=(0, 15))
            vehicle_frame.columnconfigure(1, weight=1)
            
            ttk.Label(vehicle_frame, text="Vehicle Number:", font=("Segoe UI", 9, "bold")).grid(row=0, column=0, sticky="w", pady=3)
            ttk.Label(vehicle_frame, text=parking_data["vehicle_number"] or "N/A", font=("Segoe UI", 9)).grid(row=0, column=1, sticky="w", pady=3, padx=(10, 0))
            
            ttk.Label(vehicle_frame, text="Vehicle Model:", font=("Segoe UI", 9, "bold")).grid(row=1, column=0, sticky="w", pady=3)
            ttk.Label(vehicle_frame, text=parking_data["vehicle_model"] or "N/A", font=("Segoe UI", 9)).grid(row=1, column=1, sticky="w", pady=3, padx=(10, 0))
            
            ttk.Label(vehicle_frame, text="Allocated Date:", font=("Segoe UI", 9, "bold")).grid(row=2, column=0, sticky="w", pady=3)
            ttk.Label(vehicle_frame, text=parking_data["allocated_date"] or "N/A", font=("Segoe UI", 9)).grid(row=2, column=1, sticky="w", pady=3, padx=(10, 0))
            
            row += 1
        else:
            # Free slot message
            info_frame = ttk.Frame(details_frame)
            info_frame.grid(row=0, column=0, columnspan=2, pady=20)
            
            ttk.Label(info_frame, text="🅿️ This parking slot is currently available", 
                     font=("Segoe UI", 12, "bold"), foreground="#16a34a").pack()
            ttk.Label(info_frame, text="No vehicle is currently assigned to this slot", 
                     font=("Segoe UI", 10)).pack(pady=(5, 0))
        
        # Buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill="x", pady=(15, 0))
        
        if parking_data["member_name"]:
            ttk.Button(button_frame, text="Free Slot", command=lambda: [w.destroy(), self._confirm_free_slot(slot_no)], 
                      style="Small.TButton").pack(side="left", padx=(0, 10))
        else:
            ttk.Button(button_frame, text="Allocate Slot", command=lambda: [w.destroy(), self.allocate_parking_window()], 
                      style="Accent.TButton").pack(side="left", padx=(0, 10))
        
        ttk.Button(button_frame, text="Close", command=w.destroy).pack(side="right")
    
    def _confirm_free_slot(self, slot_no):
        """Confirm and free a parking slot"""
        if messagebox.askyesno("Confirm", f"Are you sure you want to free parking slot {slot_no}?"):
            try:
                self.db.execute("""
                    UPDATE parking 
                    SET member_id = NULL, vehicle_number = NULL, vehicle_model = NULL, allocated_date = NULL
                    WHERE slot_no = ?
                """, (slot_no,))
                
                messagebox.showinfo("Success", f"Parking slot {slot_no} has been freed successfully")
                self.refresh_parking()
            except Exception as e:
                messagebox.showerror("Database Error", f"Failed to free parking slot:\n{str(e)}")

    def export_staff_csv(self):
        """Export staff details to CSV"""
        # existing implementation ...

    def print_total_staff(self):
        """Show dialog with total staff count and offer print option"""
        total = self.db.fetchone("SELECT COUNT(*) as c FROM staff")['c']
        # Simple dialog
        msg = f"Total Staff Members: {total}"
        if messagebox.askyesno("Print", msg + "\n\nPrint this information?"):
            try:
                # Create a temporary PDF file for printing
                import tempfile, os
                with tempfile.NamedTemporaryFile('wb', delete=False, suffix='.pdf') as tmp:
                    temp_path = tmp.name
                # Generate PDF with full staff details
                from reportlab.pdfgen import canvas
                from reportlab.lib.pagesizes import A4
                from reportlab.lib.units import inch

                staff_rows = self.db.fetchall("SELECT * FROM staff")

                pdf = canvas.Canvas(temp_path, pagesize=A4)
                width, height = A4
                margin = 0.75 * inch
                y = height - margin

                pdf.setFont("Helvetica-Bold", 16)
                pdf.drawString(margin, y, "Staff Details Report")
                y -= 0.4 * inch

                pdf.setFont("Helvetica", 12)
                pdf.drawString(margin, y, f"Total Staff Members: {total}")
                y -= 0.3 * inch

                # Table header (assuming common columns)
                headers = list(staff_rows[0].keys()) if staff_rows else []
                col_width = (width - 2 * margin) / (len(headers) if headers else 1)
                pdf.setFont("Helvetica-Bold", 10)
                for idx, h in enumerate(headers):
                    pdf.drawString(margin + idx * col_width, y, str(h).replace("_", " ").title())
                y -= 0.25 * inch
                pdf.setFont("Helvetica", 10)

                for row in staff_rows:
                    if y < margin:
                        pdf.showPage()
                        y = height - margin
                        pdf.setFont("Helvetica-Bold", 10)
                        for idx, h in enumerate(headers):
                            pdf.drawString(margin + idx * col_width, y, str(h).replace("_", " ").title())
                        y -= 0.25 * inch
                        pdf.setFont("Helvetica", 10)
                    for idx, h in enumerate(headers):
                        pdf.drawString(margin + idx * col_width, y, str(row[h]))
                    y -= 0.22 * inch

                pdf.save()
                # Open the generated PDF in the system's default viewer (user can print from there)
                open_file_in_default_app(temp_path)
            except Exception as e:
                messagebox.showerror("Print Error", str(e))


    # --- Inventory ---
    def add_inventory_window(self):
        w = tk.Toplevel(self)
        w.title("Add Inventory Item")
        w.geometry("420x300")
        frm = ttk.Frame(w, padding=12)
        frm.pack(fill="both", expand=True)
        ttk.Label(frm, text="Item Name:").grid(row=0, column=0, sticky="w", pady=6)
        name = tk.StringVar()
        ttk.Entry(frm, textvariable=name, width=36).grid(row=0, column=1, pady=6)
        ttk.Label(frm, text="Quantity:").grid(row=1, column=0, sticky="w", pady=6)
        qty = tk.IntVar(value=0)
        ttk.Entry(frm, textvariable=qty).grid(row=1, column=1, pady=6)
        ttk.Label(frm, text="Unit:").grid(row=2, column=0, sticky="w", pady=6)
        unit = tk.StringVar()
        ttk.Entry(frm, textvariable=unit).grid(row=2, column=1, pady=6)
        ttk.Label(frm, text="Min Required:").grid(row=3, column=0, sticky="w", pady=6)
        minreq = tk.IntVar(value=0)
        ttk.Entry(frm, textvariable=minreq).grid(row=3, column=1, pady=6)

        def save():
            if not name.get().strip():
                messagebox.showerror("Validation", "Item name required", parent=w)
                return
            self.db.execute("INSERT INTO inventory (item_name, quantity, unit, min_required) VALUES (?, ?, ?, ?)",
                            (name.get().strip(), int(qty.get()), unit.get().strip(), int(minreq.get())))
            w.destroy()
            self.refresh_inventory()

        ttk.Button(frm, text="Add", command=save, style="Accent.TButton").grid(row=4, column=0, columnspan=2, sticky="ew", pady=6)

    def use_inventory_window(self):
        sel = self.inventory_tree.selection()
        if not sel:
            messagebox.showwarning("Select", "Select an item")
            return
        inv_id = self.inventory_tree.item(sel[0])["values"][0]
        row = self.db.fetchone("SELECT * FROM inventory WHERE id=?", (inv_id,))
        if not row:
            messagebox.showerror("Not found", "Item not found")
            return
        w = tk.Toplevel(self)
        w.title("Use Inventory")
        w.geometry("420x240")
        frm = ttk.Frame(w, padding=12)
        frm.pack(fill="both", expand=True)
        ttk.Label(frm, text=f"Item: {row['item_name']} (Available: {row['quantity']})").grid(row=0, column=0, columnspan=2, sticky="w", pady=6)
        ttk.Label(frm, text="Quantity to use:").grid(row=1, column=0, sticky="w", pady=6)
        qv = tk.IntVar(value=1)
        ttk.Entry(frm, textvariable=qv).grid(row=1, column=1, pady=6)
        ttk.Label(frm, text="Note:").grid(row=2, column=0, sticky="w", pady=6)
        note = tk.StringVar()
        ttk.Entry(frm, textvariable=note).grid(row=2, column=1, pady=6)

        def use():
            q = int(qv.get())
            if q <= 0:
                messagebox.showerror("Validation", "Quantity > 0", parent=w)
                return
            new_qty = row["quantity"] - q
            self.db.execute("UPDATE inventory SET quantity=? WHERE id=?", (new_qty, inv_id))
            self.db.execute("INSERT INTO inventory_usage (inventory_id, quantity, date, note) VALUES (?, ?, ?, ?)",
                            (inv_id, q, date.today(), note.get().strip()))

    def use_inventory_window_enhanced(self):
        """Enhanced inventory usage window with flat and event tracking"""
        sel = self.inventory_tree.selection()
        if not sel:
            messagebox.showwarning("Select", "Please select an inventory item to use")
            return
        inv_id = self.inventory_tree.item(sel[0])["values"][0]
        row = self.db.fetchone("SELECT * FROM inventory WHERE id=?", (inv_id,))
        if not row:
            messagebox.showerror("Not found", "Item not found")
            return
            
        w = tk.Toplevel(self)
        w.title("Use Inventory Item")
        w.geometry("450x350")
        w.resizable(False, False)
        w.grab_set()
        
        frm = ttk.Frame(w, padding=15)
        frm.pack(fill="both", expand=True)
        
        # Item info
        ttk.Label(frm, text=f"Item: {row['item_name']} (Available: {row['quantity']})", 
                 font=("Segoe UI", 10, "bold")).grid(row=0, column=0, columnspan=3, sticky="w", pady=(0, 10))
        
        # Quantity
        ttk.Label(frm, text="Quantity to use:", font=("Segoe UI", 9)).grid(row=1, column=0, sticky="w", pady=5)
        qty_var = tk.StringVar(value="1")
        qty_entry = ttk.Entry(frm, textvariable=qty_var, width=15)
        qty_entry.grid(row=1, column=1, sticky="w", pady=5)
        qty_entry.focus_set()
        
        # Usage type selection
        ttk.Label(frm, text="Usage Type:", font=("Segoe UI", 9)).grid(row=2, column=0, sticky="w", pady=(10, 5))
        usage_type_var = tk.StringVar(value="General")
        usage_type_frame = ttk.Frame(frm)
        usage_type_frame.grid(row=2, column=1, columnspan=2, sticky="w", pady=(10, 5))
        
        ttk.Radiobutton(usage_type_frame, text="General Use", variable=usage_type_var, 
                       value="General").pack(anchor="w")
        ttk.Radiobutton(usage_type_frame, text="Flat Usage", variable=usage_type_var, 
                       value="Flat").pack(anchor="w")
        ttk.Radiobutton(usage_type_frame, text="Event Usage", variable=usage_type_var, 
                       value="Event").pack(anchor="w")
        
        # Dynamic fields based on usage type
        dynamic_frame = ttk.Frame(frm)
        dynamic_frame.grid(row=3, column=0, columnspan=3, sticky="ew", pady=10)
        frm.columnconfigure(2, weight=1)
        
        # Flat selection (initially hidden)
        flat_frame = ttk.Frame(dynamic_frame)
        flat_label = ttk.Label(flat_frame, text="Flat Number:", font=("Segoe UI", 9))
        flat_label.pack(anchor="w")
        flat_var = tk.StringVar()
        flat_entry = ttk.Entry(flat_frame, textvariable=flat_var, width=20)
        
        # Event selection (initially hidden)
        event_frame = ttk.Frame(dynamic_frame)
        event_label = ttk.Label(event_frame, text="Event Name:", font=("Segoe UI", 9))
        event_label.pack(anchor="w")
        event_var = tk.StringVar()
        event_entry = ttk.Entry(event_frame, textvariable=event_var, width=30)
        
        def update_dynamic_fields(*args):
            # Clear previous widgets
            for widget in dynamic_frame.winfo_children():
                widget.pack_forget()
                
            usage_type = usage_type_var.get()
            if usage_type == "Flat":
                flat_frame.pack(fill="x", pady=5)
                flat_label.pack(anchor="w")
                flat_entry.pack(anchor="w", pady=(2, 0))
            elif usage_type == "Event":
                event_frame.pack(fill="x", pady=5)
                event_label.pack(anchor="w")
                event_entry.pack(anchor="w", pady=(2, 0))
        
        usage_type_var.trace_add('write', update_dynamic_fields)
        
        # Note
        ttk.Label(frm, text="Additional Note:", font=("Segoe UI", 9)).grid(row=4, column=0, sticky="nw", pady=5)
        note_text = tk.Text(frm, height=4, width=40, wrap="word")
        note_text.grid(row=4, column=1, columnspan=2, sticky="ew", pady=5)
        
        def use_item():
            try:
                qty = int(qty_var.get())
                if qty <= 0:
                    messagebox.showerror("Validation", "Quantity must be greater than 0", parent=w)
                    return
                    
                if qty > row["quantity"]:
                    messagebox.showerror("Validation", 
                                       f"Insufficient quantity. Available: {row['quantity']}", parent=w)
                    return
                    
                # Build note based on usage type
                note_parts = []
                usage_type = usage_type_var.get()
                
                if usage_type == "Flat":
                    flat_no = flat_var.get().strip()
                    if not flat_no:
                        messagebox.showerror("Validation", "Please enter flat number", parent=w)
                        return
                    note_parts.append(f"Flat {flat_no}")
                elif usage_type == "Event":
                    event_name = event_var.get().strip()
                    if not event_name:
                        messagebox.showerror("Validation", "Please enter event name", parent=w)
                        return
                    note_parts.append(f"Event: {event_name}")
                
                # Add additional note if provided
                additional_note = note_text.get("1.0", tk.END).strip()
                if additional_note:
                    note_parts.append(additional_note)
                
                note = " | ".join(note_parts) if note_parts else "General usage"
                
                # Update inventory quantity
                new_qty = row["quantity"] - qty
                self.db.execute("UPDATE inventory SET quantity=? WHERE id=?", (new_qty, inv_id))
                
                # Log usage
                self.db.execute("INSERT INTO inventory_usage (inventory_id, quantity, date, note) VALUES (?, ?, ?, ?)",
                               (inv_id, qty, date.today(), note))
                
                w.destroy()
                self.refresh_inventory_tab()
                messagebox.showinfo("Success", f"Used {qty} units of {row['item_name']}")
                
            except ValueError:
                messagebox.showerror("Validation", "Please enter a valid quantity", parent=w)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to use inventory item:\n{str(e)}", parent=w)
        
        # Buttons
        button_frame = ttk.Frame(frm)
        button_frame.grid(row=5, column=0, columnspan=3, pady=(15, 0), sticky="ew")
        
        ttk.Button(button_frame, text="Use Item", command=use_item, style="Accent.TButton").pack(side="left", padx=(0, 10))
        ttk.Button(button_frame, text="Cancel", command=w.destroy, style="Small.TButton").pack(side="left")
        
        # Initialize dynamic fields
        update_dynamic_fields()

    # --- Refresh and Dashboard update ---

    def _parse_date(self, value):
        """Robust parsing for dates stored in DB. Returns a datetime.date or None."""
        if value is None:
            return None
        if isinstance(value, date):
            return value
        s = str(value).strip()
        if not s:
            return None
        # try known formats
        for fmt in ("%d-%m-%Y", "%Y-%m-%d", "%d/%m/%Y"):
            try:
                return datetime.strptime(s, fmt).date()
            except Exception:
                continue
        # fallback: try to extract numbers and attempt Y-M-D
        try:
            # if ISO with time
            return datetime.fromisoformat(s).date()
        except Exception:
            return None

    def refresh_all(self):
        self.refresh_members()
        self.refresh_payments()  # Simplified call without filter parameters
        self.refresh_complaints()
        self.refresh_events()
        self.refresh_staff()
        self.refresh_inventory()
        self.update_dashboard()

    def calculate_dues_for_member(self, member_id, monthly_rent, last_payment_date, time_period_filter):
        due_amount = 0.0
        today = date.today()

        if not last_payment_date:
            # If no last payment, all months since join_date are due
            member_join_date_row = self.db.fetchone("SELECT join_date FROM members WHERE id=?", (member_id,))
            if member_join_date_row:
                if isinstance(member_join_date_row["join_date"], str):
                    # join_date may be stored as YYYY-MM-DD or date object
                    try:
                        join_date = datetime.strptime(member_join_date_row["join_date"], "%Y-%m-%d").date()
                    except Exception:
                        try:
                            join_date = datetime.strptime(member_join_date_row["join_date"], "%d-%m-%Y").date()
                        except Exception:
                            # fallback to today
                            join_date = date.today()
                else:
                    join_date = member_join_date_row["join_date"]
                
                # Calculate months passed since join_date
                months_passed = (today.year - join_date.year) * 12 + (today.month - join_date.month)
                
                # If join_date is in the future or current month, no dues yet
                if months_passed < 0:
                    months_passed = 0
                elif today.day < join_date.day: # If current day is before join day, don't count current month
                    months_passed -= 1
                
                if time_period_filter == "Monthly":
                    # If monthly filter, only consider if current month is due
                    if months_passed >= 0:
                        due_amount = monthly_rent  # Only current month's rent
                    else:
                        due_amount = 0.0
                elif time_period_filter == "Yearly":
                    # If yearly filter, consider all months passed in the current year
                    current_year_months_due = (today.year - join_date.year) * 12 + (today.month - join_date.month)
                    if today.day < join_date.day:
                        current_year_months_due -= 1
                    
                    if current_year_months_due > 0:
                        due_amount = monthly_rent * current_year_months_due
                    else:
                        due_amount = 0.0
                else: # All or no filter
                    # As per user request: due amount = total outstanding amount
                    # In this case, that's all months passed * monthly rent
                    due_amount = monthly_rent * months_passed
        else:
            # last_payment_date might be a date or string
            if isinstance(last_payment_date, str):
                try:
                    last_payment_date = datetime.strptime(last_payment_date, "%d-%m-%Y").date()
                except Exception:
                    try:
                        last_payment_date = datetime.strptime(last_payment_date, "%Y-%m-%d").date()
                    except Exception:
                        last_payment_date = None
    
            if last_payment_date is None:
                # fallback: treat as no last payment
                return self.calculate_dues_for_member(member_id, monthly_rent, None, time_period_filter)
            
            # Calculate months since last payment
            months_since_last_payment = (today.year - last_payment_date.year) * 12 + (today.month - last_payment_date.month)
            if today.day < last_payment_date.day:
                months_since_last_payment -= 1
        
            if months_since_last_payment < 0: # Payment in future or current month already paid
                months_since_last_payment = 0

            if time_period_filter == "Monthly":
                if months_since_last_payment > 0:
                    due_amount = monthly_rent  # Only current month's rent
                else:
                    due_amount = 0.0
            elif time_period_filter == "Yearly":
                # Calculate dues for the current year only
                current_year_start = date(today.year, 1, 1)
                if last_payment_date < current_year_start:
                    # If last payment was before current year, calculate from Jan of current year
                    months_to_consider = (today.year - current_year_start.year) * 12 + (today.month - current_year_start.month)
                    if today.day < current_year_start.day:
                        months_to_consider -= 1
                    due_amount = monthly_rent * months_to_consider
                else:
                    # If last payment was in current year, calculate from month after last payment
                    months_to_consider = (today.year - last_payment_date.year) * 12 + (today.month - last_payment_date.month)
                    if today.day < last_payment_date.day:
                        months_to_consider -= 1
                    due_amount = monthly_rent * months_to_consider
            else: # All or no filter
                # As per user request: due amount = total outstanding amount
                # In this case, that's months since last payment * monthly rent
                due_amount = monthly_rent * months_since_last_payment

        return due_amount

    def update_dashboard(self):
        # Get filter values from UI components with proper defaults
        member_type_filter = "All"
        payment_status_filter = "All"
        payment_type_filter = "All"
        fdt = tdt = None
        
        # Get the selected filter category and corresponding values
        if hasattr(self, "filter_category_var"):
            cat = self.filter_category_var.get()
            
            if cat == "Time Period":
                if hasattr(self, "filter_from_date") and hasattr(self, "filter_to_date"):
                    from_date_str = self.filter_from_date.get().strip()
                    to_date_str = self.filter_to_date.get().strip()
                    try:
                        fdt = datetime.strptime(from_date_str, "%d-%m-%Y").date() if from_date_str else None
                        tdt = datetime.strptime(to_date_str, "%d-%m-%Y").date() if to_date_str else None
                    except ValueError:
                        fdt = tdt = None
                        messagebox.showwarning("Invalid Date", "Please enter dates in DD-MM-YYYY format")
                        
            elif cat == "Payment Status":
                if hasattr(self, "dashboard_filter_payment_status_var"):
                    val = self.dashboard_filter_payment_status_var.get().strip()
                    if val:
                        payment_status_filter = val
                        
            elif cat == "Member Type":
                if hasattr(self, "filter_member_type_var"):
                    val = self.filter_member_type_var.get().strip()
                    if val:
                        member_type_filter = val
                        
            elif cat == "Payment Type":
                if hasattr(self, "dashboard_filter_payment_type_var"):
                    val = self.dashboard_filter_payment_type_var.get().strip()
                    if val:
                        payment_type_filter = val
        
        today = date.today()
        
        # Check if any filters are applied
        has_filters_applied = (
            (fdt is not None or tdt is not None) or
            payment_status_filter != "All" or
            member_type_filter != "All" or
            payment_type_filter != "All"
        )
        
        # Update filter status indicator
        if hasattr(self, 'filter_status_label'):
            self._update_filter_status(has_filters_applied)
        
        # Show current filter status in console for debugging
        if has_filters_applied:
            print(f"FILTERS ACTIVE: Payment Type={payment_type_filter}, Member Type={member_type_filter}, Payment Status={payment_status_filter}, Dates={fdt} to {tdt}")
        
        # Total members with optional member_type filter
        if member_type_filter == "All":
            total_members_row = self.db.fetchone("SELECT COUNT(*) as cnt FROM members")
            total_members = total_members_row["cnt"] if total_members_row else 0
        else:
            total_members_row = self.db.fetchone("SELECT COUNT(*) as cnt FROM members WHERE member_type=?", (member_type_filter,))
            total_members = total_members_row["cnt"] if total_members_row else 0

        self.lbl_total_members.config(text=f"Total Members: {total_members}")

        # Filter members for dues calculation based on member_type_filter
        if member_type_filter == "All":
            members = self.db.fetchall("SELECT id, name, flat_no, monthly_rent, member_type, join_date, total_paid_amount FROM members")
        else:
            members = self.db.fetchall("SELECT id, name, flat_no, monthly_rent, member_type, join_date, total_paid_amount FROM members WHERE member_type = ?", (member_type_filter,))
        # Fetch payments joined with members (apply member_type filter at DB level)
        if member_type_filter == "All":
            payments_rows = self.db.fetchall("""
                SELECT p.id, p.amount, p.date, p.payment_status, p.payment_type, m.member_type
                FROM payments p LEFT JOIN members m ON p.member_id = m.id
            """)
        else:
            payments_rows = self.db.fetchall("""
                SELECT p.id, p.amount, p.date, p.payment_status, p.payment_type, m.member_type
                FROM payments p JOIN members m ON p.member_id = m.id
                WHERE m.member_type = ?
            """, (member_type_filter,))

        # Python-side filtering for time period and payment status
        total_payments_sum = 0.0
        for r in payments_rows:
            # Filter by payment status
            p_status = r["payment_status"] or "Paid"
            if payment_status_filter != "All" and p_status != payment_status_filter:
                continue
            
            # Filter by payment type
            if payment_type_filter != "All" and r["payment_type"] != payment_type_filter:
                continue

            # Parse date robustly
            pd = self._parse_date(r["date"])
            
            # Filter by custom date range (Time Period filter)
            if fdt is not None or tdt is not None:
                if pd is None:
                    continue
                if fdt is not None and pd < fdt:
                    continue
                if tdt is not None and pd > tdt:
                    continue

            # If passed all filters, include amount
            try:
                amt = float(r["amount"]) if r["amount"] is not None else 0.0
            except Exception:
                amt = 0.0
            total_payments_sum += amt



        # Calculate total collection (all payments + event contributions)
        total_payments_all_row = self.db.fetchone("SELECT COALESCE(SUM(amount), 0) as total FROM payments")
        total_payments_all = total_payments_all_row["total"] if total_payments_all_row else 0.0
        event_total_row = self.db.fetchone("SELECT COALESCE(SUM(amount), 0) as total FROM event_contributions")
        event_total = event_total_row["total"] if event_total_row else 0.0
        total_collection = (total_payments_all or 0.0) + (event_total or 0.0)
        self.lbl_total_collection.config(text=f"Total Collection Amt: {total_collection:.2f}")

        # Open complaints
        open_complaints = self.db.fetchone("SELECT COUNT(*) as cnt FROM complaints WHERE status='Open'")["cnt"]
        self.lbl_open_complaints.config(text=f"Open Complaints: {open_complaints}")

        # Update dues treeview
        for i in self.dues_tree.get_children():
            self.dues_tree.delete(i)

        # Filter members for dues calculation based on member_type_filter
        if member_type_filter == "All":
            members = self.db.fetchall("SELECT id, name, flat_no, monthly_rent, member_type, join_date, total_paid_amount FROM members")
        else:
            members = self.db.fetchall("SELECT id, name, flat_no, monthly_rent, member_type, join_date, total_paid_amount FROM members WHERE member_type = ?", (member_type_filter,))

        # Initialize aggregates
        expected_monthly = 0.0
        unpaid_total = 0.0
        tenants_cnt = 0
        owners_cnt = 0

        # Maintenance charge aggregates per member type (respecting maintenance period filter)
        maint_rowhouse = 0.0
        maint_flat = 0.0
        maint_tenant = 0.0

        # Count all members (not just filtered ones) for tenant/owner counts if no member filter
        all_members = self.db.fetchall("SELECT member_type FROM members")
        for m in all_members:
            if m["member_type"] == "Tenant":
                tenants_cnt += 1
            else:
                owners_cnt += 1

        for member in members:
            # Determine last payment date robustly by looking at member payments and picking the latest date
            # Only consider rent payments for rent dues calculation
            payments_for_member = self.db.fetchall("SELECT date FROM payments WHERE member_id=? AND payment_type='Rent'", (member["id"],))
            latest_date_obj = None
            for p in payments_for_member:
                pd = self._parse_date(p["date"])
                if pd:
                    if latest_date_obj is None or pd > latest_date_obj:
                        latest_date_obj = pd

            last_payment_date_str = None
            if latest_date_obj:
                last_payment_date_str = latest_date_obj.strftime("%d-%m-%Y")

            monthly_rent = member["monthly_rent"] if member["monthly_rent"] is not None else 0.0
            due_amount = 0.0
            
            # Calculate dues based on filters
            if payment_type_filter != "All":
                # For payment type filters, show members who have payments of that type or could have dues of that type
                if payment_type_filter == "Rent" and monthly_rent > 0:
                    # For rent filter, calculate standard dues
                    due_amount = self.calculate_dues_for_member(member["id"], monthly_rent, last_payment_date_str, "All")
                elif payment_type_filter == "Maintenance charge":
                    # For maintenance charge, check if member has any maintenance payments or should have them
                    maintenance_payments = self.db.fetchall("SELECT amount FROM payments WHERE member_id=? AND payment_type='Maintenance charge'", (member["id"],))
                    if maintenance_payments or monthly_rent > 0:  # Show if has maintenance payments or should have rent
                        due_amount = self.calculate_dues_for_member(member["id"], monthly_rent, last_payment_date_str, "All")
                else:
                    # For other payment types, check if member has payments of that type
                    type_payments = self.db.fetchall("SELECT amount FROM payments WHERE member_id=? AND payment_type=?", (member["id"], payment_type_filter))
                    if type_payments:
                        due_amount = 0.01  # Small amount to show in list
            elif fdt is not None or tdt is not None:
                # Custom date range - show members with payments/dues in that range
                member_payments_in_range = self.db.fetchall("SELECT amount, date FROM payments WHERE member_id=?", (member["id"],))
                has_activity_in_range = False
                for p in member_payments_in_range:
                    pd = self._parse_date(p["date"])
                    if pd:
                        if (fdt is None or pd >= fdt) and (tdt is None or pd <= tdt):
                            has_activity_in_range = True
                            break
                
                # If no payments in range but member joined in range, show as due
                if not has_activity_in_range and monthly_rent > 0:
                    join_date = self._parse_date(member["join_date"])
                    if join_date and (fdt is None or join_date >= fdt) and (tdt is None or join_date <= tdt):
                        due_amount = monthly_rent
                elif has_activity_in_range:
                    due_amount = self.calculate_dues_for_member(member["id"], monthly_rent, last_payment_date_str, "All")
            else:
                # Standard dues calculation - show all members with outstanding dues
                due_amount = self.calculate_dues_for_member(member["id"], monthly_rent, last_payment_date_str, "All")

            # Aggregate stats
            monthly_rent_val = member["monthly_rent"] if member["monthly_rent"] is not None else 0.0
            expected_monthly += monthly_rent_val
            unpaid_total += due_amount

            # Maintenance charge sums (payment_type == 'Maintenance charge') respecting Maintenance Period filter
            payments_member = self.db.fetchall("SELECT amount, date FROM payments WHERE member_id=? AND payment_type='Maintenance charge'", (member["id"],))
            for p in payments_member:
                amt = float(p["amount"]) if p["amount"] is not None else 0.0
                pd = self._parse_date(p["date"])

                # Determine if this payment should be included based on maintenance period filter
                include_payment = True
                maint_period_filter = self.maint_period_var.get()
                if maint_period_filter == "Monthly":
                    include_payment = pd and pd.year == today.year and pd.month == today.month
                elif maint_period_filter == "Yearly":
                    include_payment = pd and pd.year == today.year
                elif maint_period_filter not in ["Till Today", "Monthly", "Yearly"]:
                    try:
                        dt = datetime.strptime(maint_period_filter, "%B %Y")
                        include_payment = pd and pd.year == dt.year and pd.month == dt.month
                    except Exception:
                        include_payment = True  # fallback include if parsing fails
                # else 'Till Today' includes all

                if not include_payment:
                    continue

                if member["member_type"] == "Row House Owner":
                    maint_rowhouse += amt
                elif member["member_type"] == "Flat Owner":
                    maint_flat += amt
                else:
                    maint_tenant += amt

            # Show in dues table based on filter criteria - simplified logic
            show_member = False
            
            if payment_type_filter != "All":
                # For payment type filters, show all members who should have this payment type
                if payment_type_filter == "Rent":
                    show_member = monthly_rent > 0  # All members with rent setup
                else:
                    # Check if member has any payments of this type
                    type_payments = self.db.fetchall("SELECT id FROM payments WHERE member_id=? AND payment_type=?", (member["id"], payment_type_filter))
                    show_member = len(type_payments) > 0 or monthly_rent > 0
                    
            elif payment_status_filter != "All":
                # For payment status filter
                if monthly_rent > 0:
                    if payment_status_filter == "Paid":
                        show_member = due_amount <= 0  # No outstanding dues
                    elif payment_status_filter == "Unpaid":
                        show_member = due_amount > 0   # Has outstanding dues
                    else:
                        show_member = True  # For other statuses
                        
            elif member_type_filter != "All":
                # Member type filter is already handled in SQL query
                show_member = True  # Show all members of this type
                
            elif fdt is not None or tdt is not None:
                # Date range filter - show members that had activity or joined in range
                show_member = has_activity_in_range
                if not show_member and monthly_rent > 0:
                    join_date_obj = self._parse_date(member["join_date"])
                    if join_date_obj and (fdt is None or join_date_obj >= fdt) and (tdt is None or join_date_obj <= tdt):
                        show_member = True
                
            else:
                # No filters applied - show members with outstanding dues
                show_member = due_amount > 0
            
            if show_member:
                # For rent filter, ensure we show actual rent amount even if no dues
                display_due_amount = due_amount
                if payment_type_filter == "Rent" and monthly_rent > 0 and due_amount == 0:
                    display_due_amount = 0.00  # Show 0.00 for members with rent setup but no dues
                
                print(f"Showing member: {member['name']} - {payment_type_filter} filter - Due: {display_due_amount}")
                
                # Calculate total paid amount live from payments table (keeps Dashboard and Members tab consistent)
                paid_row = self.db.fetchone("SELECT SUM(amount) as total FROM payments WHERE member_id=?", (member["id"],))
                total_paid_amount = paid_row["total"] if paid_row and paid_row["total"] is not None else 0.0
                
                # Calculate balance amount (amount still due)
                if monthly_rent is not None and total_paid_amount is not None:
                    balance_amount = max(monthly_rent - total_paid_amount, 0)
                else:
                    balance_amount = 0.0

                self.dues_tree.insert("", tk.END, values=(
                    member["id"],
                    member["name"],
                    member["flat_no"],
                    member["monthly_rent"],
                    last_payment_date_str if last_payment_date_str else "N/A",
                    f"{display_due_amount:.2f}",
                    f"{balance_amount:.2f}",
                    f"{total_paid_amount:.2f}"
                ))

        # ---- Insert totals row in dues_tree ----
        # Sum only rows currently visible in dues_tree (after filters)
        total_due_amount = 0.0
        total_balance_amount = 0.0
        total_paid_amount_col = 0.0
        for item in self.dues_tree.get_children():
            vals = self.dues_tree.item(item)["values"]
            if not vals:
                continue
            try:
                total_due_amount += float(vals[5])  # due_amount column
                total_balance_amount += float(vals[6])  # balance_amount column
                total_paid_amount_col += float(vals[7])  # paid_amount column
            except Exception:
                continue
        # Remove existing totals row if present
        for item in self.dues_tree.get_children():
            if "totals" in self.dues_tree.item(item, "tags"):
                self.dues_tree.delete(item)
        # Insert new totals row (blank id/name etc.)
        self.dues_tree.insert("", tk.END, values=("", "", "", "", "Totals:", f"{total_due_amount:.2f}", f"{total_balance_amount:.2f}", f"{total_paid_amount_col:.2f}"), tags=("totals",))

        # Calculate overall outstanding irrespective of filters
        # Recalculate overall outstanding based on join date and payments history
        global_unpaid = 0.0
        all_members_details = self.db.fetchall("SELECT id, monthly_rent, join_date FROM members")
        today = date.today()
        for mdet in all_members_details:
            # Parse monthly rent safely
            try:
                monthly_rent_val = float(mdet["monthly_rent"] or 0)
            except ValueError:
                monthly_rent_val = 0.0
            # Parse join date
            join_date_raw = mdet["join_date"]
            join_dt = None
            if isinstance(join_date_raw, date):
                join_dt = join_date_raw
            elif isinstance(join_date_raw, str):
                for fmt in ("%Y-%m-%d", "%d-%m-%Y"):
                    try:
                        join_dt = datetime.strptime(join_date_raw, fmt).date()
                        break
                    except Exception:
                        continue
            if join_dt is None:
                # Skip if join date invalid
                continue
            # Months since join date (inclusive of current month)
            months_since_join = (today.year - join_dt.year) * 12 + (today.month - join_dt.month) + 1
            expected_total_due = monthly_rent_val * months_since_join
            # Sum of all payments done by member
            paid_row = self.db.fetchone("SELECT COALESCE(SUM(amount),0) as paid_total FROM payments WHERE member_id=? AND payment_type='Rent'", (mdet["id"],))
            paid_total = paid_row["paid_total"] if paid_row else 0.0
            member_outstanding = max(expected_total_due - paid_total, 0.0)
            global_unpaid += member_outstanding

        # Debug
        print(f"DEBUG Total Unpaid Calculated = {global_unpaid}")
        # Update aggregate summary labels with global unpaid
        self.lbl_total_unpaid.config(text=f"Total Unpaid Amt: {global_unpaid:.2f}")
        self.lbl_tenants.config(text=f"Total Tenants: {tenants_cnt}")
        self.lbl_owners.config(text=f"Total Owners: {owners_cnt}")

        # Update maintenance charge labels (total for selected period)
        self.lbl_maint_rowhouse.config(text=f"{maint_rowhouse:.2f}")
        self.lbl_maint_flat.config(text=f"{maint_flat:.2f}")
        self.lbl_maint_tenant.config(text=f"{maint_tenant:.2f}")
        maint_total = maint_rowhouse + maint_flat + maint_tenant
        self.lbl_maint_total.config(text=f"{maint_total:.2f}")
        
        # Calculate today's payment received
        today_str = today.strftime("%d-%m-%Y")
        today_payments_row = self.db.fetchone("""
            SELECT COALESCE(SUM(amount), 0) as today_total 
            FROM payments 
            WHERE date = ?
        """, (today_str,))
        today_payments_sum = today_payments_row["today_total"] if today_payments_row else 0.0
        self.lbl_todays_payment.config(text=f"Today's Payment Received: {today_payments_sum:.2f}")
        
        # Show success message if filters were applied
        if has_filters_applied:
            # Create a temporary status message (optional - can be removed if too intrusive)
            pass  # The filter status indicator is enough
        
        # Update rent collection summary
        self.update_rent_collection_summary()

    # --- Exports & Backup ---
    def export_payments_csv(self):
        rows = self.db.fetchall("""
            SELECT p.id, m.name as member, p.amount, p.date, p.note
            FROM payments p LEFT JOIN members m ON p.member_id = m.id
            ORDER BY p.id ASC
        """)
        if not rows:
            messagebox.showinfo("Export", "No payments to export")
            return
        filename = os.path.join(EXPORT_DIR, f"payments_{datetime.now().strftime('%d%m%Y_%H%M%S')}.csv")
        cols = ["id", "member", "amount", "date", "note"]
        export_rows_to_csv(rows, cols, filename)
        open_file_in_default_app(filename)

    # --- Parking ---
    # All parking functions have been removed as requested

    # --- Parking ---
    # All parking functions have been removed as requested

    # --- Inventory ---
    def export_inventory_csv(self):
        rows = self.db.fetchall("SELECT id, item_name, quantity, unit, min_required FROM inventory")
        if not rows:
            messagebox.showinfo("Export", "No inventory items to export")
            return
        filename = os.path.join(EXPORT_DIR, f"inventory_{datetime.now().strftime('%d%m%Y_%H%M%S')}.csv")
        cols = ["id", "item_name", "quantity", "unit", "min_required"]
        export_rows_to_csv(rows, cols, filename)
        open_file_in_default_app(filename)

    def export_inventory_usage_csv(self):
        rows = self.db.fetchall("""
            SELECT u.id, i.item_name, u.quantity, u.date, u.note
            FROM inventory_usage u LEFT JOIN inventory i ON u.inventory_id = i.id
            ORDER BY u.date DESC
        """)
        if not rows:
            messagebox.showinfo("Export", "No usage log to export")
            return
        filename = os.path.join(EXPORT_DIR, f"inventory_usage_{datetime.now().strftime('%d%m%Y_%H%M%S')}.csv")
        cols = ["id", "item_name", "quantity", "date", "note"]
        export_rows_to_csv(rows, cols, filename)
        open_file_in_default_app(filename)

    def refresh_inventory(self):
        for i in self.inventory_tree.get_children():
            self.inventory_tree.delete(i)
        rows = self.db.fetchall("SELECT id, item_name, quantity, unit, min_required FROM inventory ORDER BY item_name")
        for r in rows:
            self.inventory_tree.insert("", tk.END, values=(r["id"], r["item_name"], r["quantity"], r["unit"], r["min_required"]))

    def refresh_inventory_tab(self):
        """Refresh all inventory-related data in the tab"""
        self.refresh_inventory()
        self.refresh_flat_usage()
        self.refresh_event_usage()
        self.update_inventory_summary()

    def refresh_flat_usage(self):
        """Refresh flat-wise inventory usage display with better organization"""
        # Clear existing items
        for i in self.flat_usage_tree.get_children():
            self.flat_usage_tree.delete(i)
        
        # Get flat-wise usage data with better grouping
        rows = self.db.fetchall("""
            SELECT i.item_name, u.quantity, u.date, u.note
            FROM inventory_usage u 
            LEFT JOIN inventory i ON u.inventory_id = i.id
            WHERE LOWER(u.note) LIKE '%flat%' OR u.note LIKE '%Flat%'
            ORDER BY u.date DESC
        """)
        
        # Group by flat number extracted from note
        flat_usage = {}
        for r in rows:
            # Try to extract flat number from note
            note = r["note"] or ""
            flat_no = "Unknown"
            # Simple extraction - look for patterns like "Flat A101" or "flat A101"
            import re
            flat_match = re.search(r'[Ff]lat\s+([A-Z0-9]+)', note)
            if flat_match:
                flat_no = flat_match.group(1)
            
            if flat_no not in flat_usage:
                flat_usage[flat_no] = []
            flat_usage[flat_no].append({
                "item_name": r["item_name"],
                "quantity": r["quantity"],
                "date": r["date"],
                "note": note
            })
        
        # Display in treeview with better organization
        for flat_no in sorted(flat_usage.keys()):
            items = flat_usage[flat_no]
            # Group items by name for this flat
            item_summary = {}
            for item in items:
                item_name = item["item_name"]
                if item_name not in item_summary:
                    item_summary[item_name] = {
                        "total_quantity": 0,
                        "last_used": item["date"],
                        "notes": []
                    }
                item_summary[item_name]["total_quantity"] += item["quantity"]
                if item["date"] > item_summary[item_name]["last_used"]:
                    item_summary[item_name]["last_used"] = item["date"]
                if item["note"] not in item_summary[item_name]["notes"]:
                    item_summary[item_name]["notes"].append(item["note"])
            
            # Display summary for each item
            for item_name, summary in item_summary.items():
                notes_display = "; ".join(summary["notes"][:2])  # Show first 2 notes
                if len(summary["notes"]) > 2:
                    notes_display += f" (+{len(summary['notes'])-2} more)"
                    
                self.flat_usage_tree.insert("", tk.END, values=(
                    flat_no,
                    item_name,
                    summary["total_quantity"],
                    summary["last_used"]
                ))

    def refresh_event_usage(self):
        """Refresh event-related inventory usage display with better organization"""
        # Clear existing items
        for i in self.event_usage_tree.get_children():
            self.event_usage_tree.delete(i)
        
        # Get event-related usage data
        rows = self.db.fetchall("""
            SELECT i.item_name, u.quantity, u.date, u.note
            FROM inventory_usage u 
            LEFT JOIN inventory i ON u.inventory_id = i.id
            WHERE LOWER(u.note) LIKE '%event%' OR u.note LIKE '%Event%'
            ORDER BY u.date DESC
        """)
        
        # Group by event name extracted from note
        event_usage = {}
        for r in rows:
            # Try to extract event name from note
            note = r["note"] or ""
            event_name = "Unnamed Event"
            # Look for patterns like "Event: Diwali Celebration" or "event: Holi"
            import re
            event_match = re.search(r'[Ee]vent:\s*([^|]+)', note)
            if event_match:
                event_name = event_match.group(1).strip()
            
            if event_name not in event_usage:
                event_usage[event_name] = []
            event_usage[event_name].append({
                "item_name": r["item_name"],
                "quantity": r["quantity"],
                "date": r["date"],
                "note": note
            })
        
        # Display in treeview with better organization
        for event_name in sorted(event_usage.keys()):
            items = event_usage[event_name]
            # Group items by name for this event
            item_summary = {}
            for item in items:
                item_name = item["item_name"]
                if item_name not in item_summary:
                    item_summary[item_name] = {
                        "total_quantity": 0,
                        "date_used": item["date"],
                        "notes": []
                    }
                item_summary[item_name]["total_quantity"] += item["quantity"]
                if item["date"] > item_summary[item_name]["date_used"]:
                    item_summary[item_name]["date_used"] = item["date"]
                if item["note"] not in item_summary[item_name]["notes"]:
                    item_summary[item_name]["notes"].append(item["note"])
            
            # Display summary for each item
            for item_name, summary in item_summary.items():
                notes_display = "; ".join(summary["notes"][:2])  # Show first 2 notes
                if len(summary["notes"]) > 2:
                    notes_display += f" (+{len(summary['notes'])-2} more)"
                    
                self.event_usage_tree.insert("", tk.END, values=(
                    event_name,
                    item_name,
                    summary["total_quantity"],
                    summary["date_used"]
                ))

    def update_inventory_summary(self):
        """Update inventory summary statistics with more detailed information"""
        # Get total items
        total_items_row = self.db.fetchone("SELECT COUNT(*) as count FROM inventory")
        total_items = total_items_row["count"] if total_items_row else 0
        
        # Get total quantity
        total_qty_row = self.db.fetchone("SELECT SUM(quantity) as total FROM inventory")
        total_quantity = total_qty_row["total"] if total_qty_row and total_qty_row["total"] else 0
        
        # Get low stock items (quantity <= min_required)
        low_stock_row = self.db.fetchone("""
            SELECT COUNT(*) as count FROM inventory 
            WHERE quantity <= min_required AND min_required > 0
        """)
        low_stock = low_stock_row["count"] if low_stock_row else 0
        
        # Get items with zero quantity
        zero_stock_row = self.db.fetchone("""
            SELECT COUNT(*) as count FROM inventory 
            WHERE quantity = 0
        """)
        zero_stock = zero_stock_row["count"] if zero_stock_row else 0
        
        # Get recent usage (last 30 days)
        recent_usage_row = self.db.fetchone("""
            SELECT COUNT(*) as count FROM inventory_usage 
            WHERE date >= date('now', '-30 days')
        """)
        recent_usage = recent_usage_row["count"] if recent_usage_row else 0
        
        # Update labels with more detailed information
        self.total_items_label.config(text=f"Total Items: {total_items}")
        self.total_quantity_label.config(text=f"Total Quantity: {total_quantity}")
        
        # Update low stock label with more information
        if low_stock > 0:
            self.low_stock_label.config(text=f"Low Stock Items: {low_stock} (Zero Stock: {zero_stock})", foreground="red")
        elif zero_stock > 0:
            self.low_stock_label.config(text=f"Low Stock Items: {low_stock} (Zero Stock: {zero_stock})", foreground="orange")
        else:
            self.low_stock_label.config(text=f"Low Stock Items: {low_stock} (Zero Stock: {zero_stock})", foreground="black")
        
        # Add recent usage info
        if not hasattr(self, 'recent_usage_label'):
            # Find the summary frame (it's the parent of the low_stock_label)
            summary_frame = self.low_stock_label.master
            self.recent_usage_label = ttk.Label(summary_frame, text="")
            self.recent_usage_label.pack(anchor="w", pady=2)
        self.recent_usage_label.config(text=f"Recent Usage (30 days): {recent_usage}")

    def export_flat_usage_csv(self):
        """Export flat-wise inventory usage to CSV with detailed information"""
        rows = self.db.fetchall("""
            SELECT i.item_name, u.quantity, u.date, u.note
            FROM inventory_usage u 
            LEFT JOIN inventory i ON u.inventory_id = i.id
            WHERE LOWER(u.note) LIKE '%flat%' OR u.note LIKE '%Flat%'
            ORDER BY u.date DESC
        """)
        
        if not rows:
            messagebox.showinfo("Export", "No flat usage data to export")
            return
        
        # Process data for export with better organization
        export_data = []
        flat_usage = {}
        
        # Group by flat number
        for r in rows:
            note = r["note"] or ""
            flat_no = "Unknown"
            import re
            flat_match = re.search(r'[Ff]lat\s+([A-Z0-9]+)', note)
            if flat_match:
                flat_no = flat_match.group(1)
            
            if flat_no not in flat_usage:
                flat_usage[flat_no] = []
            flat_usage[flat_no].append({
                "item_name": r["item_name"],
                "quantity": r["quantity"],
                "date": r["date"],
                "note": note
            })
        
        # Create detailed export data
        for flat_no, items in flat_usage.items():
            # Group items by name for this flat
            item_summary = {}
            for item in items:
                item_name = item["item_name"]
                if item_name not in item_summary:
                    item_summary[item_name] = {
                        "total_quantity": 0,
                        "usage_dates": [],
                        "notes": []
                    }
                item_summary[item_name]["total_quantity"] += item["quantity"]
                item_summary[item_name]["usage_dates"].append(item["date"])
                if item["note"] not in item_summary[item_name]["notes"]:
                    item_summary[item_name]["notes"].append(item["note"])
            
            # Add summary rows for each item
            for item_name, summary in item_summary.items():
                first_date = min(summary["usage_dates"])
                last_date = max(summary["usage_dates"])
                notes_combined = "; ".join(summary["notes"])
                
                export_data.append({
                    "flat_no": flat_no,
                    "item_name": item_name,
                    "total_quantity_used": summary["total_quantity"],
                    "first_usage_date": first_date,
                    "last_usage_date": last_date,
                    "usage_count": len(summary["usage_dates"]),
                    "notes": notes_combined
                })
        
        filename = os.path.join(EXPORT_DIR, f"flat_inventory_usage_detailed_{datetime.now().strftime('%d%m%Y_%H%M%S')}.csv")
        cols = ["flat_no", "item_name", "total_quantity_used", "first_usage_date", "last_usage_date", "usage_count", "notes"]
        export_rows_to_csv(export_data, cols, filename)
        open_file_in_default_app(filename)
        messagebox.showinfo("Export Complete", f"Flat usage data exported successfully!\n\nFile: {filename}")

    def export_event_usage_csv(self):
        """Export event-related inventory usage to CSV with detailed information"""
        rows = self.db.fetchall("""
            SELECT i.item_name, u.quantity, u.date, u.note
            FROM inventory_usage u 
            LEFT JOIN inventory i ON u.inventory_id = i.id
            WHERE LOWER(u.note) LIKE '%event%' OR u.note LIKE '%Event%'
            ORDER BY u.date DESC
        """)
        
        if not rows:
            messagebox.showinfo("Export", "No event usage data to export")
            return
        
        # Process data for export with better organization
        export_data = []
        event_usage = {}
        
        # Group by event name
        for r in rows:
            note = r["note"] or ""
            event_name = "Unnamed Event"
            import re
            event_match = re.search(r'[Ee]vent:\s*([^|]+)', note)
            if event_match:
                event_name = event_match.group(1).strip()
            
            if event_name not in event_usage:
                event_usage[event_name] = []
            event_usage[event_name].append({
                "item_name": r["item_name"],
                "quantity": r["quantity"],
                "date": r["date"],
                "note": note
            })
        
        # Create detailed export data
        for event_name, items in event_usage.items():
            # Group items by name for this event
            item_summary = {}
            for item in items:
                item_name = item["item_name"]
                if item_name not in item_summary:
                    item_summary[item_name] = {
                        "total_quantity": 0,
                        "usage_dates": [],
                        "notes": []
                    }
                item_summary[item_name]["total_quantity"] += item["quantity"]
                item_summary[item_name]["usage_dates"].append(item["date"])
                if item["note"] not in item_summary[item_name]["notes"]:
                    item_summary[item_name]["notes"].append(item["note"])
            
            # Add summary rows for each item
            for item_name, summary in item_summary.items():
                first_date = min(summary["usage_dates"])
                last_date = max(summary["usage_dates"])
                notes_combined = "; ".join(summary["notes"])
                
                export_data.append({
                    "event_name": event_name,
                    "item_name": item_name,
                    "total_quantity_used": summary["total_quantity"],
                    "first_usage_date": first_date,
                    "last_usage_date": last_date,
                    "usage_count": len(summary["usage_dates"]),
                    "notes": notes_combined
                })
        
        filename = os.path.join(EXPORT_DIR, f"event_inventory_usage_detailed_{datetime.now().strftime('%d%m%Y_%H%M%S')}.csv")
        cols = ["event_name", "item_name", "total_quantity_used", "first_usage_date", "last_usage_date", "usage_count", "notes"]
        export_rows_to_csv(export_data, cols, filename)
        open_file_in_default_app(filename)
        messagebox.showinfo("Export Complete", f"Event usage data exported successfully!\n\nFile: {filename}")

    # --- Refresh and Dashboard update ---
    def refresh_events(self):
        """Refresh events tree with budget and contribution data"""
        for i in self.events_tree.get_children():
            self.events_tree.delete(i)
        
        # Get events with calculated totals
        rows = self.db.fetchall("""
            SELECT e.id, e.title, e.event_date, e.status, e.total_budget,
                   COALESCE(SUM(ec.amount), 0) as total_collected
            FROM events e 
            LEFT JOIN event_contributions ec ON e.id = ec.event_id 
            GROUP BY e.id, e.title, e.event_date, e.status, e.total_budget
            ORDER BY e.event_date DESC
        """)
        
        for r in rows:
            # Format currency values
            budget = f"₹{r['total_budget']:.0f}" if r['total_budget'] else "₹0"
            collected = f"₹{r['total_collected']:.0f}" if r['total_collected'] else "₹0"
            
            self.events_tree.insert("", tk.END, values=(
                r["id"], r["title"], r["event_date"], 
                r["status"] or "Planned", budget, collected
            ))
        
        # Update statistics
        self.update_event_statistics()

    def update_rent_collection_summary(self):
        """Update the rent collection summary based on selected month and year"""
        # Get selected month and year
        selected_month_name = self.rent_month_var.get()
        selected_year = self.rent_year_var.get()
        
        # Convert month name to number
        month_names = ["January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        selected_month = month_names.index(selected_month_name) + 1
        
        # Calculate total tenant rent received for the selected month and year
        rent_received_query = """
            SELECT COALESCE(SUM(p.amount), 0) as total_rent
            FROM payments p
            JOIN members m ON p.member_id = m.id
            WHERE m.member_type = 'Tenant'
            AND p.payment_type = 'Rent'
            AND strftime('%m', substr(p.date, 7, 4) || '-' || substr(p.date, 4, 2) || '-' || substr(p.date, 1, 2)) = ?
            AND strftime('%Y', substr(p.date, 7, 4) || '-' || substr(p.date, 4, 2) || '-' || substr(p.date, 1, 2)) = ?
        """
        
        # Execute query with parameters
        rent_received_row = self.db.fetchone(rent_received_query, (f"{selected_month:02d}", selected_year))
        rent_received = rent_received_row["total_rent"] if rent_received_row else 0.0
        
        # Calculate expected rent for the selected month and year
        expected_rent_query = """
            SELECT COALESCE(SUM(m.monthly_rent), 0) as expected_rent
            FROM members m
            WHERE m.member_type = 'Tenant'
        """
        
        # For monthly expected, we just sum all tenant rents
        expected_rent_row = self.db.fetchone(expected_rent_query)
        expected_rent = expected_rent_row["expected_rent"] if expected_rent_row else 0.0
        
        # Update the labels for month
        self.lbl_month_rent_received.config(text=f"→ Total Tenant Rent Received: ₹{rent_received:.2f}")
        self.lbl_month_rent_expected.config(text=f"   (Expected: ₹{expected_rent:.2f})")
        
        # Calculate total tenant rent received for the selected year
        year_rent_received_query = """
            SELECT COALESCE(SUM(p.amount), 0) as total_rent
            FROM payments p
            JOIN members m ON p.member_id = m.id
            WHERE m.member_type = 'Tenant'
            AND p.payment_type = 'Rent'
            AND strftime('%Y', substr(p.date, 7, 4) || '-' || substr(p.date, 4, 2) || '-' || substr(p.date, 1, 2)) = ?
        """
        
        # Execute query with parameters
        year_rent_received_row = self.db.fetchone(year_rent_received_query, (selected_year,))
        year_rent_received = year_rent_received_row["total_rent"] if year_rent_received_row else 0.0
        
        # Calculate expected rent for the selected year (monthly rent * 12)
        expected_yearly_rent = expected_rent * 12
        
        # Update the labels for year
        self.lbl_year_rent_received.config(text=f"→ Total Tenant Rent Received: ₹{year_rent_received:.2f}")
        self.lbl_year_rent_expected.config(text=f"   (Expected: ₹{expected_yearly_rent:.2f})")

    # --- Backup ---
    def backup_db(self):
        src = Path(DB_FILE)
        if not src.exists():
            messagebox.showerror("Backup", "Database file not found")
            return
        os.makedirs(BACKUP_DIR, exist_ok=True)
        dest = Path(BACKUP_DIR) / f"colony_backup_{datetime.now().strftime('%d%m%Y_%H%M%S')}.db"
        try:
            shutil.copy2(src, dest)
            messagebox.showinfo("Backup", f"Backup created at {dest}")
            open_file_in_default_app(dest)
        except Exception as e:
            messagebox.showerror("Backup Error", str(e))

    # --- Optional sample data helper for quicker testing ---
    def add_sample_data(self):
        # Add sample staff data for testing
        if self.db.fetchone("SELECT COUNT(*) as c FROM staff")["c"] == 0:
            self.db.execute("INSERT INTO staff (name, role, phone, salary, joined_date, status) VALUES (?, ?, ?, ?, ?, ?)",
                            ("Raj Kumar", "Security Guard", "9876543210", 15000.0, date.today(), "Active"))
            self.db.execute("INSERT INTO staff (name, role, phone, salary, joined_date, status) VALUES (?, ?, ?, ?, ?, ?)",
                            ("Sunita Sharma", "Cleaner", "9123456789", 12000.0, date.today(), "Active"))
            self.db.execute("INSERT INTO staff (name, role, phone, salary, joined_date, status) VALUES (?, ?, ?, ?, ?, ?)",
                            ("Mohan Singh", "Maintenance", "9988776655", 18000.0, date.today(), "On Leave"))
            print("✅ Added sample staff data for testing")
        
        if self.db.fetchone("SELECT COUNT(*) as c FROM members")["c"] == 0:
            self.db.execute("INSERT INTO members (name, phone, email, flat_no, join_date, monthly_rent) VALUES (?, ?, ?, ?, ?, ?)",
                            ("Ramesh Kumar", "9876543210", "ramesh@example.com", "A101", date.today(), 5000.0))
            self.db.execute("INSERT INTO members (name, phone, email, flat_no, join_date, monthly_rent) VALUES (?, ?, ?, ?, ?, ?)",
                            ("Sonia Mehta", "9123456780", "sonia@example.com", "A102", date.today(), 4500.0))
            self.db.execute("INSERT INTO payments (member_id, amount, date, note) VALUES (?, ?, ?, ?)", (1, 5000.0, date.today().strftime('%d-%m-%Y'), "Monthly"))
            self.db.execute("INSERT INTO complaints (member_id, title, description, date, status) VALUES (?, ?, ?, ?, ?)", (2, "Water leakage", "Leak in wash area", date.today(), "Open"))
            self.refresh_all()


# --- Dual Mode Interface after Master Authentication ---
class DualModeInterface(tk.Tk):
    """Unified interface with Developer Mode and Customer Mode options"""
    
    def __init__(self):
        super().__init__()
        self.title("Colony Maintenance Manager - Access Control")
        self.geometry("800x600")
        self.resizable(False, False)
        self.configure(bg="#f8fafc")
        
        self.license_manager = LicenseManager()
        self.selected_mode = None
        
        self._build_ui()
        self._center_window()
        
        # Make window modal
        self.transient()
        self.grab_set()
        self.attributes('-topmost', True)
        
        # Handle window close
        self.protocol("WM_DELETE_WINDOW", self._on_close)
    
    def _build_ui(self):
        """Build the dual mode interface"""
        # Main container
        main_frame = tk.Frame(self, bg="#f8fafc", padx=40, pady=40)
        main_frame.pack(fill="both", expand=True)
        
        # Header
        header_frame = tk.Frame(main_frame, bg="#f8fafc")
        header_frame.pack(fill="x", pady=(0, 30))
        
        title_label = tk.Label(header_frame, 
                              text="🏢 Colony Maintenance Manager",
                              font=("Segoe UI", 20, "bold"),
                              bg="#f8fafc", fg="#1e293b")
        title_label.pack()
        
        subtitle_label = tk.Label(header_frame,
                                 text="Choose Your Access Mode",
                                 font=("Segoe UI", 12),
                                 bg="#f8fafc", fg="#64748b")
        subtitle_label.pack(pady=(5, 0))
        
        # Authentication status
        auth_status = tk.Label(header_frame,
                              text="✅ Master Authentication Successful",
                              font=("Segoe UI", 10, "bold"),
                              bg="#f8fafc", fg="#16a34a")
        auth_status.pack(pady=(10, 0))
        
        # Mode selection container
        modes_frame = tk.Frame(main_frame, bg="#f8fafc")
        modes_frame.pack(fill="both", expand=True, pady=(20, 0))
        
        # Developer Mode Card
        dev_card = tk.Frame(modes_frame, bg="#dbeafe", relief="solid", bd=2)
        dev_card.pack(side="left", fill="both", expand=True, padx=(0, 15))
        
        dev_header = tk.Frame(dev_card, bg="#3b82f6", height=60)
        dev_header.pack(fill="x")
        dev_header.pack_propagate(False)
        
        tk.Label(dev_header, text="👨‍💻 Developer Mode",
                font=("Segoe UI", 16, "bold"),
                bg="#3b82f6", fg="white").pack(expand=True)
        
        dev_content = tk.Frame(dev_card, bg="#dbeafe", padx=20, pady=20)
        dev_content.pack(fill="both", expand=True)
        
        # Developer mode features
        dev_features = [
            "✅ No activation required",
            "✅ Full administrative access", 
            "✅ Database management tools",
            "✅ License generation capabilities",
            "✅ Customer analytics dashboard",
            "✅ System configuration access"
        ]
        
        for feature in dev_features:
            tk.Label(dev_content, text=feature,
                    font=("Segoe UI", 10),
                    bg="#dbeafe", fg="#1e40af",
                    anchor="w").pack(fill="x", pady=2)
        
        # Developer mode button
        dev_btn = tk.Button(dev_content, 
                           text="🚀 Enter Developer Mode",
                           command=self._enter_developer_mode,
                           font=("Segoe UI", 12, "bold"),
                           bg="#3b82f6", fg="white",
                           relief="flat", padx=20, pady=12,
                           cursor="hand2")
        dev_btn.pack(pady=(20, 0), fill="x")
        
        # Customer Mode Card
        cust_card = tk.Frame(modes_frame, bg="#fef3c7", relief="solid", bd=2)
        cust_card.pack(side="right", fill="both", expand=True, padx=(15, 0))
        
        cust_header = tk.Frame(cust_card, bg="#f59e0b", height=60)
        cust_header.pack(fill="x")
        cust_header.pack_propagate(False)
        
        tk.Label(cust_header, text="👥 Customer Mode",
                font=("Segoe UI", 16, "bold"),
                bg="#f59e0b", fg="white").pack(expand=True)
        
        cust_content = tk.Frame(cust_card, bg="#fef3c7", padx=20, pady=20)
        cust_content.pack(fill="both", expand=True)
        
        # Customer mode features
        cust_features = [
            "🔑 Requires license activation",
            "📋 Shows machine ID for licensing",
            "💼 Standard user interface",
            "📊 Basic management features",
            "🔒 Secure license validation"
        ]
        
        for feature in cust_features:
            tk.Label(cust_content, text=feature,
                    font=("Segoe UI", 10),
                    bg="#fef3c7", fg="#92400e",
                    anchor="w").pack(fill="x", pady=2)
        
        # Customer mode button
        cust_btn = tk.Button(cust_content,
                            text="🏢 Enter Customer Mode", 
                            command=self._enter_customer_mode,
                            font=("Segoe UI", 12, "bold"),
                            bg="#f59e0b", fg="white",
                            relief="flat", padx=20, pady=12,
                            cursor="hand2")
        cust_btn.pack(pady=(20, 0), fill="x")
        
        # Footer
        footer_frame = tk.Frame(main_frame, bg="#f8fafc")
        footer_frame.pack(fill="x", pady=(30, 0))
        
        info_text = ("Developer Mode: Direct access with full privileges\n"
                    "Customer Mode: Standard license activation required")
        
        tk.Label(footer_frame, text=info_text,
                font=("Segoe UI", 9),
                bg="#f8fafc", fg="#6b7280",
                justify="center").pack()
    
    def _center_window(self):
        """Center window on screen"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")
    
    def _enter_developer_mode(self):
        """Enter developer mode - bypass license check"""
        print("🚀 Entering Developer Mode - No activation required")
        self.selected_mode = "developer"
        self.destroy()
    
    def _enter_customer_mode(self):
        """Enter customer mode - show activation window"""
        print("🏢 Entering Customer Mode - Activation required")
        self.selected_mode = "customer"
        self.destroy()
    
    def _on_close(self):
        """Handle window close"""
        self.selected_mode = None
        self.destroy()

# --- Main launcher: Master Auth -> Dual Mode -> Application ---
def show_master_authentication():
    """Show master authentication dialog"""
    print("🔐 Starting Master Authentication Dialog...")
    
    try:
        root = tk.Tk()
        root.withdraw()  # Hide the root window
        
        dialog = MasterAuthenticationDialog(root)
        print("📝 Master Authentication window opened")
        print("🔑 Please enter credentials:")
        print("   Master ID: SANTOSH_MASTER_DEV_2024")
        print("   Password: COLONY_MASTER_SECURE_2024")
        
        root.wait_window(dialog)
        
        result = dialog.result
        print(f"🎯 Master Authentication result: {result}")
        
        root.destroy()
        return result
        
    except Exception as e:
        print(f"❌ Master Authentication error: {e}")
        import traceback
        traceback.print_exc()
        return False

def main():
    """Main application launcher with integrated dual mode system"""
    print("🏢 Colony Maintenance Manager - Starting Up...")
    
    # Step 1: Master Authentication
    print("Checking master authentication...")
    
    # Check if master auth file exists
    master_auth_file = os.path.join(APP_DATA_DIR, "master_auth.key")
    master_authenticated = os.path.exists(master_auth_file)
    
    if not master_authenticated:
        print("Master authentication required...")
        if not show_master_authentication():
            print("❌ Master authentication failed or cancelled. Exiting.")
            return
        print("✅ Master authentication successful!")
        master_authenticated = True
    else:
        print("✅ Master authentication found - proceeding...")
    
    # Step 2: Show Dual Mode Interface
    print("Showing dual mode interface...")
    dual_mode = DualModeInterface()
    dual_mode.mainloop()
    
    if not dual_mode.selected_mode:
        print("❌ No mode selected. Exiting.")
        return
    
    selected_mode = dual_mode.selected_mode
    print(f"✅ Selected mode: {selected_mode.upper()}")
    
    # Step 3: Handle Selected Mode
    if selected_mode == "developer":
        # Developer Mode - Direct access
        print("🚀 Developer Mode: Bypassing license check...")
        
        # Direct to login
        db = Database()
        login = LoginWindow(db)
        login.mainloop()
        
        if login.authenticated:
            print("✅ Developer login successful - launching application...")
            app = ColonyApp(db, login.username)
            app.add_sample_data()
            app.mainloop()
        else:
            print("❌ Developer login cancelled.")
    
    elif selected_mode == "customer":
        # Customer Mode - Show activation window
        print("🏢 Customer Mode: Showing activation window...")
        
        # Create and show license window with force customer mode
        license_window = LicenseWindow(force_customer_mode=True)
        license_window.mainloop()
        
        # Check if license was validated
        if hasattr(license_window, 'license_valid') and license_window.license_valid:
            print("✅ Customer license validated - proceeding to login...")
            
            # Proceed to login
            db = Database()
            login = LoginWindow(db)
            login.mainloop()
            
            if login.authenticated:
                print("✅ Customer login successful - launching application...")
                app = ColonyApp(db, login.username)
                app.add_sample_data()
                app.mainloop()
            else:
                print("❌ Customer login cancelled.")
        else:
            print("❌ Customer license validation failed or cancelled.")
    
    print("🏢 Colony Maintenance Manager - Session ended.")


if __name__ == "__main__":
    main()
